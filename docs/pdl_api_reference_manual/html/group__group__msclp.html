<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CAT2 Peripheral Driver Library: MSCLP        (Multi-Sense Converter Low-Power)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CAT2 Peripheral Driver Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__msclp.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">API Reference</a>  </div>
  <div class="headertitle">
<div class="title">MSCLP (Multi-Sense Converter Low-Power)</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<p>The MSCLP HW block represents the low power family of the fifth-generation CAPSENSE&trade; devices. </p>
<p>It enables multiple sensing capabilities on PSoC&trade; devices, including the self-cap and mutual-cap capacitive touch-sense solutions and flyback inductive sensing solution.</p>
<p>The CAPSENSE&trade; solution includes:</p><ul>
<li>The CAPSENSE&trade; Configurator tool, which is a configuration wizard to create and configure CAPSENSE&trade; widgets. It can be launched in ModusToolbox&trade; from the MSCLP personality as well as in standalone mode. It contains separate documentation on how to create and configure widgets, parameters, and algorithm descriptions.</li>
<li>An API to control the design from the application program. This documentation describes the API with code snippets about how to use them.</li>
<li>The CAPSENSE&trade; Tuner tool for real-time tuning, testing, and debugging, for easy and smooth design of human interfaces on customer products. The Tuner tool communicates with a device through a HW bridge and communication drivers (EzI2C, UART, etc.) and allows monitoring of widget statuses, sensor signals, detected touch positions, gestures, etc. The application program does not need to interact with the MSCLP driver and/or other drivers such as GPIO or SysClk directly. All of that is configured and managed by the middleware.</li>
</ul>
<div class="image">
<img src="capsense_solution_msclp.png" alt="capsense_solution_msclp.png" width="800px"/>
<div class="caption">
CAPSENSE&trade; Solution</div></div>
 <p>This section describes only the MSCLP driver. Refer to the corresponding sections for documentation of middleware supported by the MSCLP HW block.</p>
<p>The MSCLP driver is a low-level peripheral driver that provides an interface to a complex mixed signal of the MSCLP HW block.</p>
<p>The MSCLP driver alone does not provide system-level functions. Instead, it is used by upper-level middleware to configure the MSCLP HW block required by an application.</p>
<p>The MSCLP HW block can support only one function at a time. To allow seamless time-multiplex implementation of functionality and to avoid conflicting access to hardware from the upper level, the MSCLP driver also implements a lock semaphore mechanism.</p>
<p>The MSCLP driver supports re-entrance. If a device contains several MSCLP HW blocks, the same MSCLP driver is used to configure any HW block. For that, each function of the MSCLP driver contains a base address to define the MSCLP HW block to which the MSCLP driver communicates.</p>
<p>There is no restriction on the MSCLP Driver usage in RTOS.</p>
<h1><a class="anchor" id="group_msclp_config_usage"></a>
Usage</h1>
<p>The MSCLP driver is a simple wrapper driver specifically designed to be used by higher level middleware. Hence, it is highly not recommended to use the MSCLP driver directly in the application program. To incorporate MSCLP HW block functionality in the application program, an associated middleware should be used.</p>
<p>The MSCLP Driver can be used to implement a custom sensing solution. In such a case, the application program must acquire and lock the MSCLP HW block prior to accessing it.</p>
<p>Setting up and using the MSCLP driver can be summed up in these four stages:</p><ul>
<li>Define configuration in the config structure.</li>
<li>Allocate context structure variable for the driver.</li>
<li>Capture the MSCLP HW block.</li>
<li>Execute the action required to perform any kind of conversion.</li>
</ul>
<p>The following code snippet demonstrates how to capture the MSCLP HW block for custom implementation:</p>
<div class="fragment"><div class="line"><a class="code" href="structcy__stc__msclp__context__t.html">cy_stc_msclp_context_t</a> msclpContext = <a class="code" href="group__group__msclp__macros.html#ga1e2b8f3762ec74431dc9a5cd66ab0431">CY_MSCLP_CONTEXT_INIT_VALUE</a>;</div></div><!-- fragment --><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">    * Scenario: Capture MSCLP HW block to perform a conversion.</span></div><div class="line"><span class="comment">    * This scenario does not cover Pins, Clock, Interrupt, configuration.</span></div><div class="line"><span class="comment">    */</span></div><div class="line"></div><div class="line">    <span class="comment">/*...*/</span></div><div class="line">    <a class="code" href="group__group__msclp__enums.html#ga4f743c2a5c581346b50ed3edffabd110">cy_en_msclp_key_t</a> key;</div><div class="line">    <a class="code" href="group__group__msclp__enums.html#ga6c70f9f61712d865a792069871ebc2c6">cy_en_msclp_status_t</a> status;</div><div class="line"></div><div class="line">    <span class="comment">/* Allocates MSCLP configuration structure and initialize it with user&#39;s configuration */</span></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structcy__stc__msclp__base__config__t.html">cy_stc_msclp_base_config_t</a> customConfig = CUSTOM_CONFIG;</div><div class="line"></div><div class="line">    <span class="comment">/* Checks if the MSCLP block if free */</span></div><div class="line">    key = <a class="code" href="group__group__msclp__functions.html#gacbb10faa7cadd1a5c423841aa34b96ba">Cy_MSCLP_GetLockStatus</a>(MSCLP0, &amp;msclpContext);</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__msclp__enums.html#gga4f743c2a5c581346b50ed3edffabd110a10fac4e96644a843bc7e802419529339">CY_MSCLP_NONE_KEY</a> == key)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Captures the MSCLP block and initialize it with user&#39;s configuration */</span></div><div class="line">        status = <a class="code" href="group__group__msclp__functions.html#gab88f9fb6678c6dcbce2e0e10b52c591b">Cy_MSCLP_Init</a>(MSCLP0, &amp;customConfig, <a class="code" href="group__group__msclp__enums.html#gga4f743c2a5c581346b50ed3edffabd110a7e2e65977016de0e807623b718dd5f2e">CY_MSCLP_USER_DEFINED_KEY</a>, &amp;msclpContext);</div><div class="line">        <span class="comment">/* Checks if the MSCLP block was captured successfully */</span></div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="group__group__msclp__enums.html#gga6c70f9f61712d865a792069871ebc2c6ac5845dddb5cce0780bf47a69b0fb5b4d">CY_MSCLP_SUCCESS</a> == status)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Block is captured successfully. User&#39;s application code can be placed and executed here. */</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="comment">/*...*/</span></div><div class="line"></div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>User's application code should follow these recommendations:<ol type="1">
<li>The last sensor configuration in the frame should have the LAST bit of SNS_CTL register set.</li>
<li>The START_FRAME bit of FRAME_CMD register should be set prior to calling the <a class="el" href="group__group__msclp__functions.html#ga710830f1768cc249d9c63fd688609157" title="Sets configuration of sensor frame registers of the MSCLP HW block and starts the scan...">Cy_MSCLP_ConfigureScan()</a> API. It should be set once per frame if the frame contains multiple sensor configurations, and each frame if the frame contains only one sensor configuration.</li>
<li>The START_SCAN bit of SNS_CTL register should be set in the sensor frame to start the conversion.</li>
</ol>
</dd></dl>
<p>The entire solution, like CAPSENSE&trade;, in addition to the MSCLP HW block, incorporates the following instances:</p>
<ul>
<li><a class="el" href="group__group__msclp.html#group_msclp_config_clocks">Clocks</a></li>
<li><a class="el" href="group__group__msclp.html#group_msclp_config_interrupts">Interrupts</a></li>
<li><a class="el" href="group__group__msclp.html#group_msclp_config_pin">GPIO Pins</a></li>
</ul>
<p>The MSCLP driver does not configure those blocks and they should be managed by an upper level. When using CAPSENSE&trade;, those blocks are managed by the middleware.</p>
<h2><a class="anchor" id="group_msclp_config_clocks"></a>
Clocks</h2>
<p>The MSCLP HW block requires a low frequency clock (clk_lf) for LF-AoS operation. It can be enabled either:</p><ul>
<li>Using the Device Configurator (System tab).</li>
<li>Using the <a class="el" href="group__group__sysclk.html">SysClk (System Clock)</a> driver. See the <a class="el" href="group__group__sysclk__ilo.html">Internal Low-Speed Oscillator (ILO)</a> section for more details.</li>
</ul>
<p>Also the MSCLP HW block uses internal MRSS clock source for LF-AoS operation, see the <a class="el" href="group__group__msclp__functions.html#ga584c38e61b0b62eb706e0dccdeafb29b" title="Turns on the MRSS resources. ">Cy_MSCLP_MrssStart()</a> function.</p>
<p>If middleware is used, the clocks are managed by the middleware.</p>
<h2><a class="anchor" id="group_msclp_config_pin"></a>
GPIO Pins</h2>
<p>CAPSENSE&trade; provides the ability to form a user interface using widgets. Each widget consists of one or more sensors. These sensors are connected to the GPIO pins.</p>
<p>The CAPSENSE&trade;-related GPIO pins can be divided into three groups:</p><ol type="1">
<li>Legacy GPIO sensor pads - all the GPIOs, where the CSD_SENSE/CSD_SHIELD HSIOM connections are supported, the AMUXBUS-A/B are used to connect the sensor and CAPSENSE&trade; HW block. Required an update of GPIO registers (Drive mode and the HSIOM selection) for this group of pins in order to set the sensor to the specific state (GND, High-Z, Tx, Rx, etc...).</li>
<li>MSCv3LP-compatible GPIO sensor pads - a subset of GPIOs, that can be controlled by the MSCLP HW block directly, the AMUXBUS-A/B are used to connect the sensor and CAPSENSE&trade; HW block. Not required an update of the GPIO registers (Drive mode and the HSIOM selection) for this group of pins in order to set the sensor to the specific state (GND, High-Z, Tx, Rx, etc...).</li>
<li>New MSCv3LP GPIO Cmod pads - dedicated pads for the external integration capacitors. Similarly to the MSCv3LP-compatible GPIOs, Cmod pads can be controlled by the MSCLP HW block directly and can be used as extra sense pins. These IOs have lower resistance compared to the legacy GPIOs and MSCv3LP-compatible GPIOs.</li>
</ol>
<p>Usage of the MSCv3LP-compatible GPIO sensor pads under the CAPSENSE&trade; MW has the following advantages:</p><ul>
<li>The CAPSENSE&trade; MW pre-calculates all needed configurations in advance (during initialization)</li>
<li>The CAPSENSE&trade; MW triggers the next scanning by writing to several registers of the MSCLP HW block (instead of disconnecting a previously scanned sensor and connecting a new sensor).</li>
</ul>
<p>A GPIO input can be assigned to the MSCLP HW block using the following methods:</p><ul>
<li>Using the Device Configurator (Pins tab).</li>
<li>Using the GPIO (General Purpose Input Output) driver. Refer to the <a class="el" href="group__group__gpio.html">GPIO (General Purpose Input Output)</a> driver section.</li>
</ul>
<p>If middleware is used, pin configuration is managed by the middleware. Under the MSCLP driver custom implementation, the application program must manage the pin connections.</p>
<p>Each AMUXBUS can be split into multiple segments. Ensure that the MSCLP HW block and a GPIO belong to the same bus segment or join the segments to establish the connection GPIO-to-MSCLP HW block.</p>
<p>For more information about pin configuration, refer to the <a class="el" href="group__group__gpio.html">GPIO (General Purpose Input Output)</a> driver.</p>
<h2><a class="anchor" id="group_msclp_config_interrupts"></a>
Interrupts</h2>
<p>The MSCLP HW block implements two interrupts:</p><ul>
<li>Active domain interrupt</li>
<li>Deep Sleep domain interrupt.</li>
</ul>
<p>The Active domain interrupt can be triggered by the following events:</p><ul>
<li>Sub Sample: A valid CIC2 sub-sample is complete.</li>
<li>Sample: A single sample is complete.</li>
<li>Scan: A single scan is complete.</li>
<li>Init: Coarse initialization is complete.</li>
<li>Frame: A single frame is complete.</li>
<li>CIC2 Error: A CIC2 error is detected.</li>
</ul>
<p>The Deep Sleep domain interrupt can be triggered by the following events:</p><ul>
<li>Signal Detect: LP-AoS has detected a signal wakeup.</li>
<li>Frame Timeout: LP-AoS has detected a frame timeout.</li>
<li>Frame: A single frame is complete.</li>
<li>CE Done: Channel Engine done signal. Asserted '1' at the end of the Channel Engine processing pipeline.</li>
<li>IMO Up: MSCv3LP logic has turned on the MRSS IMO.</li>
</ul>
<p>The Active domain interrupt can wake up the device from the Sleep power mode. The Deep Sleep domain interrupt can wake up the device from the Deep Sleep power mode.</p>
<p>If CAPSENSE&trade; MW is used, the interrupt service routine is managed by middleware. When using the MSCLP driver for custom implementation or other middleware, the application program must manage the interrupt service routine.</p>
<p>Implement an interrupt routine and assign it to the MSCLP interrupt. Use the pre-defined enumeration as the interrupt source of the MSCLP HW block. The MSCLP interrupt to the NVIC is raised any time the intersection (logic AND) of the interrupt flags and the corresponding interrupt masks are non-zero. The peripheral interrupt status register should be read in the ISR to detect which condition generated the interrupt. The appropriate interrupt registers should be cleared so that subsequent interrupts can be handled.</p>
<p>The following code snippet demonstrates how to implement a routine to handle the interrupt. The routine is called when a MSCLP interrupt is triggered.</p>
<div class="fragment"><div class="line"></div><div class="line">    <span class="keywordtype">void</span> snippet_Cy_MSCLP_IntHandler(<span class="keywordtype">void</span>)</div><div class="line">    {</div><div class="line">        uint32_t intrStatus;</div><div class="line"></div><div class="line">        <span class="comment">/* Reads interrupt status register */</span></div><div class="line">        intrStatus = <a class="code" href="group__group__msclp__functions.html#gad4afecc1a0e8b5a03c3a8a48e17fa97b">Cy_MSCLP_ReadReg</a>(MSCLP0, <a class="code" href="group__group__msclp__reg__const.html#ga44306b58f19961a02bdce02c5c818daa">CY_MSCLP_REG_OFFSET_INTR</a>);</div><div class="line"></div><div class="line">        <span class="comment">/* Checks the &#39;single scan is complete&#39; event that triggered the interrupt */</span></div><div class="line">        <span class="keywordflow">if</span> ((intrStatus &amp; MSCLP_INTR_SCAN_Msk) == MSCLP_INTR_SCAN_Msk)</div><div class="line">        {</div><div class="line">            <span class="comment">/* End of scan occurred, get the result and do something with it here */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* Clears the pending interrupts */</span></div><div class="line">        <a class="code" href="group__group__msclp__functions.html#gae95636218ca61f5995e5c9e2f4a5e681">Cy_MSCLP_WriteReg</a>(MSCLP0, <a class="code" href="group__group__msclp__reg__const.html#ga44306b58f19961a02bdce02c5c818daa">CY_MSCLP_REG_OFFSET_INTR</a>, intrStatus);</div><div class="line">        (void)<a class="code" href="group__group__msclp__functions.html#gad4afecc1a0e8b5a03c3a8a48e17fa97b">Cy_MSCLP_ReadReg</a>(MSCLP0, <a class="code" href="group__group__msclp__reg__const.html#ga44306b58f19961a02bdce02c5c818daa">CY_MSCLP_REG_OFFSET_INTR</a>);</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --><div class="fragment"><div class="line"></div><div class="line">    <span class="keywordtype">void</span> snippet_Cy_MSCLP_IntHandlerLp(<span class="keywordtype">void</span>)</div><div class="line">    {</div><div class="line">        uint32_t intrStatus;</div><div class="line"></div><div class="line">        <span class="comment">/* Reads interrupt status register */</span></div><div class="line">        intrStatus = <a class="code" href="group__group__msclp__functions.html#gad4afecc1a0e8b5a03c3a8a48e17fa97b">Cy_MSCLP_ReadReg</a>(MSCLP0, <a class="code" href="group__group__msclp__reg__const.html#ga9c78dc68f40b5140d71d43d7b46dad27">CY_MSCLP_REG_OFFSET_INTR_LP</a>);</div><div class="line"></div><div class="line">        <span class="comment">/* Checks the &#39;signal detection&#39; event that triggered the interrupt */</span></div><div class="line">        <span class="keywordflow">if</span> ((intrStatus &amp; MSCLP_INTR_LP_SIG_DET_Msk) == MSCLP_INTR_LP_SIG_DET_Msk)</div><div class="line">        {</div><div class="line">            <span class="comment">/* The signal detection occurred, setup a further scanning */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* Clears pending interrupts */</span></div><div class="line">        <a class="code" href="group__group__msclp__functions.html#gae95636218ca61f5995e5c9e2f4a5e681">Cy_MSCLP_WriteReg</a>(MSCLP0, <a class="code" href="group__group__msclp__reg__const.html#ga9c78dc68f40b5140d71d43d7b46dad27">CY_MSCLP_REG_OFFSET_INTR_LP</a>, intrStatus);</div><div class="line">        (void)<a class="code" href="group__group__msclp__functions.html#gad4afecc1a0e8b5a03c3a8a48e17fa97b">Cy_MSCLP_ReadReg</a>(MSCLP0, <a class="code" href="group__group__msclp__reg__const.html#ga9c78dc68f40b5140d71d43d7b46dad27">CY_MSCLP_REG_OFFSET_INTR_LP</a>);</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --><p> The following code snippet demonstrates how to configure and enable the MSCLP interrupt:</p>
<div class="fragment"><div class="line">    <span class="comment">/* Scenario: initialize both regular and LP interrupt for the MSCLP block */</span></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structcy__stc__sysint__t.html">cy_stc_sysint_t</a> MSCLP_ISR_cfg =</div><div class="line">    {</div><div class="line">        .<a class="code" href="structcy__stc__sysint__t.html#a6da08d81da65a7f93d3e4c46a4b8d950">intrSrc</a> = msclp_interrupt_IRQn,    <span class="comment">/* Interrupt source is the MSCLP0 interrupt */</span></div><div class="line">        .intrPriority = 3u,               <span class="comment">/* Interrupt priority is 3 */</span></div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structcy__stc__sysint__t.html">cy_stc_sysint_t</a> MSCLP_ISR_LP_cfg =</div><div class="line">    {</div><div class="line">        .<a class="code" href="structcy__stc__sysint__t.html#a6da08d81da65a7f93d3e4c46a4b8d950">intrSrc</a> = msclp_interrupt_lp_IRQn, <span class="comment">/* Interrupt source is the MSCLP0 LP interrupt */</span></div><div class="line">        .intrPriority = 3u,               <span class="comment">/* Interrupt priority is 3 */</span></div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">/* Configures the interrupt with vector at snippet_Cy_MSCLP_IntHandler() */</span></div><div class="line">    (void)<a class="code" href="group__group__sysint__functions.html#gab2ff6820a898e9af3f780000054eea5d">Cy_SysInt_Init</a>(&amp;MSCLP_ISR_cfg, snippet_Cy_MSCLP_IntHandler);</div><div class="line"></div><div class="line">    <span class="comment">/* Configures the interrupt with vector at snippet_Cy_MSCLP_IntHandlerLp() */</span></div><div class="line">    (void)<a class="code" href="group__group__sysint__functions.html#gab2ff6820a898e9af3f780000054eea5d">Cy_SysInt_Init</a>(&amp;MSCLP_ISR_LP_cfg, snippet_Cy_MSCLP_IntHandlerLp);</div><div class="line"></div><div class="line">    <span class="comment">/* Enables the interrupt */</span></div><div class="line">    NVIC_EnableIRQ(MSCLP_ISR_cfg.<a class="code" href="structcy__stc__sysint__t.html#a6da08d81da65a7f93d3e4c46a4b8d950">intrSrc</a>);</div><div class="line"></div><div class="line">    <span class="comment">/* Enables the LP interrupt */</span></div><div class="line">    NVIC_EnableIRQ(MSCLP_ISR_LP_cfg.<a class="code" href="structcy__stc__sysint__t.html#a6da08d81da65a7f93d3e4c46a4b8d950">intrSrc</a>);</div><div class="line"></div><div class="line">    <span class="comment">/* Enables the MSCLP SCAN interrupt mask */</span></div><div class="line">    <a class="code" href="group__group__msclp__functions.html#gae95636218ca61f5995e5c9e2f4a5e681">Cy_MSCLP_WriteReg</a>(MSCLP0, <a class="code" href="group__group__msclp__reg__const.html#gabeffce025e0d3b4138ff0a24ecb22e19">CY_MSCLP_REG_OFFSET_INTR_MASK</a>, MSCLP_INTR_MASK_SCAN_Msk);</div><div class="line"></div><div class="line">    <span class="comment">/* Enables the MSCLP LP SIG DET interrupt mask */</span></div><div class="line">    <a class="code" href="group__group__msclp__functions.html#gae95636218ca61f5995e5c9e2f4a5e681">Cy_MSCLP_WriteReg</a>(MSCLP0, <a class="code" href="group__group__msclp__reg__const.html#gac7c7d7e0799946707f09d1b100e53cc6">CY_MSCLP_REG_OFFSET_INTR_LP_MASK</a>, MSCLP_INTR_LP_MASK_SIG_DET_Msk);</div></div><!-- fragment --><p> For more information, refer to the <a class="el" href="group__group__sysint.html">SysInt (System Interrupt)</a> driver.</p>
<p>Alternatively, instead of handling the interrupts, the <a class="el" href="group__group__msclp__functions.html#ga8c201f62dfb14998f68998372bc2fd66">Cy_MSCLP_GetConversionStatus()</a> function allows for firmware polling of the MSCLP block status.</p>
<h1><a class="anchor" id="group_msclp_config_power_modes"></a>
Power Modes</h1>
<p>The MSCLP HW block can perform scans in Active, Sleep, and DeepSleep MCU power modes if it is configured for operation in the AS_MS or LP_AOS modes. If MSCLP HW block is configured for operation in the Interrupt Driven (CPU) mode, it can perform scans only in in Active or Sleep MCU power modes.</p>
<dl class="section note"><dt>Note</dt><dd><ol type="1">
<li>The MSCLP driver does not provide a callback function to facilitate the MCU low-power mode transitions. The responsibility belongs to an upper level that uses the MSCLP HW block to ensure the MSCLP HW block is ready to a power mode transition.</li>
<li>MCU transition to Deep Sleep power mode is not recommended if the MSCLP HW block operates in Interrupt Driven (CPU) mode and it is busy. Unexpected behavior may occur. The MSCLP HW block status must be checked using the Cy_MSCLP_GetStatus() function prior to a power mode transition in this case. This restriction is not applicable to Sleep mode and the device can seamlessly enter and exit Sleep mode while the MSCLP HW block is busy.</li>
</ol>
</dd></dl>
<p>Refer to the <a class="el" href="group__group__syspm.html">SysPm (System Power Management)</a> driver for more information about low-power mode transitions.</p>
<h1><a class="anchor" id="group_msclp_more_information"></a>
More Information</h1>
<p>Important information about the CAPSENSE&trade; technology overview, appropriate Infineon device for the design, CAPSENSE&trade; system and sensor design guidelines, different interfaces and tuning guidelines necessary for a successful design of a CAPSENSE&trade; system is available in the Getting Started with CAPSENSE&trade; document and the product-specific CAPSENSE&trade; design guide. Infineon highly recommends starting with these documents. They can be found on the Infineon web site at www.infineon.com</p>
<p>For more information, refer to the following documents:</p>
<ul>
<li>CAPSENSE&trade; Overview:<ul>
<li><a href="https://github.com/Infineon/capsense"><b>CAPSENSE&trade; Middleware Library</b></a></li>
<li><a href="https://infineon.github.io/capsense/capsense_api_reference_manual/html/index.html"><b>CAPSENSE&trade; Middleware API Reference Guide</b></a></li>
<li><a href="https://documentation.infineon.com/html/modustoolbox-software/en/latest/tool-guide/ModusToolbox_CapSense_Configurator_Guide.html"><b>ModusToolbox&trade; CAPSENSE&trade; Configurator Tool Guide</b></a></li>
<li><a href="https://documentation.infineon.com/html/modustoolbox-software/en/latest/tool-guide/ModusToolbox_CapSense_Tuner_Guide.html"><b>ModusToolbox&trade; CAPSENSE&trade; Tuner Tool Guide</b></a></li>
<li><a href="https://www.infineon.com/dgdl/Infineon-AN85951_PSoC_4_and_PSoC_6_MCU_CapSense_Design_Guide-ApplicationNotes-v27_00-EN.pdf?fileId=8ac78c8c7cdc391c017d0723535d4661"><b>CAPSENSE&trade; Design Guide</b></a></li>
</ul>
</li>
<li>ModusToolbox&trade; Overview:<ul>
<li><a href="https://www.infineon.com/cms/en/design-support/tools/sdk/modustoolbox-software"><b>ModusToolbox&trade; Software Environment, Quick Start Guide, Documentation, and Videos</b></a></li>
<li><a href="https://documentation.infineon.com/html/modustoolbox-software/en/latest/tool-guide/ModusToolbox_Device_Configurator_Guide.html"><b>ModusToolbox&trade; Device Configurator Tool Guide</b></a></li>
</ul>
</li>
<li>Infineon Kits:<ul>
<li>Information will be available later. In case of urgency, contact the technical support group.</li>
</ul>
</li>
<li>General Information:<ul>
<li><a href="https://infineon.github.io/mtb-pdl-cat2/pdl_api_reference_manual/html/index.html"><b>PDL API Reference</b></a></li>
<li><a href="https://github.com/Infineon"><b>Infineon Technologies GitHub</b></a></li>
<li><a href="http://www.infineon.com"><b>Infineon Technologies</b></a></li>
</ul>
</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The links to another software component's documentation (middleware and PDL) point to GitHub to the latest available version of the software. To get documentation of the specified version, download from GitHub and unzip the component archive. The documentation is available in the <em>docs</em> folder.</dd></dl>
<h1><a class="anchor" id="group_msclp_changelog"></a>
Changelog</h1>
<table class="doxtable">
<tr>
<th>Version</th><th>Changes</th><th>Reason for Change </th></tr>
<tr>
<td>2.0 </td><td>Changed name of defines: CY_MSCLP_IMO_24_MHZ -&gt; <a class="el" href="group__group__msclp__macros.html#gab7aa7f5889731729081dc93614814442">CY_MSCLP_IMO_25_MHZ</a>, CY_MSCLP_IMO_36_MHZ -&gt; <a class="el" href="group__group__msclp__macros.html#ga3ee8d613fc7446d8965b262ecba568b4">CY_MSCLP_IMO_38_MHZ</a>, CY_MSCLP_IMO_48_MHZ -&gt; <a class="el" href="group__group__msclp__macros.html#ga308d590db24fde0e177847bd0623d492">CY_MSCLP_IMO_46_MHZ</a> </td><td>Names consistency with HW frequency.  </td></tr>
<tr>
<td>1.0 </td><td>The initial version </td><td></td></tr>
</table>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
API Reference</h2></td></tr>
<tr class="memitem:group__group__msclp__macros"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__msclp__macros.html">Macros</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__msclp__functions"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__msclp__functions.html">Functions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__msclp__data__structures"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__msclp__data__structures.html">Data Structures</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__msclp__enums"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__msclp__enums.html">Enumerated Types</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>CAT2 Peripheral Driver Library</b> by <b>Infineon Technologies</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
