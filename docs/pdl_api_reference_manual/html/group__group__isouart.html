<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CAT2 Peripheral Driver Library: IsoUART      (Isolated UART)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CAT2 Peripheral Driver Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__isouart.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a>  </div>
  <div class="headertitle">
<div class="title">IsoUART (Isolated UART)</div>  </div>
</div><!--header-->
<div class="contents">

<p>The iso UART is a point-to-point differential current edge-triggered UART interface for communication with the other battery management system (BMS) ICs.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__group__isouart__macros"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__isouart__macros.html">Macros</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__isouart__functions"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__isouart__functions.html">Functions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__isouart__data__structures"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__isouart__data__structures.html">Data Structures</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__isouart__enums"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__isouart__enums.html">Enumerated Types</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The iso UART is a point-to-point differential current edge-triggered UART interface for communication with the other battery management system (BMS) ICs. </p>
<dl class="section note"><dt>Note</dt><dd>Supported on PSOC&trade; 4 HVPA SPM only.</dd></dl>
<p>The functions and other declarations used in this driver are in cy_isouart.h. You can include cy_pdl.h to get access to all functions and declarations in the PDL.</p>
<h1><a class="anchor" id="group_isouart_overview"></a>
Overview</h1>
<p>The iso UART can be configured to operate in different modes: Master (Host) or Slave (Node). This protocol consists of a single master device and multiple slave devices. The master device can address the slave devices using node-id and block id. It provides galvanic isolation with UART-style frames (start bit, stop bit, 8 data bits, zero parity bits), and has high robustness against external noise.</p>
<h2><a class="anchor" id="group_isouart_interfaces"></a>
Physical Interfaces</h2>
<p>The iso UART communicates via two physical links: high side interface (IFH) and low side interface (IFL). Both high and low side interfaces can drive the differential lines (TX) and both have a differential receiver circuit (RX). This offers the necessary isolation to guarantee error-free communication between different modules in the battery system. The interface allowed to drive the bus lines is determined by the bus timing protocol.</p>
<h2><a class="anchor" id="group_isouart_topologies"></a>
Topologies</h2>
<p>The protocol supports up to 30 devices in a single chain using device IDs. This can be extended to more than 30 devices using Block ID. Block ID can also be used to group devices and limit the number of devices responding to broadcast messages. There are two possible topologies: Master-on-Bottom (MOB) and Master-on-Top (MOT). These topologies can also be optionally wired as complete loops (Ring).</p>
<div class="image">
<img src="isouart_topologies.png" alt="isouart_topologies.png" width="600px"/>
<div class="caption">
MOT, MOB and Ring topology</div></div>
<p><b>Master-on-Top (MOT):</b></p><ul>
<li>Host positioned at the top of the chain</li>
<li>Host communicates via Low interface</li>
<li>Data stored in SRAM Low interface registers</li>
</ul>
<p><b>Master-on-Bottom (MOB):</b></p><ul>
<li>Host positioned at the bottom of the chain</li>
<li>Host communicates via High interface</li>
<li>Data stored in SRAM High interface registers</li>
</ul>
<p><b>Ring Topologies (MOT-Ring, MOB-Ring):</b></p><ul>
<li>Complete physical loops connecting the chain endpoints</li>
<li>Host receives node replies on both interfaces</li>
<li>Host's own transmitted commands received on the opposite interface</li>
</ul>
<p>Both high side (IFH) and low side (IFL) interfaces can act as transmitters and receivers. Nodes automatically detect the wake signal source and configure their internal multiplexer to receive commands from the appropriate interface while simultaneously forwarding frames through the chain via the opposite interface. When transmitting a response, the slave transmits on both High and Low interfaces simultaneously.</p>
<h2><a class="anchor" id="group_isouart_commands"></a>
Command Types</h2>
<p>The iso UART protocol supports six command types for Host-Node communication, with two main categories: write and read requests that differ primarily in Address/ID field content. All frames are hardware-interpreted and use 8-bit data with full CRC protection (no parity). The protocol tolerates frequency mismatch between Host and Node transmissions and supports broadcast operations.</p>
<div class="image">
<img src="isouart_commands.png" alt="isouart_commands.png" width="800px"/>
<div class="caption">
Possible Master to Slave communication commands</div></div>
<p><b>Write Commands:</b> <br />
The Host can write data to Node registers or SRAM locations using several write command types: <br />
</p><ul>
<li><b>Write</b>: Writes 16-bit data to a specific address of one Node.</li>
<li><b>Broadcast Write</b>: Writes 16-bit data to the same address of all Nodes in the chain simultaneously.</li>
</ul>
<p>When executing write commands, Nodes return Write Reply messages containing operation status information (CRC, status flags, error bits) stored in HIGH_INTERFACE_READ or LOW_INTERFACE_READ registers. Standard Write commands receive a response from the addressed Node, while Broadcast Write commands receive a response from the final Node in the chain. It is essential for broadcast write mode that the final Node in the chain must be properly marked with FN=1 (Final Node flag) during the enumeration process. If no Node has FN=1 set, Broadcast Write commands will not receive any Write Reply frame, resulting in a FRAME ERROR. This configuration is essential for proper broadcast communication functionality.</p>
<p><b>Read Commands:</b> <br />
The Host can read data from Node registers or SRAM locations using several read command types: <br />
</p><ul>
<li><b>Read</b>: Reads 16-bit data from a specific address of one Node.</li>
<li><b>Broadcast Read</b>: Reads 16-bit data from the same address of all Nodes sequentially. Nodes transmit sequentially starting from Node 1, with each Node switching to transmit mode while others monitor the reply frames for synchronization. After each transmission completes, the next Node takes its turn.</li>
<li><b>Multi-Read</b>: Reads multiple registers from one Node using pre-configured address ranges. The multi-read configuration must be set via broadcast write before use.</li>
<li><b>Broadcast Multi-Read</b>: Combines broadcast and multi-read functionality to read multiple registers from all Nodes sequentially.</li>
</ul>
<p><b>Two non-data notifications commands:</b></p><ul>
<li><b>Wake-up Sequence</b>: Required before any command frame to wake all Nodes from sleep mode. Automatically sent by Host on first enable or after reset/re-enable. For subsequent commands, wake sequence can be manually triggered via software when needed.</li>
<li><b>Emergency Mode (EMM)</b>: Alternating signal used only by Nodes for fault handling. Can be triggered via SW or external trigger inputs. EMM also wakes devices from sleep and is automatically forwarded through the chain.</li>
</ul>
<h2><a class="anchor" id="group_isouart_sram"></a>
SRAM</h2>
<p>The iso UART block contains the 128 x 32-bit SRAM, which serves as the primary memory for data storage and exchange. It is the only interface between the iso UART peripheral and the rest of the chip via CPU or DMA. The SRAM defaults to an unexpected state and must be initialized and divided before iso UART block is enabled.</p>
<p><b>SRAM Word Structure (32 bits):</b></p><ul>
<li><b>Bits [15:0]</b>: Data field - stores the actual 16-bit payload data.</li>
<li><b>Bits [24:16]</b>: Attributes field (9 bits) - stores control and status information.</li>
<li><b>Bits [31:25]</b>: ECC field (7 bits) - stores error correction code for data integrity.</li>
</ul>
<p>The 128-word SRAM can be divided into two parts Low and High, with each part being dedicated to store data received from corresponding interface in certain receive modes.</p>
<p>The iso UART provides three distinct receiver modes that determine how incoming frame data is processed and stored in SRAM:</p><ul>
<li><b>Register Mode</b>: Reply frames stored only in receive registers, no SRAM usage.</li>
<li><b>Unpacked Mode</b>: Data field (16 bits) extracted and stored in SRAM using one row.</li>
<li><b>Raw Mode</b>: Entire frame (ID, address, data, CRC) stored in SRAM using three rows per frame.</li>
</ul>
<p>In Unpacked and Raw modes, data is written to both SRAM and interface registers, with optional ECC calculation for enhanced data integrity protection. Register mode writes data only to interface registers without using SRAM.</p>
<h1><a class="anchor" id="group_isouart_configuration"></a>
Configuration Considerations</h1>
<h2><a class="anchor" id="group_isouart_config_device_configurator"></a>
Device Configurator Setup</h2>
<p>The ModusToolbox Device Configurator provides a graphical user interface to configure the iso UART peripheral. This tool automatically generates initialization code and configuration structures based on your settings.</p>
<p>To use the Device Configurator:</p><ol type="1">
<li>Open the ModusToolbox Device Configurator from your project.</li>
<li>Navigate to the "Peripherals" tab and under "Communication" group enable "Iso UART" block.</li>
<li>Choose the operation mode (Host or Node).</li>
<li>Configure basic parameters like topology, bit rate, and CRC policy.</li>
<li>Save the configuration to generate the initialization code.</li>
</ol>
<p>After Device Configurator is set up, the initialization structures, clocks, peripheral clock dividers, GPIOs, and other peripheral configuration code are auto-generated and placed in ../bsps/TARGET_APP_.../config directory files. <br />
Place the call of the cybsp_init() function before using any iso UART API functions to ensure initialization of all external resources required for the iso UART operation.</p>
<h2><a class="anchor" id="group_isouart_config_host"></a>
Host Configuration</h2>
<p>To set up the iso UART driver in the Host mode, provide the configuration parameters in the <a class="el" href="structcy__stc__isouart__host__config__t.html">cy_stc_isouart_host_config_t</a> structure. Host configuration requires careful consideration of topology, receiver mode, CRC policy, block ID usage, and multi-read settings to match those configured on the nodes in the physical chain setup. To initialize the driver, call the <a class="el" href="group__group__isouart__host__functions.html#ga2df0457ce3ec1288562be27318ce26c5">Cy_ISOUART_HostInit</a> function providing a pointer to the populated <a class="el" href="structcy__stc__isouart__host__config__t.html">cy_stc_isouart_host_config_t</a> structure. </p><div class="fragment"><div class="line">    <span class="comment">/* Populate Host configuration structure */</span></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structcy__stc__isouart__host__config__t.html">cy_stc_isouart_host_config_t</a> hostConfig =</div><div class="line">    {</div><div class="line">        .<a class="code" href="structcy__stc__isouart__host__config__t.html#a2dccce9fc133b2463c9480822f95dc05">topology</a>               = <a class="code" href="group__group__isouart__enums.html#gga7ae5099fccf3be08ddf434725e0124cfa7d851d32354f44abaebcea701ce98c82">CY_ISOUART_MOT</a>,                       <span class="comment">/* Master-on-Top topology. */</span></div><div class="line">        .hostBitrate            = <a class="code" href="group__group__isouart__enums.html#ggadf6158d9884867f717026c8a3010b8cda9dd2e9b9346846e8018baf98c06af292">CY_ISOUART_HOST_BITRATE_2_1MBPS</a>,      <span class="comment">/* 2.1 Mbps data rate. */</span></div><div class="line">        .receiverMode           = <a class="code" href="group__group__isouart__enums.html#ggada45cd4ff842f52208cb24ef9d182546a1679c08d80fe2ce05cbe0283791cdfe7">CY_ISOUART_RECEIVER_MODE_UNPACKED</a>,    <span class="comment">/* Unpacked receive mode. */</span></div><div class="line">        .crcPolicy              = <a class="code" href="group__group__isouart__enums.html#gga5f8723808993c8c35ff8e4a38431b5f8a07911441f1719321ecd737d30d8c3f51">CY_ISOUART_CRC8_SAE_J1850</a>,            <span class="comment">/* CRC8 SAE J1850 polynomial. */</span></div><div class="line">        .enableBlockId          = <span class="keyword">true</span>,                                 <span class="comment">/* Enable Block ID feature. */</span></div><div class="line">        .useWriteDoneTrig       = <span class="keyword">false</span>,                                <span class="comment">/* No trigger on write complete. */</span></div><div class="line">        .useLowSramFullTrig     = <span class="keyword">false</span>,                                <span class="comment">/* No trigger when low SRAM full. */</span></div><div class="line">        .useHighSramFullTrig    = <span class="keyword">false</span>,                                <span class="comment">/* No trigger when high SRAM full. */</span></div><div class="line">        .enableMultiReadBC      = <span class="keyword">false</span>,                                <span class="comment">/* Disable broadcast multi-read. */</span></div><div class="line">        .enableInternalLoopback = <span class="keyword">false</span>,                                <span class="comment">/* Disable internal loopback. */</span></div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">/* Configure iso UART Host to operate */</span></div><div class="line">    <a class="code" href="group__group__isouart__host__functions.html#ga2df0457ce3ec1288562be27318ce26c5">Cy_ISOUART_HostInit</a>(ISOUART, &amp;hostConfig);</div></div><!-- fragment --> <h2><a class="anchor" id="group_isouart_config_node"></a>
Node Configuration</h2>
<p>To set up the iso UART driver in the Node mode, provide the configuration parameters in the <a class="el" href="structcy__stc__isouart__node__config__t.html">cy_stc_isouart_node_config_t</a> structure. Node configuration must be compatible with the host configuration, especially regarding CRC policy, Block ID usage, and multi-read settings. To initialize the driver, call <a class="el" href="group__group__isouart__node__functions.html#gaf77367274aaf36815a38ed396858b465">Cy_ISOUART_NodeInit</a> function providing a pointer to the populated <a class="el" href="structcy__stc__isouart__node__config__t.html">cy_stc_isouart_node_config_t</a> structure. </p><div class="fragment"><div class="line">    <span class="comment">/* Populate Node configuration structure */</span></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structcy__stc__isouart__node__config__t.html">cy_stc_isouart_node_config_t</a> nodeConfig =</div><div class="line">    {</div><div class="line">        .<a class="code" href="structcy__stc__isouart__node__config__t.html#a5461fe479433a67716f706b790a06a37">crcPolicy</a>          = <a class="code" href="group__group__isouart__enums.html#gga5f8723808993c8c35ff8e4a38431b5f8a07911441f1719321ecd737d30d8c3f51">CY_ISOUART_CRC8_SAE_J1850</a>,     <span class="comment">/* Match host CRC policy. */</span></div><div class="line">        .enableBlockId      = <span class="keyword">true</span>,                         <span class="comment">/* Enable if host uses Block ID. */</span></div><div class="line">        .useTrig0Emm        = <span class="keyword">false</span>,                        <span class="comment">/* No emergency mode trigger 0. */</span></div><div class="line">        .useTrig1Emm        = <span class="keyword">false</span>,                        <span class="comment">/* No emergency mode trigger 1. */</span></div><div class="line">        .useTrig2Emm        = <span class="keyword">false</span>,                        <span class="comment">/* No emergency mode trigger 2. */</span></div><div class="line">        .useTrig3Emm        = <span class="keyword">false</span>,                        <span class="comment">/* No emergency mode trigger 3. */</span></div><div class="line">        .enableMultiReadBC  = <span class="keyword">false</span>,                        <span class="comment">/* Disable broadcast multi-read. */</span></div><div class="line">        .baseAddressA       = 0UL,                          <span class="comment">/* Base address A for multi-read. */</span></div><div class="line">        .baseAddressB       = 0UL,                          <span class="comment">/* Base address B for multi-read. */</span></div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">/* Configure iso UART Node to operate */</span></div><div class="line">    <a class="code" href="group__group__isouart__node__functions.html#gaf77367274aaf36815a38ed396858b465">Cy_ISOUART_NodeInit</a>(ISOUART, &amp;nodeConfig);</div></div><!-- fragment --> <h2><a class="anchor" id="group_isouart_config_clock"></a>
Clock Configuration</h2>
<p>The iso UART block requires proper configuration of high frequency clock (HFCLK) and peripheral dividers to operate at 24 MHz. This clock is configured using the <a class="el" href="group__group__sysclk.html">SysClk (System Clock)</a> driver API. </p><div class="fragment"><div class="line">    <span class="comment">/* This example assumes that the HFCLK has already been initialized to 24MHz before this APIs is called.</span></div><div class="line"><span class="comment">     * Therefore, it simply enables peripheral divider with no divider.</span></div><div class="line"><span class="comment">     */</span></div><div class="line"><span class="preprocessor">    #define CLK_DIV_TYPE        (CY_SYSCLK_DIV_16_BIT)</span></div><div class="line"><span class="preprocessor">    #define CLK_DIV_NUM         (1UL)</span></div><div class="line"><span class="preprocessor">    #define CLK_DIV_VALUE       (0UL)</span></div><div class="line"></div><div class="line">    <a class="code" href="group__group__sysclk__clk__peripheral__funcs.html#ga66c291e9903a5a499b516f600925b54b">Cy_SysClk_PeriphDisableDivider</a>(CLK_DIV_TYPE, CLK_DIV_NUM); <span class="comment">/* Disable divider before configuring. */</span></div><div class="line">    <a class="code" href="group__group__sysclk__clk__peripheral__funcs.html#ga735e08e163703408d76adac860b752c8">Cy_SysClk_PeriphAssignDivider</a>(PCLK_ISOUART_CLOCK_IUART, CLK_DIV_TYPE, CLK_DIV_NUM); <span class="comment">/* Assign divider to the iso UART clock. */</span></div><div class="line">    <a class="code" href="group__group__sysclk__clk__peripheral__funcs.html#ga548bab5bed961e0f210892299baa389d">Cy_SysClk_PeriphSetDivider</a>(CLK_DIV_TYPE, CLK_DIV_NUM, CLK_DIV_VALUE); <span class="comment">/* Set divider 0 resulting 24MHz. */</span></div><div class="line">    <a class="code" href="group__group__sysclk__clk__peripheral__funcs.html#gafec3a5a368f67cae80adfd61a9550cb4">Cy_SysClk_PeriphEnableDivider</a>(CLK_DIV_TYPE, CLK_DIV_NUM);  <span class="comment">/* Enable the divider. */</span></div></div><!-- fragment --> <h2><a class="anchor" id="group_isouart_config_interrupt"></a>
Interrupt Configuration</h2>
<p>The iso UART can use interrupts to handle communication events. Configuration flow includes setting up the interrupt service routine (ISR) and enabling the appropriate interrupt sources. </p><div class="fragment"><div class="line">    <span class="comment">/* Assign iso UART interrupt number and priority. */</span></div><div class="line"><span class="preprocessor">    #define CY_ISOUART_INTR_NUM        ((IRQn_Type) isouart_interrupt_IRQn)</span></div><div class="line"><span class="preprocessor">    #define CY_ISOUART_INTR_PRIORITY   (3UL)</span></div><div class="line"></div><div class="line">    <span class="comment">/* Populate configuration structure. */</span></div><div class="line">    <a class="code" href="structcy__stc__sysint__t.html">cy_stc_sysint_t</a> IntrConfig =</div><div class="line">    {</div><div class="line">        .<a class="code" href="structcy__stc__sysint__t.html#a6da08d81da65a7f93d3e4c46a4b8d950">intrSrc</a>      = CY_ISOUART_INTR_NUM,</div><div class="line">        .intrPriority = CY_ISOUART_INTR_PRIORITY,</div><div class="line">    };</div><div class="line"></div><div class="line">    (void) <a class="code" href="group__group__sysint__functions.html#gab2ff6820a898e9af3f780000054eea5d">Cy_SysInt_Init</a>(&amp;IntrConfig, &amp;IntrHandler);        <span class="comment">/* Initialize system interrupt with handler */</span></div><div class="line">    NVIC_ClearPendingIRQ(IntrConfig.<a class="code" href="structcy__stc__sysint__t.html#a6da08d81da65a7f93d3e4c46a4b8d950">intrSrc</a>);                <span class="comment">/* Clear any pending interrupts */</span></div><div class="line">    NVIC_EnableIRQ(IntrConfig.<a class="code" href="structcy__stc__sysint__t.html#a6da08d81da65a7f93d3e4c46a4b8d950">intrSrc</a>);                      <span class="comment">/* Enable interrupt in NVIC */</span></div></div><!-- fragment --> <h2><a class="anchor" id="group_isouart_config_enable"></a>
Enable Iso UART</h2>
<p>The iso UART must be enabled to operate. This includes enabling the peripheral and global interrupts. </p><div class="fragment"><div class="line">    <span class="comment">/* Enable iso UART to operate. */</span></div><div class="line">    <a class="code" href="group__group__isouart__common__functions.html#gadf7a574beb29a2411f540cf8356f6c16">Cy_ISOUART_Enable</a>(ISOUART);</div><div class="line">    <span class="comment">/* Enable global interrupts. */</span></div><div class="line">    __enable_irq();</div></div><!-- fragment --> <h2><a class="anchor" id="group_isouart_config_multiread"></a>
Multi-Read Configuration</h2>
<p>The multi-read feature allows reading multiple registers from a Node using pre-configured address ranges. To use this feature, the multi-read configuration must be set via broadcast write before use. </p><div class="fragment"><div class="line">    <span class="comment">/* Scenario: Configure multi-read settings for nodes.</span></div><div class="line"><span class="comment">     * This example demonstrates configuring the multi-read configuration register</span></div><div class="line"><span class="comment">     * for PSOC 4 HVPA SPM 1.0 and writing it to all nodes at once using a broadcast write command.</span></div><div class="line"><span class="comment">     */</span></div><div class="line"></div><div class="line">    <span class="comment">/* ISOUART_MULTI_READ_CFG bit fields for PSOC4 HVPA SPM 1.0</span></div><div class="line"><span class="comment">     * See Architecture Reference Manual for detailed bit field descriptions.</span></div><div class="line"><span class="comment">     */</span></div><div class="line"><span class="preprocessor">    #define ISOUART_MULTI_READ_CFG_NUM_A_Pos        (0UL)</span></div><div class="line"><span class="preprocessor">    #define ISOUART_MULTI_READ_CFG_SUBTRACT_A_Pos   (4UL)</span></div><div class="line"><span class="preprocessor">    #define ISOUART_MULTI_READ_CFG_NUM_B_Pos        (5UL)</span></div><div class="line"><span class="preprocessor">    #define ISOUART_MULTI_READ_CFG_SUBTRACT_B_Pos   (8UL)</span></div><div class="line"><span class="preprocessor">    #define ISOUART_MULTI_READ_CFG_DUMMY_DATA_Pos   (9UL)</span></div><div class="line"></div><div class="line"><span class="preprocessor">    #define ISOUART_BROADCAST_ID                    (63U)</span></div><div class="line"></div><div class="line">    <span class="keyword">const</span> uint32_t blockId = 0UL;   <span class="comment">/* Applied block ID (Applicable if block ID is enabled). */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Prepare multi-read configuration data. */</span></div><div class="line">    uint16_t multiReadNumA = 3U;     <span class="comment">/* Number of reads from Base Address A (exclusive). */</span></div><div class="line">    uint16_t keepLastAddrA = 1U;     <span class="comment">/* Do not subtract from reads from Base Address A. */</span></div><div class="line">    uint16_t multiReadNumB = 5U;     <span class="comment">/* Number of reads from Base Address B (exclusive). */</span></div><div class="line">    uint16_t keepLastAddrB = 1U;     <span class="comment">/* Do not subtract from reads from Base Address B. */</span></div><div class="line">    uint16_t dummyDataNum =  0U;     <span class="comment">/* Number of dummy reads after reads from Base Address A and Base Address B. */</span></div><div class="line"></div><div class="line">    uint16_t multiReadConfig = 0U;</div><div class="line">    multiReadConfig |= multiReadNumA &lt;&lt; ISOUART_MULTI_READ_CFG_NUM_A_Pos;</div><div class="line">    multiReadConfig |= keepLastAddrA &lt;&lt; ISOUART_MULTI_READ_CFG_SUBTRACT_A_Pos;</div><div class="line">    multiReadConfig |= multiReadNumB &lt;&lt; ISOUART_MULTI_READ_CFG_NUM_B_Pos;</div><div class="line">    multiReadConfig |= keepLastAddrB &lt;&lt; ISOUART_MULTI_READ_CFG_SUBTRACT_B_Pos;</div><div class="line">    multiReadConfig |= dummyDataNum  &lt;&lt; ISOUART_MULTI_READ_CFG_DUMMY_DATA_Pos;</div><div class="line"></div><div class="line">    <span class="comment">/* Send multi-read configuration to all Nodes at once using broadcast write command. */</span></div><div class="line">    <a class="code" href="group__group__isouart__host__functions.html#ga7a3ec21178947cefe247a830d5d60a9a">Cy_ISOUART_HostSendWriteCommand</a>(ISOUART, blockId, ISOUART_BROADCAST_ID, <a class="code" href="group__group__isouart__macros__reserved__addresses.html#gad5be8c5d55760d44f8348fffe9ddaadc">CY_ISOUART_ADDR_MULTI_READ_CFG</a>, multiReadConfig);</div></div><!-- fragment --> <h1><a class="anchor" id="group_isouart_common_use_cases"></a>
Common Use Cases</h1>
<p>This section demonstrates a typical iso UART Host and Node implementation using the following configuration:</p><ul>
<li><b>Topology</b>: Master-on-Top</li>
<li><b>Receiver Mode</b>: Unpacked</li>
<li><b>Operation</b>: Sequenced mode</li>
</ul>
<h2><a class="anchor" id="group_isouart_host_configuration"></a>
Host Use Case</h2>
<p>This section demonstrates how to configure a Host to communicate with Nodes in the chain. The Host can be configured using either auto-generated code from <a class="el" href="group__group__isouart.html#group_isouart_config_device_configurator">Device Configurator Setup</a> or manual configuration as described in <a class="el" href="group__group__isouart.html#group_isouart_config_host">Host Configuration</a>, <a class="el" href="group__group__isouart.html#group_isouart_config_clock">Clock Configuration</a>, <a class="el" href="group__group__isouart.html#group_isouart_config_interrupt">Interrupt Configuration</a>, and <a class="el" href="group__group__isouart.html#group_isouart_config_enable">Enable Iso UART</a> sections.</p>
<p><b>Enumeration Process</b> <br />
Before starting communication, the Host must enumerate each Node in the chain to assign unique IDs. This process is required at a startup and after a wake-up from Sleep mode, as Node-IDs are reset to 0. The Host sequentially assigns IDs by sending write commands to Device ID 0, starting from 1. Every enumerated Node starts forwarding messages which allow access to the next Node with ID 0. This continues until all Nodes receive consecutive IDs, with the final Node marked appropriately: </p><div class="fragment"><div class="line">    <span class="comment">/* Scenario: Perform node enumeration in Master-on-Top topology.</span></div><div class="line"><span class="comment">     * This process assigns a unique ID to a node and configures it as the final node in the chain.</span></div><div class="line"><span class="comment">     * This example uses polling to wait for command completion instead of interrupt-driven approach.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">const</span> uint32_t blockId = 0UL;   <span class="comment">/* Applied block ID (Applicable if block ID is enabled). */</span></div><div class="line">    <span class="keyword">const</span> uint32_t nodeId  = 1UL;   <span class="comment">/* Applied ID to the node, must start from 0 and sequential. */</span></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> isFinalNode = <span class="keyword">true</span>;  <span class="comment">/* Specify the node is the last node in the chain, this config affects broadcast command. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* For the 1st command, enable the wakeup sequence to awake nodes in the chain.</span></div><div class="line"><span class="comment">     * This request is one-shot, no need to send a wakeup sequence other than the 1st command.</span></div><div class="line"><span class="comment">     * The wakeup delay depends on the nodes in the chain, the delay allows nodes to set up themselves to react to commands.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <a class="code" href="group__group__isouart__host__functions.html#ga61d0688e051bc9c5186d9b46d1304474">Cy_ISOUART_HostEnableWakeSequence</a>(ISOUART, 0x2EE0UL);</div><div class="line"></div><div class="line">    <span class="comment">/* Prepare node configuration data. */</span></div><div class="line">    <span class="keyword">const</span> uint16_t configData = (nodeId | (blockId &lt;&lt; 6UL) | (isFinalNode &lt;&lt; 11UL));</div><div class="line"></div><div class="line">    <span class="comment">/* Send the configuration command into the bus.</span></div><div class="line"><span class="comment">     * Node ID in the enumeration command must be 0.</span></div><div class="line"><span class="comment">     * Prior to the command frame, the requested wakeup sequence will be sent.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <a class="code" href="group__group__isouart__host__functions.html#ga7a3ec21178947cefe247a830d5d60a9a">Cy_ISOUART_HostSendWriteCommand</a>(ISOUART, blockId, 0UL, <a class="code" href="group__group__isouart__macros__reserved__addresses.html#ga3ae2ac6d18f215b34ea8c68f24571185">CY_ISOUART_ADDR_CONFIG</a>, configData);</div><div class="line"></div><div class="line">    <span class="comment">/* Wait for Write command completion by polling FRAME_RECEIVED interrupt status</span></div><div class="line"><span class="comment">     * (interface side depends on topology) instead of using interrupt service routine.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    uint32_t intrStatus = 0UL;</div><div class="line">    <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">        intrStatus = <a class="code" href="group__group__isouart__interrupt__functions.html#gab6fca3a063d0446136bfa052cc2f783d">Cy_ISOUART_GetInterruptStatusMasked</a>(ISOUART);</div><div class="line">    } <span class="keywordflow">while</span> (0UL == (intrStatus &amp; <a class="code" href="group__group__isouart__macros__interrupt__masks.html#ga348b62bed7f47685f3f46a479cd046f7">CY_ISOUART_INTR_MASTER_LOW_FRAME_RECEIVED</a>));</div><div class="line"></div><div class="line">    <span class="comment">/* Clear interrupt flags. */</span></div><div class="line">    <a class="code" href="group__group__isouart__interrupt__functions.html#ga59a17f6508ba472e5626b8082da1ab04">Cy_ISOUART_ClearInterrupt</a>(ISOUART, intrStatus);</div><div class="line"></div><div class="line">    <span class="comment">/* Read the write response from low interface (because of MOT topology)</span></div><div class="line"><span class="comment">     * and verify the CRC of the write response.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    uint8_t regVal_low = <a class="code" href="group__group__isouart__host__functions.html#gaef4277791822d589ceb1322921c441e9">Cy_ISOUART_HostReadLowInterface</a>(ISOUART);</div><div class="line">    <span class="keywordtype">bool</span> ret_low = <a class="code" href="group__group__isouart__host__functions.html#gab5834661246ac6c970933a526a46bb2f">Cy_ISOUART_HostVerifyCRC</a>(regVal_low);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<span class="keyword">false</span> == ret_low)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Handle the incorrect CRC data in the write response. */</span></div><div class="line">    }</div></div><!-- fragment --><p> <b>Write Operations</b> <br />
The Host writes data to Node registers or SRAM using <a class="el" href="group__group__isouart__host__functions.html#ga7a3ec21178947cefe247a830d5d60a9a">Cy_ISOUART_HostSendWriteCommand</a>. This function supports both individual Node writes and broadcast writes to all Nodes simultaneously (for broadcast mode, set the nodeId parameter to 63).</p>
<p>After every write operation, Nodes return Write Reply frames containing operation status information such as CRC validation, error flags, and operation status. These replies are stored in HIGH_INTERFACE_READ or LOW_INTERFACE_READ registers. If any error bits are set in the reply (status, access, or address errors), the Host triggers the corresponding interrupts: <a class="el" href="group__group__isouart__macros__interrupt__masks.html#gaf87ab2ab45ab8b6ee3515543e982d925">CY_ISOUART_INTR_MASTER_SLAVE_STATUS_ERROR</a>, <a class="el" href="group__group__isouart__macros__interrupt__masks.html#ga43869b6e95d6de3c75bfe48711775bd6">CY_ISOUART_INTR_MASTER_SLAVE_ACCESS_ERROR</a>, or <a class="el" href="group__group__isouart__macros__interrupt__masks.html#ga83b1f4084ebb2178e6c3c0898229ea94">CY_ISOUART_INTR_MASTER_SLAVE_ADDRESS_ERROR</a>. Additionally, if the CRC doesn't match the expected value, the Host triggers <a class="el" href="group__group__isouart__macros__interrupt__masks.html#gac6b3079466d7278d6fd17441441fce5f">CY_ISOUART_INTR_MASTER_CRC_ERROR</a> interrupt.</p>
<p>To process the write reply, there are two approaches for CRC validation. You can enable the <a class="el" href="group__group__isouart__macros__interrupt__masks.html#gac6b3079466d7278d6fd17441441fce5f">CY_ISOUART_INTR_MASTER_CRC_ERROR</a> interrupt or, alternatively, you can use manual validation by reading the reply data with <a class="el" href="group__group__isouart__host__functions.html#gaef4277791822d589ceb1322921c441e9">Cy_ISOUART_HostReadLowInterface</a> or <a class="el" href="group__group__isouart__host__functions.html#ga3eac86b6a2148e4930010fd4a718a30b">Cy_ISOUART_HostReadHighInterface</a> (depending on your topology configuration) and then passing this value to <a class="el" href="group__group__isouart__host__functions.html#gab5834661246ac6c970933a526a46bb2f">Cy_ISOUART_HostVerifyCRC</a> to validate the CRC value. </p><div class="fragment"><div class="line">    <span class="comment">/* Scenario: Perform write operation to specific node in Master-on-Top topology.</span></div><div class="line"><span class="comment">     * This demonstrates sending data to node SRAM and verifying write response with CRC check.</span></div><div class="line"><span class="comment">     * This example uses polling to wait for command completion instead of interrupt-driven approach.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="comment">/* Write command parameters */</span></div><div class="line">    <span class="keyword">const</span> uint32_t address   = 0UL;         <span class="comment">/* SRAM address to write to. */</span></div><div class="line">    <span class="keyword">const</span> uint32_t writeData = 0x1234UL;    <span class="comment">/* Data to write. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Send Write command in sequenced mode. */</span></div><div class="line">    <a class="code" href="group__group__isouart__host__functions.html#ga7a3ec21178947cefe247a830d5d60a9a">Cy_ISOUART_HostSendWriteCommand</a>(ISOUART, blockId, nodeId, address, writeData);</div><div class="line"></div><div class="line">    <span class="comment">/* Wait for Write command completion by polling FRAME_RECEIVED interrupt status</span></div><div class="line"><span class="comment">     * (interface side depends on topology) instead of using interrupt service routine.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    uint32_t intrStatus = 0UL;</div><div class="line">    <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">        intrStatus = <a class="code" href="group__group__isouart__interrupt__functions.html#gaa27998c25657a4a8c5225d995d2044cc">Cy_ISOUART_GetInterruptStatus</a>(ISOUART);</div><div class="line">    } <span class="keywordflow">while</span> (0UL == (intrStatus &amp; CY_ISOUART_INTR_MASTER_LOW_FRAME_RECEIVED));</div><div class="line"></div><div class="line">    <span class="comment">/* Clear interrupt flags. */</span></div><div class="line">    <a class="code" href="group__group__isouart__interrupt__functions.html#ga59a17f6508ba472e5626b8082da1ab04">Cy_ISOUART_ClearInterrupt</a>(ISOUART, intrStatus);</div><div class="line"></div><div class="line">    <span class="comment">/* Read the write response from low interface (because of MOT topology)</span></div><div class="line"><span class="comment">     * and verify the CRC of the write response.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    uint8_t regVal_low = <a class="code" href="group__group__isouart__host__functions.html#gaef4277791822d589ceb1322921c441e9">Cy_ISOUART_HostReadLowInterface</a>(ISOUART);</div><div class="line">    <span class="keywordtype">bool</span> ret_low = <a class="code" href="group__group__isouart__host__functions.html#gab5834661246ac6c970933a526a46bb2f">Cy_ISOUART_HostVerifyCRC</a>(regVal_low);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<span class="keyword">false</span> == ret_low)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Handle incorrect CRC data in write response. */</span></div><div class="line">    }</div></div><!-- fragment --><p> <b>Read Operations</b> <br />
The Host can read data from Node registers or SRAM locations using <a class="el" href="group__group__isouart__host__functions.html#ga1ca934c5454237de73583ef5a9ad919f">Cy_ISOUART_HostSendReadCommand</a>. Received data is stored in SRAM and can be retrieved using appropriate API functions based on the configured receiver mode: <a class="el" href="group__group__isouart__sram__functions.html#gae2c475bbf77332590cfdf723ab6ceb22">Cy_ISOUART_HostReadSramUnpack</a> for Unpacked mode, <a class="el" href="group__group__isouart__sram__functions.html#gab1ce26fcb50542c344c2e3fab7c6281c">Cy_ISOUART_HostReadSramRaw</a> for Raw mode (returns complete packet with addr, nodeID, data, CRC fields, or use <a class="el" href="group__group__isouart__sram__functions.html#ga61f5b2480294e583304a7db5dca360e4">Cy_ISOUART_ReadSramRow16</a> / <a class="el" href="group__group__isouart__sram__functions.html#ga3d906793c82b584f3463c2f5b676ad75">Cy_ISOUART_ReadSramRow32</a> for direct data field access), or <a class="el" href="group__group__isouart__host__functions.html#gaef4277791822d589ceb1322921c441e9">Cy_ISOUART_HostReadLowInterface</a> / <a class="el" href="group__group__isouart__host__functions.html#ga3eac86b6a2148e4930010fd4a718a30b">Cy_ISOUART_HostReadHighInterface</a> for Register mode:</p>
<div class="fragment"><div class="line">    <span class="comment">/* Scenario: Perform read operation from specific node in Master-on-Top topology.</span></div><div class="line"><span class="comment">     * This demonstrates SRAM size configuration, reading data from node, and unpacked data retrieval.</span></div><div class="line"><span class="comment">     * This example uses polling to wait for command completion instead of interrupt-driven approach.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">const</span> uint32_t address = 0UL;   <span class="comment">/* SRAM address to read from. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Disable iso UART block. */</span></div><div class="line">    <a class="code" href="group__group__isouart__common__functions.html#gab90f55e8aeabb059fdc6f1d90884d3b2">Cy_ISOUART_Disable</a>(ISOUART);</div><div class="line"></div><div class="line">    <span class="comment">/* For the proper handling, set the interface SRAM size to the expected size by the transaction.</span></div><div class="line"><span class="comment">     * NOTE: The SRAM size shall only be changed when iso UART is disabled or both interfaces are in Slave mode.</span></div><div class="line"><span class="comment">     * e.g. for unpack mode, normal read command = 1</span></div><div class="line"><span class="comment">     * e.g. for raw mode, normal read command = 3</span></div><div class="line"><span class="comment">     * e.g. for unpack mode, multi read command = 1 x number of multi read</span></div><div class="line"><span class="comment">     * e.g. for unpack mode, BC read command = 1 x number of nodes in the chain</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <a class="code" href="group__group__isouart__sram__functions.html#ga13bf7ea2057d2b4290455ba10310fe1f">Cy_ISOUART_HostSetSramSize</a>(ISOUART, 1UL, 0UL); <span class="comment">/* Set the Low side 1 row, High side 0 row. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Enable iso UART to operate. */</span></div><div class="line">    <a class="code" href="group__group__isouart__common__functions.html#gadf7a574beb29a2411f540cf8356f6c16">Cy_ISOUART_Enable</a>(ISOUART);</div><div class="line"></div><div class="line">    <span class="comment">/* Perform Read operation. */</span></div><div class="line">    <a class="code" href="group__group__isouart__host__functions.html#ga1ca934c5454237de73583ef5a9ad919f">Cy_ISOUART_HostSendReadCommand</a>(ISOUART, blockId, nodeId, address);</div><div class="line">    <span class="comment">/* Wait for Read command completion by polling SRAM_FULL interrupt status</span></div><div class="line"><span class="comment">     * (interface side depends on topology) instead of using interrupt service routine.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    uint32_t intrStatus = 0UL;</div><div class="line">    <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">        intrStatus = <a class="code" href="group__group__isouart__interrupt__functions.html#gaa27998c25657a4a8c5225d995d2044cc">Cy_ISOUART_GetInterruptStatus</a>(ISOUART);</div><div class="line">    } <span class="keywordflow">while</span> (0UL == (intrStatus &amp; <a class="code" href="group__group__isouart__macros__interrupt__masks.html#ga4b3b00545aee1d8a31375a8a38a722ea">CY_ISOUART_INTR_MASTER_LOW_SRAM_FULL</a>));</div><div class="line"></div><div class="line">    <span class="comment">/* Clear interrupt flags. */</span></div><div class="line">    <a class="code" href="group__group__isouart__interrupt__functions.html#ga59a17f6508ba472e5626b8082da1ab04">Cy_ISOUART_ClearInterrupt</a>(ISOUART, intrStatus);</div><div class="line"></div><div class="line">    <span class="comment">/* Read data from low interface SRAM. */</span></div><div class="line">    uint16_t readData = <a class="code" href="group__group__isouart__sram__functions.html#gae2c475bbf77332590cfdf723ab6ceb22">Cy_ISOUART_HostReadSramUnpack</a>(ISOUART, <a class="code" href="group__group__isouart__enums.html#ggacf2d3e5d86ed1ad3bb584ef929f93faeab383854c267880dc0fd76cac0bb8e574">CY_ISOUART_IF_LOW</a>, 0UL);</div><div class="line">    <span class="comment">/* Process the read data */</span></div></div><!-- fragment --> <h2><a class="anchor" id="group_isouart_node_configuration"></a>
Node Use Case</h2>
<p>This section demonstrates how to configure a Node to receive and process commands from the Host. The Node can be configured using either auto-generated code from <a class="el" href="group__group__isouart.html#group_isouart_config_device_configurator">Device Configurator Setup</a> or manual configuration as described in <a class="el" href="group__group__isouart.html#group_isouart_config_node">Node Configuration</a>, <a class="el" href="group__group__isouart.html#group_isouart_config_clock">Clock Configuration</a>, <a class="el" href="group__group__isouart.html#group_isouart_config_interrupt">Interrupt Configuration</a>, and <a class="el" href="group__group__isouart.html#group_isouart_config_enable">Enable Iso UART</a> sections.</p>
<p><b>Trigger Interrupts Structures and Attributes Configuration</b> <br />
 To properly handle Host commands, the Node must be configured to monitor-specific SRAM addresses and trigger actions based on received data. This requires configuring interrupt trigger structures and linking them to specific SRAM row attributes: </p><div class="fragment"><div class="line">    <span class="comment">/* Scenario: Configure the iso UART Node interrupt trigger structure and SRAM row attributes.</span></div><div class="line"><span class="comment">     * This setup enables Primary Access interrupt on write operations to SRAM address 0.</span></div><div class="line"><span class="comment">     * The interrupt handler (IntrHandler) will process the triggered interrupt.</span></div><div class="line"><span class="comment">     */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Use trigger structure ID 1 to configure */</span></div><div class="line">    <span class="keyword">const</span> uint8_t intrTrigStructId = 1U;</div><div class="line"></div><div class="line">    <span class="comment">/* Configure interrupt trigger structure */</span></div><div class="line">    <a class="code" href="group__group__isouart__node__functions.html#gaedd07fc6dee98285aae07c5369e454bd">Cy_ISOUART_NodeConfigTriggerInt</a>(ISOUART,</div><div class="line">                                intrTrigStructId,          <span class="comment">/* Trigger structure ID */</span></div><div class="line">                                <a class="code" href="group__group__isouart__enums.html#ggaf8903b939cf9627b4f0ecc3710911830af9eed768db9b0a056c92d1d866c04dee">CY_ISOUART_EVENT_NONE</a>,     <span class="comment">/* Trigger source */</span></div><div class="line">                                <a class="code" href="group__group__isouart__enums.html#ggaf8903b939cf9627b4f0ecc3710911830ae0be52d935dc408264f723486a492699">CY_ISOUART_EVENT_WRITE</a>,    <span class="comment">/* Primary interrupt source */</span></div><div class="line">                                <a class="code" href="group__group__isouart__enums.html#ggaf8903b939cf9627b4f0ecc3710911830af9eed768db9b0a056c92d1d866c04dee">CY_ISOUART_EVENT_NONE</a>);    <span class="comment">/* Secondary interrupt source */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Configure SRAM row attributes for address 0 */</span></div><div class="line">    <a class="code" href="group__group__isouart__sram__functions.html#ga974d4b0dfad2b098161c85843c733436">Cy_ISOUART_NodeConfigSramRowAttr</a>(ISOUART,</div><div class="line">                                    SRAM_ADDRESS,       <span class="comment">/* SRAM address */</span></div><div class="line">                                    intrTrigStructId,   <span class="comment">/* Trigger structure ID */</span></div><div class="line">                                    <span class="keyword">false</span>,              <span class="comment">/* Invalid address disabled */</span></div><div class="line">                                    <span class="keyword">false</span>);             <span class="comment">/* Read protection disabled */</span></div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>After configuring the trigger structure, ensure that:<ol type="1">
<li>Primary Access and other relevant interrupts are enabled in the interrupt mask.</li>
<li>Interrupt handler is properly configured (see next snippet).</li>
<li>Global interrupts are enabled before expecting interrupt triggers.</li>
</ol>
</dd></dl>
<p><b>Implementing the Interrupt Handler</b> <br />
 The Node's interrupt handler processes incoming write commands from the Host and executes appropriate responses. Note that proper interrupt configuration (as described in <a class="el" href="group__group__isouart.html#group_isouart_config_interrupt">Interrupt Configuration</a>) must be completed before this handler can function correctly: </p><div class="fragment"><div class="line"><span class="comment">/* Scenario: Handle iso UART Node interrupts including Wake-up and Primary Access events.</span></div><div class="line"><span class="comment"> * This handler processes write operations to SRAM address 0 and wakeup signals from Host.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keywordtype">void</span> IntrHandler(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    uint32_t intrStatus = <a class="code" href="group__group__isouart__interrupt__functions.html#gab6fca3a063d0446136bfa052cc2f783d">Cy_ISOUART_GetInterruptStatusMasked</a>(ISOUART);</div><div class="line">    <a class="code" href="group__group__isouart__interrupt__functions.html#ga59a17f6508ba472e5626b8082da1ab04">Cy_ISOUART_ClearInterrupt</a>(ISOUART, intrStatus);</div><div class="line"></div><div class="line">    <span class="comment">/* Check for Wake-up interrupt on both interfaces. */</span></div><div class="line">    <span class="keywordflow">if</span> (0UL != (intrStatus &amp; (<a class="code" href="group__group__isouart__macros__interrupt__masks.html#gae3315982fa3a31eb7f70a4420bc7d411">CY_ISOUART_INTR_WAKE_HIGH</a> | <a class="code" href="group__group__isouart__macros__interrupt__masks.html#gaa02aeb963d6f7fc0f9dbb4f43cafdf8a">CY_ISOUART_INTR_WAKE_LOW</a>)))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Handle Wake-up interrupt. */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Check for Primary Access interrupt. */</span></div><div class="line">    <span class="keywordflow">if</span> (0UL != (intrStatus &amp; <a class="code" href="group__group__isouart__macros__interrupt__masks.html#gaf9982e3cd55c37f522a3cb9837ea92d1">CY_ISOUART_INTR_REG_ACCESS_P</a>))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Get the interrupt address and event type. */</span></div><div class="line">        uint8_t intrAddress = <a class="code" href="group__group__isouart__interrupt__functions.html#ga663de66a7a4d74eb9ecaad4e1207fae9">Cy_ISOUART_NodeGetIntrAddrPrim</a>(ISOUART);</div><div class="line">        <a class="code" href="group__group__isouart__enums.html#gaf8903b939cf9627b4f0ecc3710911830">cy_en_isouart_event_t</a> intrEvent = <a class="code" href="group__group__isouart__interrupt__functions.html#ga78cd7822d8d207f00242e1f7fe97760d">Cy_ISOUART_NodeGetIntrEventPrim</a>(ISOUART);</div><div class="line"></div><div class="line">        <span class="comment">/* Check if write command was sent to the expected SRAM address. */</span></div><div class="line">        <span class="keywordflow">if</span> ((SRAM_ADDRESS == intrAddress) &amp;&amp; (<a class="code" href="group__group__isouart__enums.html#ggaf8903b939cf9627b4f0ecc3710911830ae0be52d935dc408264f723486a492699">CY_ISOUART_EVENT_WRITE</a> == intrEvent))</div><div class="line">        {</div><div class="line">            <span class="comment">/* Read the received data from SRAM. */</span></div><div class="line">            receivedData = <a class="code" href="group__group__isouart__sram__functions.html#ga61f5b2480294e583304a7db5dca360e4">Cy_ISOUART_ReadSramRow16</a>(ISOUART, intrAddress);</div><div class="line">            <span class="comment">/* Process received data. */</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p> <b>Maintaining Node Activity</b> <br />
 The Node contains a 7-bit watchdog counter that counts downward from its maximum value and must be serviced regularly to prevent the device from entering Sleep mode. The watchdog operates with a 16ms resolution on a 24MHz clock, and so provide a maximum timeout of 2.03 seconds. This watchdog timer must be refreshed periodically before it reaches zero using <a class="el" href="group__group__isouart__node__functions.html#gaacd76b4675e6300521b6cc5177ade59f">Cy_ISOUART_NodeSetWdtCount</a> on the Node or using <a class="el" href="group__group__isouart__host__functions.html#ga7a3ec21178947cefe247a830d5d60a9a">Cy_ISOUART_HostSendWriteCommand</a> on the Host side.</p>
<p>Refreshing watchdog counter from Host: </p><div class="fragment"><div class="line">    <span class="comment">/* Scenario: Refresh the watchdog timer of all nodes in the chain from the Host side. */</span></div><div class="line"><span class="preprocessor">    #define ISOUART_BROADCAST_ID    (63U)</span></div><div class="line"></div><div class="line">    <span class="keyword">const</span> uint32_t blockId = 0UL;   <span class="comment">/* Applied block ID (Applicable if block ID is enabled). */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Refresh watchdog timer for all nodes using broadcast write command. */</span></div><div class="line">    <a class="code" href="group__group__isouart__host__functions.html#ga7a3ec21178947cefe247a830d5d60a9a">Cy_ISOUART_HostSendWriteCommand</a>(ISOUART, blockId, ISOUART_BROADCAST_ID, <a class="code" href="group__group__isouart__macros__reserved__addresses.html#ga97d7cddaacc400652ac318d08db057f6">CY_ISOUART_ADDR_WDOG_CNT</a>, 0x7F);</div></div><!-- fragment --><p>Refreshing watchdog counter on the Node: </p><div class="fragment"><div class="line">    <span class="comment">/* Scenario: Refresh the watchdog timer in the main loop to prevent Node from going into Sleep mode. */</span></div><div class="line">    <span class="keywordflow">for</span> (;;)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Refresh a 7-bit watchdog timer. */</span></div><div class="line">        <a class="code" href="group__group__isouart__node__functions.html#gaacd76b4675e6300521b6cc5177ade59f">Cy_ISOUART_NodeSetWdtCount</a>(ISOUART, 0x7F);</div><div class="line">        <span class="comment">/* 50 ms delay between watchdog refreshes */</span></div><div class="line">        <a class="code" href="group__group__syslib__functions.html#gaad1c32546fdb0e3c6fa8b46fb95843b5">Cy_SysLib_Delay</a>(50U);</div><div class="line">    }</div></div><!-- fragment --> <h2><a class="anchor" id="group_isouart_sram_protection"></a>
SRAM Address Protection</h2>
<p>The iso UART provides mechanisms to protect SRAM addresses on Nodes using <a class="el" href="group__group__isouart__sram__functions.html#ga974d4b0dfad2b098161c85843c733436">Cy_ISOUART_NodeConfigSramRowAttr</a>. Two protection modes are available: <br />
 <b>Invalid Address Protection</b> <br />
When a Node marks a SRAM address as invalid using <a class="el" href="group__group__isouart__sram__functions.html#ga974d4b0dfad2b098161c85843c733436">Cy_ISOUART_NodeConfigSramRowAttr</a>, any Host read or write attempt to that address will be rejected. For write commands, the Node responds with the address error bit set in the reply frame, triggering the <a class="el" href="group__group__isouart__macros__interrupt__masks.html#ga83b1f4084ebb2178e6c3c0898229ea94">CY_ISOUART_INTR_MASTER_SLAVE_ADDRESS_ERROR</a> interrupt on the Host side.</p>
<p>Node-side configuration: </p><div class="fragment"><div class="line">    <span class="comment">/* Scenario: Configure Node SRAM address as invalid.</span></div><div class="line"><span class="comment">     * When a SRAM address is marked as invalid (isInvalid=true), any Host read or write attempt to that address</span></div><div class="line"><span class="comment">     * will be rejected. For write commands, the Node responds with the address error bit set in the reply frame,</span></div><div class="line"><span class="comment">     * triggering the CY_ISOUART_INTR_MASTER_SLAVE_ADDRESS_ERROR interrupt on the Host side (if enabled in the interrupt mask).</span></div><div class="line"><span class="comment">     */</span></div><div class="line"></div><div class="line">    <span class="keyword">const</span> uint32_t invalidAddress = 0x10UL;  <span class="comment">/* Address to mark as invalid. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Configure SRAM address as invalid on Node side. */</span></div><div class="line">    <a class="code" href="group__group__isouart__sram__functions.html#ga974d4b0dfad2b098161c85843c733436">Cy_ISOUART_NodeConfigSramRowAttr</a>(ISOUART,</div><div class="line">                                    invalidAddress,       <span class="comment">/* SRAM address to protect */</span></div><div class="line">                                    1U,                   <span class="comment">/* Trigger structure ID */</span></div><div class="line">                                    <span class="keyword">true</span>,                 <span class="comment">/* Mark as invalid address */</span></div><div class="line">                                    <span class="keyword">false</span>);               <span class="comment">/* Read protection not needed */</span></div></div><!-- fragment --><p> Host-side error handling: </p><div class="fragment"><div class="line">    <span class="comment">/* Scenario: Handle the address error on Host side when accessing an invalid Node SRAM address.</span></div><div class="line"><span class="comment">     * This example demonstrates Host-side configuration and error handling for Master-on-Top topology</span></div><div class="line"><span class="comment">     * when attempting to access a Node address marked as invalid.</span></div><div class="line"><span class="comment">     */</span></div><div class="line"></div><div class="line">    <span class="keyword">const</span> uint32_t invalidAddress = 0x10UL;  <span class="comment">/* Invalid address on Node side. */</span></div><div class="line">    <span class="keyword">const</span> uint32_t writeData = 0x5678UL;     <span class="comment">/* Data to write. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Enable the address error interrupt on Host to detect when Node reports the address error. */</span></div><div class="line">    uint32_t intrMask = <a class="code" href="group__group__isouart__interrupt__functions.html#gaf9916fe6db993a83dcb4c3d6ab4a0880">Cy_ISOUART_GetInterruptMask</a>(ISOUART);</div><div class="line">    <a class="code" href="group__group__isouart__interrupt__functions.html#ga36ffb24e32d696e2bf1d366dc680654b">Cy_ISOUART_SetInterruptMask</a>(ISOUART, intrMask | <a class="code" href="group__group__isouart__macros__interrupt__masks.html#ga83b1f4084ebb2178e6c3c0898229ea94">CY_ISOUART_INTR_MASTER_SLAVE_ADDRESS_ERROR</a>);</div><div class="line"></div><div class="line">    <span class="comment">/* Attempt to write to the invalid address. */</span></div><div class="line">    <a class="code" href="group__group__isouart__host__functions.html#ga7a3ec21178947cefe247a830d5d60a9a">Cy_ISOUART_HostSendWriteCommand</a>(ISOUART, blockId, nodeId, invalidAddress, writeData);</div><div class="line"></div><div class="line">    <span class="comment">/* Wait for write command completion. */</span></div><div class="line">    uint32_t intrStatus = 0UL;</div><div class="line">    <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">        intrStatus = <a class="code" href="group__group__isouart__interrupt__functions.html#gab6fca3a063d0446136bfa052cc2f783d">Cy_ISOUART_GetInterruptStatusMasked</a>(ISOUART);</div><div class="line">    } <span class="keywordflow">while</span> (0UL == (intrStatus &amp; (CY_ISOUART_INTR_MASTER_LOW_FRAME_RECEIVED | <a class="code" href="group__group__isouart__macros__interrupt__masks.html#ga83b1f4084ebb2178e6c3c0898229ea94">CY_ISOUART_INTR_MASTER_SLAVE_ADDRESS_ERROR</a>)));</div><div class="line"></div><div class="line">    <span class="comment">/* Clear interrupt flags. */</span></div><div class="line">    <a class="code" href="group__group__isouart__interrupt__functions.html#ga59a17f6508ba472e5626b8082da1ab04">Cy_ISOUART_ClearInterrupt</a>(ISOUART, intrStatus);</div><div class="line"></div><div class="line">    <span class="comment">/* Check if an address error occurred. */</span></div><div class="line">    <span class="keywordflow">if</span> (0UL != (intrStatus &amp; <a class="code" href="group__group__isouart__macros__interrupt__masks.html#ga83b1f4084ebb2178e6c3c0898229ea94">CY_ISOUART_INTR_MASTER_SLAVE_ADDRESS_ERROR</a>))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Node responded with the address error bit set.</span></div><div class="line"><span class="comment">         * This indicates that the requested address is marked as invalid on Node.</span></div><div class="line"><span class="comment">         * Handle the error condition appropriately.</span></div><div class="line"><span class="comment">         */</span></div><div class="line">    }</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>Interrupt <a class="el" href="group__group__isouart__macros__interrupt__masks.html#ga83b1f4084ebb2178e6c3c0898229ea94">CY_ISOUART_INTR_MASTER_SLAVE_ADDRESS_ERROR</a> must be enabled in the interrupt mask on the Host.</dd></dl>
<p><b>Read-Only Protection</b> <br />
When a Node marks a SRAM address as read-only using <a class="el" href="group__group__isouart__sram__functions.html#ga974d4b0dfad2b098161c85843c733436">Cy_ISOUART_NodeConfigSramRowAttr</a>, write attempts from the Host will be rejected while read operations remain allowed. The Node responds with the access error bit set in the reply frame, triggering the <a class="el" href="group__group__isouart__macros__interrupt__masks.html#ga43869b6e95d6de3c75bfe48711775bd6">CY_ISOUART_INTR_MASTER_SLAVE_ACCESS_ERROR</a> interrupt on the Host side.</p>
<p>Node-side configuration: </p><div class="fragment"><div class="line">    <span class="comment">/* Scenario: Configure Node SRAM address as read-only.</span></div><div class="line"><span class="comment">     * When a SRAM address is marked as read-only (isReadOnly=true), Host write attempts to that address will be</span></div><div class="line"><span class="comment">     * rejected, while read operations remain allowed. Node will respond to the write attempts with the access error bit set</span></div><div class="line"><span class="comment">     * and will trigger the CY_ISOUART_INTR_MASTER_SLAVE_ACCESS_ERROR interrupt on Host side (if enabled in the interrupt mask).</span></div><div class="line"><span class="comment">     */</span></div><div class="line"></div><div class="line">    <span class="keyword">const</span> uint32_t readOnlyAddress = 0x20UL;  <span class="comment">/* Address to mark as read-only. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Configure SRAM address as read-only on Node side. */</span></div><div class="line">    <a class="code" href="group__group__isouart__sram__functions.html#ga974d4b0dfad2b098161c85843c733436">Cy_ISOUART_NodeConfigSramRowAttr</a>(ISOUART,</div><div class="line">                                    readOnlyAddress,      <span class="comment">/* SRAM address to protect */</span></div><div class="line">                                    1U,                   <span class="comment">/* Trigger structure ID */</span></div><div class="line">                                    <span class="keyword">false</span>,                <span class="comment">/* Not invalid address */</span></div><div class="line">                                    <span class="keyword">true</span>);                <span class="comment">/* Mark as read-only */</span></div></div><!-- fragment --><p> Host-side error handling: </p><div class="fragment"><div class="line">    <span class="comment">/* Scenario: Handle the access error on Host side when writing to a read-only Node SRAM address.</span></div><div class="line"><span class="comment">     * This example demonstrates Host-side configuration and error handling for Master-on-Top topology</span></div><div class="line"><span class="comment">     * when attempting to write to a Node address marked as read-only. It also shows that read</span></div><div class="line"><span class="comment">     * operations to the same address are allowed and will succeed.</span></div><div class="line"><span class="comment">     */</span></div><div class="line"></div><div class="line">    <span class="keyword">const</span> uint32_t readOnlyAddress = 0x20UL;  <span class="comment">/* Read-only address on Node side. */</span></div><div class="line">    <span class="keyword">const</span> uint32_t writeData = 0xABCDUL;      <span class="comment">/* Data to write. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Enable the access error interrupt on Host to detect when Node reports the access error. */</span></div><div class="line">    uint32_t intrMask = <a class="code" href="group__group__isouart__interrupt__functions.html#gaf9916fe6db993a83dcb4c3d6ab4a0880">Cy_ISOUART_GetInterruptMask</a>(ISOUART);</div><div class="line">    <a class="code" href="group__group__isouart__interrupt__functions.html#ga36ffb24e32d696e2bf1d366dc680654b">Cy_ISOUART_SetInterruptMask</a>(ISOUART, intrMask | <a class="code" href="group__group__isouart__macros__interrupt__masks.html#ga43869b6e95d6de3c75bfe48711775bd6">CY_ISOUART_INTR_MASTER_SLAVE_ACCESS_ERROR</a>);</div><div class="line"></div><div class="line">    <span class="comment">/* Attempt to write to the read-only address - this will trigger access error. */</span></div><div class="line">    <a class="code" href="group__group__isouart__host__functions.html#ga7a3ec21178947cefe247a830d5d60a9a">Cy_ISOUART_HostSendWriteCommand</a>(ISOUART, blockId, nodeId, readOnlyAddress, writeData);</div><div class="line"></div><div class="line">    <span class="comment">/* Wait for write command completion. */</span></div><div class="line">    uint32_t intrStatus = 0UL;</div><div class="line">    <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">        intrStatus = <a class="code" href="group__group__isouart__interrupt__functions.html#gab6fca3a063d0446136bfa052cc2f783d">Cy_ISOUART_GetInterruptStatusMasked</a>(ISOUART);</div><div class="line">    } <span class="keywordflow">while</span> (0UL == (intrStatus &amp; (CY_ISOUART_INTR_MASTER_LOW_FRAME_RECEIVED | <a class="code" href="group__group__isouart__macros__interrupt__masks.html#ga43869b6e95d6de3c75bfe48711775bd6">CY_ISOUART_INTR_MASTER_SLAVE_ACCESS_ERROR</a>)));</div><div class="line"></div><div class="line">    <span class="comment">/* Clear interrupt flags. */</span></div><div class="line">    <a class="code" href="group__group__isouart__interrupt__functions.html#ga59a17f6508ba472e5626b8082da1ab04">Cy_ISOUART_ClearInterrupt</a>(ISOUART, intrStatus);</div><div class="line"></div><div class="line">    <span class="comment">/* Check if an access error occurred. */</span></div><div class="line">    <span class="keywordflow">if</span> (0UL != (intrStatus &amp; <a class="code" href="group__group__isouart__macros__interrupt__masks.html#ga43869b6e95d6de3c75bfe48711775bd6">CY_ISOUART_INTR_MASTER_SLAVE_ACCESS_ERROR</a>))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Node responded with the access error bit set.</span></div><div class="line"><span class="comment">         * This indicates that the write operation to the read-only address was rejected.</span></div><div class="line"><span class="comment">         * Handle the error condition appropriately.</span></div><div class="line"><span class="comment">         */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Read from the read-only address - this operation is allowed and will succeed. */</span></div><div class="line">    <a class="code" href="group__group__isouart__host__functions.html#ga1ca934c5454237de73583ef5a9ad919f">Cy_ISOUART_HostSendReadCommand</a>(ISOUART, blockId, nodeId, readOnlyAddress);</div><div class="line"></div><div class="line">    <span class="comment">/* Wait for read command completion. */</span></div><div class="line">    <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">        intrStatus = <a class="code" href="group__group__isouart__interrupt__functions.html#gaa27998c25657a4a8c5225d995d2044cc">Cy_ISOUART_GetInterruptStatus</a>(ISOUART);</div><div class="line">    } <span class="keywordflow">while</span> (0UL == (intrStatus &amp; CY_ISOUART_INTR_MASTER_LOW_SRAM_FULL));</div><div class="line"></div><div class="line">    <span class="comment">/* Clear interrupt flags. */</span></div><div class="line">    <a class="code" href="group__group__isouart__interrupt__functions.html#ga59a17f6508ba472e5626b8082da1ab04">Cy_ISOUART_ClearInterrupt</a>(ISOUART, intrStatus);</div><div class="line"></div><div class="line">    <span class="comment">/* Check if an access error occurred. (Should not occur for read operations) */</span></div><div class="line">    <span class="keywordflow">if</span> (0UL != (intrStatus &amp; CY_ISOUART_INTR_MASTER_SLAVE_ACCESS_ERROR))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Handle the error condition appropriately. */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Read data from SRAM - this will succeed without errors. */</span></div><div class="line">    uint16_t readData = <a class="code" href="group__group__isouart__sram__functions.html#gae2c475bbf77332590cfdf723ab6ceb22">Cy_ISOUART_HostReadSramUnpack</a>(ISOUART, <a class="code" href="group__group__isouart__enums.html#ggacf2d3e5d86ed1ad3bb584ef929f93faeab383854c267880dc0fd76cac0bb8e574">CY_ISOUART_IF_LOW</a>, 0UL);</div><div class="line">    <span class="comment">/* Process the read data. */</span></div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>Interrupt <a class="el" href="group__group__isouart__macros__interrupt__masks.html#ga43869b6e95d6de3c75bfe48711775bd6">CY_ISOUART_INTR_MASTER_SLAVE_ACCESS_ERROR</a> must be enabled in the interrupt mask on the Host.</dd></dl>
<h1><a class="anchor" id="group_isouart_more_information"></a>
More Information.</h1>
<p>See the Iso UART chapter of the device technical reference manual (TRM).</p>
<h1><a class="anchor" id="group_isouart_changelog"></a>
Changelog</h1>
<table class="doxtable">
<tr>
<th>Version</th><th>Changes</th><th>Reason for Change </th></tr>
<tr>
<td>1.0 </td><td>The initial version. </td><td></td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>CAT2 Peripheral Driver Library</b> by <b>Infineon Technologies</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
