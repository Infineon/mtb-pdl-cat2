<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CAT2 Peripheral Driver Library: Host Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CAT2 Peripheral Driver Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__isouart__host__functions.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Host Functions<div class="ingroups"><a class="el" href="group__group__isouart.html">IsoUART      (Isolated UART)</a> &raquo; <a class="el" href="group__group__isouart__functions.html">Functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga2df0457ce3ec1288562be27318ce26c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__isouart__host__functions.html#ga2df0457ce3ec1288562be27318ce26c5">Cy_ISOUART_HostInit</a> (ISOUART_Type *base, const <a class="el" href="structcy__stc__isouart__host__config__t.html">cy_stc_isouart_host_config_t</a> *config)</td></tr>
<tr class="memdesc:ga2df0457ce3ec1288562be27318ce26c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Full Init of the iso UART in host mode.  <a href="#ga2df0457ce3ec1288562be27318ce26c5">More...</a><br /></td></tr>
<tr class="separator:ga2df0457ce3ec1288562be27318ce26c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61d0688e051bc9c5186d9b46d1304474"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__isouart__host__functions.html#ga61d0688e051bc9c5186d9b46d1304474">Cy_ISOUART_HostEnableWakeSequence</a> (ISOUART_Type *base, uint32_t wakeCmdDelay)</td></tr>
<tr class="memdesc:ga61d0688e051bc9c5186d9b46d1304474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the transmission of wake sequence.  <a href="#ga61d0688e051bc9c5186d9b46d1304474">More...</a><br /></td></tr>
<tr class="separator:ga61d0688e051bc9c5186d9b46d1304474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef4277791822d589ceb1322921c441e9"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__isouart__host__functions.html#gaef4277791822d589ceb1322921c441e9">Cy_ISOUART_HostReadLowInterface</a> (const ISOUART_Type *base)</td></tr>
<tr class="memdesc:gaef4277791822d589ceb1322921c441e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the latest frame data from the Low interface.  <a href="#gaef4277791822d589ceb1322921c441e9">More...</a><br /></td></tr>
<tr class="separator:gaef4277791822d589ceb1322921c441e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3eac86b6a2148e4930010fd4a718a30b"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__isouart__host__functions.html#ga3eac86b6a2148e4930010fd4a718a30b">Cy_ISOUART_HostReadHighInterface</a> (const ISOUART_Type *base)</td></tr>
<tr class="memdesc:ga3eac86b6a2148e4930010fd4a718a30b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the latest frame data from the High interface.  <a href="#ga3eac86b6a2148e4930010fd4a718a30b">More...</a><br /></td></tr>
<tr class="separator:ga3eac86b6a2148e4930010fd4a718a30b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a3ec21178947cefe247a830d5d60a9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__isouart__host__functions.html#ga7a3ec21178947cefe247a830d5d60a9a">Cy_ISOUART_HostSendWriteCommand</a> (ISOUART_Type *base, uint32_t blockId, uint32_t nodeId, uint32_t address, uint16_t data)</td></tr>
<tr class="memdesc:ga7a3ec21178947cefe247a830d5d60a9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a write command frame (sequenced mode) to a node.  <a href="#ga7a3ec21178947cefe247a830d5d60a9a">More...</a><br /></td></tr>
<tr class="separator:ga7a3ec21178947cefe247a830d5d60a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ca934c5454237de73583ef5a9ad919f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__isouart__host__functions.html#ga1ca934c5454237de73583ef5a9ad919f">Cy_ISOUART_HostSendReadCommand</a> (ISOUART_Type *base, uint32_t blockId, uint32_t nodeId, uint32_t address)</td></tr>
<tr class="memdesc:ga1ca934c5454237de73583ef5a9ad919f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a read command frame (sequenced mode) to a node.  <a href="#ga1ca934c5454237de73583ef5a9ad919f">More...</a><br /></td></tr>
<tr class="separator:ga1ca934c5454237de73583ef5a9ad919f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb42bc154fe919839bac5c17cb09a78a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__isouart__host__functions.html#gabb42bc154fe919839bac5c17cb09a78a">Cy_ISOUART_HostSendManualCommand</a> (ISOUART_Type *base, uint8_t data)</td></tr>
<tr class="memdesc:gabb42bc154fe919839bac5c17cb09a78a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a single 8-bit frame in manual mode.  <a href="#gabb42bc154fe919839bac5c17cb09a78a">More...</a><br /></td></tr>
<tr class="separator:gabb42bc154fe919839bac5c17cb09a78a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5834661246ac6c970933a526a46bb2f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__isouart__host__functions.html#gab5834661246ac6c970933a526a46bb2f">Cy_ISOUART_HostVerifyCRC</a> (uint8_t frameData)</td></tr>
<tr class="memdesc:gab5834661246ac6c970933a526a46bb2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies the CRC contained in a write response byte.  <a href="#gab5834661246ac6c970933a526a46bb2f">More...</a><br /></td></tr>
<tr class="separator:gab5834661246ac6c970933a526a46bb2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga2df0457ce3ec1288562be27318ce26c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2df0457ce3ec1288562be27318ce26c5">&#9670;&nbsp;</a></span>Cy_ISOUART_HostInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_ISOUART_HostInit </td>
          <td>(</td>
          <td class="paramtype">ISOUART_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__stc__isouart__host__config__t.html">cy_stc_isouart_host_config_t</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Full Init of the iso UART in host mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base address for the iso UART. </td></tr>
    <tr><td class="paramname">config</td><td>Configuration options for the iso UART in host mode. See <a class="el" href="structcy__stc__isouart__host__config__t.html">cy_stc_isouart_host_config_t</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is valid only for Host. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function depends on the SysClk frequency and requires re-initialization if it changes to avoid frame errors. Ensure that CSV events (if enabled) are handled properly and trigger re-initialization if the SysClk source switches to the backup source. </dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Populate Host configuration structure */</span></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structcy__stc__isouart__host__config__t.html">cy_stc_isouart_host_config_t</a> hostConfig =</div><div class="line">    {</div><div class="line">        .<a class="code" href="structcy__stc__isouart__host__config__t.html#a2dccce9fc133b2463c9480822f95dc05">topology</a>               = <a class="code" href="group__group__isouart__enums.html#gga7ae5099fccf3be08ddf434725e0124cfa7d851d32354f44abaebcea701ce98c82">CY_ISOUART_MOT</a>,                       <span class="comment">/* Master-on-Top topology. */</span></div><div class="line">        .hostBitrate            = <a class="code" href="group__group__isouart__enums.html#ggadf6158d9884867f717026c8a3010b8cda9dd2e9b9346846e8018baf98c06af292">CY_ISOUART_HOST_BITRATE_2_1MBPS</a>,      <span class="comment">/* 2.1 Mbps data rate. */</span></div><div class="line">        .receiverMode           = <a class="code" href="group__group__isouart__enums.html#ggada45cd4ff842f52208cb24ef9d182546a1679c08d80fe2ce05cbe0283791cdfe7">CY_ISOUART_RECEIVER_MODE_UNPACKED</a>,    <span class="comment">/* Unpacked receive mode. */</span></div><div class="line">        .crcPolicy              = <a class="code" href="group__group__isouart__enums.html#gga5f8723808993c8c35ff8e4a38431b5f8a07911441f1719321ecd737d30d8c3f51">CY_ISOUART_CRC8_SAE_J1850</a>,            <span class="comment">/* CRC8 SAE J1850 polynomial. */</span></div><div class="line">        .enableBlockId          = <span class="keyword">true</span>,                                 <span class="comment">/* Enable Block ID feature. */</span></div><div class="line">        .useWriteDoneTrig       = <span class="keyword">false</span>,                                <span class="comment">/* No trigger on write complete. */</span></div><div class="line">        .useLowSramFullTrig     = <span class="keyword">false</span>,                                <span class="comment">/* No trigger when low SRAM full. */</span></div><div class="line">        .useHighSramFullTrig    = <span class="keyword">false</span>,                                <span class="comment">/* No trigger when high SRAM full. */</span></div><div class="line">        .enableMultiReadBC      = <span class="keyword">false</span>,                                <span class="comment">/* Disable broadcast multi-read. */</span></div><div class="line">        .enableInternalLoopback = <span class="keyword">false</span>,                                <span class="comment">/* Disable internal loopback. */</span></div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">/* Configure iso UART Host to operate */</span></div><div class="line">    <a class="code" href="group__group__isouart__host__functions.html#ga2df0457ce3ec1288562be27318ce26c5">Cy_ISOUART_HostInit</a>(ISOUART, &amp;hostConfig);</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga61d0688e051bc9c5186d9b46d1304474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61d0688e051bc9c5186d9b46d1304474">&#9670;&nbsp;</a></span>Cy_ISOUART_HostEnableWakeSequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_ISOUART_HostEnableWakeSequence </td>
          <td>(</td>
          <td class="paramtype">ISOUART_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>wakeCmdDelay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the transmission of wake sequence. </p>
<p>The registered wake sequence will be sent prior to next command transmission. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base address for the iso UART. </td></tr>
    <tr><td class="paramname">wakeCmdDelay</td><td>Amount of delay between wake sequence and command frame. Each count corresponds to 1/(iso UART IP input clock [Hz]) seconds. Valid range is [0x2EE0 ... 0x3FFC]. The appropriate delay value is specific to the node hardware - refer to the target node IC datasheet for the required delay specification. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is valid only for Host. </dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: Perform node enumeration in Master-on-Top topology.</span></div><div class="line"><span class="comment">     * This process assigns a unique ID to a node and configures it as the final node in the chain.</span></div><div class="line"><span class="comment">     * This example uses polling to wait for command completion instead of interrupt-driven approach.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">const</span> uint32_t blockId = 0UL;   <span class="comment">/* Applied block ID (Applicable if block ID is enabled). */</span></div><div class="line">    <span class="keyword">const</span> uint32_t nodeId  = 1UL;   <span class="comment">/* Applied ID to the node, must start from 0 and sequential. */</span></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> isFinalNode = <span class="keyword">true</span>;  <span class="comment">/* Specify the node is the last node in the chain, this config affects broadcast command. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* For the 1st command, enable the wakeup sequence to awake nodes in the chain.</span></div><div class="line"><span class="comment">     * This request is one-shot, no need to send a wakeup sequence other than the 1st command.</span></div><div class="line"><span class="comment">     * The wakeup delay depends on the nodes in the chain, the delay allows nodes to set up themselves to react to commands.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <a class="code" href="group__group__isouart__host__functions.html#ga61d0688e051bc9c5186d9b46d1304474">Cy_ISOUART_HostEnableWakeSequence</a>(ISOUART, 0x2EE0UL);</div><div class="line"></div><div class="line">    <span class="comment">/* Prepare node configuration data. */</span></div><div class="line">    <span class="keyword">const</span> uint16_t configData = (nodeId | (blockId &lt;&lt; 6UL) | (isFinalNode &lt;&lt; 11UL));</div><div class="line"></div><div class="line">    <span class="comment">/* Send the configuration command into the bus.</span></div><div class="line"><span class="comment">     * Node ID in the enumeration command must be 0.</span></div><div class="line"><span class="comment">     * Prior to the command frame, the requested wakeup sequence will be sent.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <a class="code" href="group__group__isouart__host__functions.html#ga7a3ec21178947cefe247a830d5d60a9a">Cy_ISOUART_HostSendWriteCommand</a>(ISOUART, blockId, 0UL, <a class="code" href="group__group__isouart__macros__reserved__addresses.html#ga3ae2ac6d18f215b34ea8c68f24571185">CY_ISOUART_ADDR_CONFIG</a>, configData);</div><div class="line"></div><div class="line">    <span class="comment">/* Wait for Write command completion by polling FRAME_RECEIVED interrupt status</span></div><div class="line"><span class="comment">     * (interface side depends on topology) instead of using interrupt service routine.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    uint32_t intrStatus = 0UL;</div><div class="line">    <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">        intrStatus = <a class="code" href="group__group__isouart__interrupt__functions.html#gab6fca3a063d0446136bfa052cc2f783d">Cy_ISOUART_GetInterruptStatusMasked</a>(ISOUART);</div><div class="line">    } <span class="keywordflow">while</span> (0UL == (intrStatus &amp; <a class="code" href="group__group__isouart__macros__interrupt__masks.html#ga348b62bed7f47685f3f46a479cd046f7">CY_ISOUART_INTR_MASTER_LOW_FRAME_RECEIVED</a>));</div><div class="line"></div><div class="line">    <span class="comment">/* Clear interrupt flags. */</span></div><div class="line">    <a class="code" href="group__group__isouart__interrupt__functions.html#ga59a17f6508ba472e5626b8082da1ab04">Cy_ISOUART_ClearInterrupt</a>(ISOUART, intrStatus);</div><div class="line"></div><div class="line">    <span class="comment">/* Read the write response from low interface (because of MOT topology)</span></div><div class="line"><span class="comment">     * and verify the CRC of the write response.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    uint8_t regVal_low = <a class="code" href="group__group__isouart__host__functions.html#gaef4277791822d589ceb1322921c441e9">Cy_ISOUART_HostReadLowInterface</a>(ISOUART);</div><div class="line">    <span class="keywordtype">bool</span> ret_low = <a class="code" href="group__group__isouart__host__functions.html#gab5834661246ac6c970933a526a46bb2f">Cy_ISOUART_HostVerifyCRC</a>(regVal_low);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<span class="keyword">false</span> == ret_low)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Handle the incorrect CRC data in the write response. */</span></div><div class="line">    }</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="gaef4277791822d589ceb1322921c441e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef4277791822d589ceb1322921c441e9">&#9670;&nbsp;</a></span>Cy_ISOUART_HostReadLowInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint8_t Cy_ISOUART_HostReadLowInterface </td>
          <td>(</td>
          <td class="paramtype">const ISOUART_Type *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the latest frame data from the Low interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base address for the iso UART. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The latest frame data from the Low interface. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is valid only for Host. </dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: Perform write operation to specific node in Master-on-Top topology.</span></div><div class="line"><span class="comment">     * This demonstrates sending data to node SRAM and verifying write response with CRC check.</span></div><div class="line"><span class="comment">     * This example uses polling to wait for command completion instead of interrupt-driven approach.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="comment">/* Write command parameters */</span></div><div class="line">    <span class="keyword">const</span> uint32_t address   = 0UL;         <span class="comment">/* SRAM address to write to. */</span></div><div class="line">    <span class="keyword">const</span> uint32_t writeData = 0x1234UL;    <span class="comment">/* Data to write. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Send Write command in sequenced mode. */</span></div><div class="line">    <a class="code" href="group__group__isouart__host__functions.html#ga7a3ec21178947cefe247a830d5d60a9a">Cy_ISOUART_HostSendWriteCommand</a>(ISOUART, blockId, nodeId, address, writeData);</div><div class="line"></div><div class="line">    <span class="comment">/* Wait for Write command completion by polling FRAME_RECEIVED interrupt status</span></div><div class="line"><span class="comment">     * (interface side depends on topology) instead of using interrupt service routine.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    uint32_t intrStatus = 0UL;</div><div class="line">    <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">        intrStatus = <a class="code" href="group__group__isouart__interrupt__functions.html#gaa27998c25657a4a8c5225d995d2044cc">Cy_ISOUART_GetInterruptStatus</a>(ISOUART);</div><div class="line">    } <span class="keywordflow">while</span> (0UL == (intrStatus &amp; CY_ISOUART_INTR_MASTER_LOW_FRAME_RECEIVED));</div><div class="line"></div><div class="line">    <span class="comment">/* Clear interrupt flags. */</span></div><div class="line">    <a class="code" href="group__group__isouart__interrupt__functions.html#ga59a17f6508ba472e5626b8082da1ab04">Cy_ISOUART_ClearInterrupt</a>(ISOUART, intrStatus);</div><div class="line"></div><div class="line">    <span class="comment">/* Read the write response from low interface (because of MOT topology)</span></div><div class="line"><span class="comment">     * and verify the CRC of the write response.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    uint8_t regVal_low = <a class="code" href="group__group__isouart__host__functions.html#gaef4277791822d589ceb1322921c441e9">Cy_ISOUART_HostReadLowInterface</a>(ISOUART);</div><div class="line">    <span class="keywordtype">bool</span> ret_low = <a class="code" href="group__group__isouart__host__functions.html#gab5834661246ac6c970933a526a46bb2f">Cy_ISOUART_HostVerifyCRC</a>(regVal_low);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<span class="keyword">false</span> == ret_low)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Handle incorrect CRC data in write response. */</span></div><div class="line">    }</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga3eac86b6a2148e4930010fd4a718a30b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3eac86b6a2148e4930010fd4a718a30b">&#9670;&nbsp;</a></span>Cy_ISOUART_HostReadHighInterface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint8_t Cy_ISOUART_HostReadHighInterface </td>
          <td>(</td>
          <td class="paramtype">const ISOUART_Type *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the latest frame data from the High interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base address for the iso UART. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The latest frame data from the High interface. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is valid only for Host. </dd></dl>

</div>
</div>
<a id="ga7a3ec21178947cefe247a830d5d60a9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a3ec21178947cefe247a830d5d60a9a">&#9670;&nbsp;</a></span>Cy_ISOUART_HostSendWriteCommand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_ISOUART_HostSendWriteCommand </td>
          <td>(</td>
          <td class="paramtype">ISOUART_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>blockId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nodeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a write command frame (sequenced mode) to a node. </p>
<p>If a wake sequence was previously enabled with <a class="el" href="group__group__isouart__host__functions.html#ga61d0688e051bc9c5186d9b46d1304474" title="Enables the transmission of wake sequence. ">Cy_ISOUART_HostEnableWakeSequence()</a>, the wake sequence is transmitted automatically before this frame. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base address for the iso UART. </td></tr>
    <tr><td class="paramname">blockId</td><td>Block ID placed in the frame when block ID feature is enabled. Valid range: 0..6 (ignored if block ID is disabled). </td></tr>
    <tr><td class="paramname">nodeId</td><td>Target node ID. <br />
 0 : Enumeration <br />
 1..30 : Normal node IDs <br />
 63 : Broadcast </td></tr>
    <tr><td class="paramname">address</td><td>Target register / SRAM address. Valid range: 0..127. </td></tr>
    <tr><td class="paramname">data</td><td>16-bit payload to be written. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>Clears the internal wake sequence pending flag after transmission.</li>
<li>This function is valid only for Host. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: Perform write operation to specific node in Master-on-Top topology.</span></div><div class="line"><span class="comment">     * This demonstrates sending data to node SRAM and verifying write response with CRC check.</span></div><div class="line"><span class="comment">     * This example uses polling to wait for command completion instead of interrupt-driven approach.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="comment">/* Write command parameters */</span></div><div class="line">    <span class="keyword">const</span> uint32_t address   = 0UL;         <span class="comment">/* SRAM address to write to. */</span></div><div class="line">    <span class="keyword">const</span> uint32_t writeData = 0x1234UL;    <span class="comment">/* Data to write. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Send Write command in sequenced mode. */</span></div><div class="line">    <a class="code" href="group__group__isouart__host__functions.html#ga7a3ec21178947cefe247a830d5d60a9a">Cy_ISOUART_HostSendWriteCommand</a>(ISOUART, blockId, nodeId, address, writeData);</div><div class="line"></div><div class="line">    <span class="comment">/* Wait for Write command completion by polling FRAME_RECEIVED interrupt status</span></div><div class="line"><span class="comment">     * (interface side depends on topology) instead of using interrupt service routine.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    uint32_t intrStatus = 0UL;</div><div class="line">    <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">        intrStatus = <a class="code" href="group__group__isouart__interrupt__functions.html#gaa27998c25657a4a8c5225d995d2044cc">Cy_ISOUART_GetInterruptStatus</a>(ISOUART);</div><div class="line">    } <span class="keywordflow">while</span> (0UL == (intrStatus &amp; CY_ISOUART_INTR_MASTER_LOW_FRAME_RECEIVED));</div><div class="line"></div><div class="line">    <span class="comment">/* Clear interrupt flags. */</span></div><div class="line">    <a class="code" href="group__group__isouart__interrupt__functions.html#ga59a17f6508ba472e5626b8082da1ab04">Cy_ISOUART_ClearInterrupt</a>(ISOUART, intrStatus);</div><div class="line"></div><div class="line">    <span class="comment">/* Read the write response from low interface (because of MOT topology)</span></div><div class="line"><span class="comment">     * and verify the CRC of the write response.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    uint8_t regVal_low = <a class="code" href="group__group__isouart__host__functions.html#gaef4277791822d589ceb1322921c441e9">Cy_ISOUART_HostReadLowInterface</a>(ISOUART);</div><div class="line">    <span class="keywordtype">bool</span> ret_low = <a class="code" href="group__group__isouart__host__functions.html#gab5834661246ac6c970933a526a46bb2f">Cy_ISOUART_HostVerifyCRC</a>(regVal_low);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<span class="keyword">false</span> == ret_low)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Handle incorrect CRC data in write response. */</span></div><div class="line">    }</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga1ca934c5454237de73583ef5a9ad919f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ca934c5454237de73583ef5a9ad919f">&#9670;&nbsp;</a></span>Cy_ISOUART_HostSendReadCommand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_ISOUART_HostSendReadCommand </td>
          <td>(</td>
          <td class="paramtype">ISOUART_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>blockId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nodeId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a read command frame (sequenced mode) to a node. </p>
<p>If a wake sequence was previously enabled with <a class="el" href="group__group__isouart__host__functions.html#ga61d0688e051bc9c5186d9b46d1304474" title="Enables the transmission of wake sequence. ">Cy_ISOUART_HostEnableWakeSequence()</a>, the wake sequence is transmitted automatically before this frame. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base address for the iso UART. </td></tr>
    <tr><td class="paramname">blockId</td><td>Block ID placed in the frame when the block ID feature is enabled. Valid range: 0..6 (ignored if the feature is disabled). </td></tr>
    <tr><td class="paramname">nodeId</td><td>Target node ID. <br />
 0 : Enumeration <br />
 1..30 : Normal node IDs <br />
 63 : Broadcast </td></tr>
    <tr><td class="paramname">address</td><td>Target register / SRAM address. Valid range: 0..127. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>Clears the internal wake sequence pending flag after transmission.</li>
<li>This function is valid only for Host. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: Perform read operation from specific node in Master-on-Top topology.</span></div><div class="line"><span class="comment">     * This demonstrates SRAM size configuration, reading data from node, and unpacked data retrieval.</span></div><div class="line"><span class="comment">     * This example uses polling to wait for command completion instead of interrupt-driven approach.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">const</span> uint32_t address = 0UL;   <span class="comment">/* SRAM address to read from. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Disable iso UART block. */</span></div><div class="line">    <a class="code" href="group__group__isouart__common__functions.html#gab90f55e8aeabb059fdc6f1d90884d3b2">Cy_ISOUART_Disable</a>(ISOUART);</div><div class="line"></div><div class="line">    <span class="comment">/* For the proper handling, set the interface SRAM size to the expected size by the transaction.</span></div><div class="line"><span class="comment">     * NOTE: The SRAM size shall only be changed when iso UART is disabled or both interfaces are in Slave mode.</span></div><div class="line"><span class="comment">     * e.g. for unpack mode, normal read command = 1</span></div><div class="line"><span class="comment">     * e.g. for raw mode, normal read command = 3</span></div><div class="line"><span class="comment">     * e.g. for unpack mode, multi read command = 1 x number of multi read</span></div><div class="line"><span class="comment">     * e.g. for unpack mode, BC read command = 1 x number of nodes in the chain</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <a class="code" href="group__group__isouart__sram__functions.html#ga13bf7ea2057d2b4290455ba10310fe1f">Cy_ISOUART_HostSetSramSize</a>(ISOUART, 1UL, 0UL); <span class="comment">/* Set the Low side 1 row, High side 0 row. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Enable iso UART to operate. */</span></div><div class="line">    <a class="code" href="group__group__isouart__common__functions.html#gadf7a574beb29a2411f540cf8356f6c16">Cy_ISOUART_Enable</a>(ISOUART);</div><div class="line"></div><div class="line">    <span class="comment">/* Perform Read operation. */</span></div><div class="line">    <a class="code" href="group__group__isouart__host__functions.html#ga1ca934c5454237de73583ef5a9ad919f">Cy_ISOUART_HostSendReadCommand</a>(ISOUART, blockId, nodeId, address);</div><div class="line">    <span class="comment">/* Wait for Read command completion by polling SRAM_FULL interrupt status</span></div><div class="line"><span class="comment">     * (interface side depends on topology) instead of using interrupt service routine.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    uint32_t intrStatus = 0UL;</div><div class="line">    <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">        intrStatus = <a class="code" href="group__group__isouart__interrupt__functions.html#gaa27998c25657a4a8c5225d995d2044cc">Cy_ISOUART_GetInterruptStatus</a>(ISOUART);</div><div class="line">    } <span class="keywordflow">while</span> (0UL == (intrStatus &amp; <a class="code" href="group__group__isouart__macros__interrupt__masks.html#ga4b3b00545aee1d8a31375a8a38a722ea">CY_ISOUART_INTR_MASTER_LOW_SRAM_FULL</a>));</div><div class="line"></div><div class="line">    <span class="comment">/* Clear interrupt flags. */</span></div><div class="line">    <a class="code" href="group__group__isouart__interrupt__functions.html#ga59a17f6508ba472e5626b8082da1ab04">Cy_ISOUART_ClearInterrupt</a>(ISOUART, intrStatus);</div><div class="line"></div><div class="line">    <span class="comment">/* Read data from low interface SRAM. */</span></div><div class="line">    uint16_t readData = <a class="code" href="group__group__isouart__sram__functions.html#gae2c475bbf77332590cfdf723ab6ceb22">Cy_ISOUART_HostReadSramUnpack</a>(ISOUART, <a class="code" href="group__group__isouart__enums.html#ggacf2d3e5d86ed1ad3bb584ef929f93faeab383854c267880dc0fd76cac0bb8e574">CY_ISOUART_IF_LOW</a>, 0UL);</div><div class="line">    <span class="comment">/* Process the read data */</span></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="gabb42bc154fe919839bac5c17cb09a78a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb42bc154fe919839bac5c17cb09a78a">&#9670;&nbsp;</a></span>Cy_ISOUART_HostSendManualCommand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_ISOUART_HostSendManualCommand </td>
          <td>(</td>
          <td class="paramtype">ISOUART_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a single 8-bit frame in manual mode. </p>
<p>If a wake sequence was previously enabled with <a class="el" href="group__group__isouart__host__functions.html#ga61d0688e051bc9c5186d9b46d1304474" title="Enables the transmission of wake sequence. ">Cy_ISOUART_HostEnableWakeSequence()</a>, the wake sequence is transmitted automatically before this frame. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base address for the iso UART. </td></tr>
    <tr><td class="paramname">data</td><td>1 byte frame to transmit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>Clears the internal wake sequence pending flag after transmission.</li>
<li>This function is valid only for Host. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gab5834661246ac6c970933a526a46bb2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5834661246ac6c970933a526a46bb2f">&#9670;&nbsp;</a></span>Cy_ISOUART_HostVerifyCRC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cy_ISOUART_HostVerifyCRC </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>frameData</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies the CRC contained in a write response byte. </p>
<p>Compares the lower 3 bits (CRC) of the supplied write response byte against the expected CRC looked up using the upper 5 bits as index. The response can be obtained via <a class="el" href="group__group__isouart__host__functions.html#gaef4277791822d589ceb1322921c441e9">Cy_ISOUART_HostReadLowInterface()</a> or <a class="el" href="group__group__isouart__host__functions.html#ga3eac86b6a2148e4930010fd4a718a30b">Cy_ISOUART_HostReadHighInterface()</a>. An interrupt after the write command completion indicates the reply is available. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frameData</td><td>Write response frame byte (bits[7:3] = payload, bits[2:0] = CRC). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true - CRC matches the expected value (response byte is valid). false - CRC mismatch (response byte is invalid). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is valid only for Host. </dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: Perform write operation to specific node in Master-on-Top topology.</span></div><div class="line"><span class="comment">     * This demonstrates sending data to node SRAM and verifying write response with CRC check.</span></div><div class="line"><span class="comment">     * This example uses polling to wait for command completion instead of interrupt-driven approach.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="comment">/* Write command parameters */</span></div><div class="line">    <span class="keyword">const</span> uint32_t address   = 0UL;         <span class="comment">/* SRAM address to write to. */</span></div><div class="line">    <span class="keyword">const</span> uint32_t writeData = 0x1234UL;    <span class="comment">/* Data to write. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Send Write command in sequenced mode. */</span></div><div class="line">    <a class="code" href="group__group__isouart__host__functions.html#ga7a3ec21178947cefe247a830d5d60a9a">Cy_ISOUART_HostSendWriteCommand</a>(ISOUART, blockId, nodeId, address, writeData);</div><div class="line"></div><div class="line">    <span class="comment">/* Wait for Write command completion by polling FRAME_RECEIVED interrupt status</span></div><div class="line"><span class="comment">     * (interface side depends on topology) instead of using interrupt service routine.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    uint32_t intrStatus = 0UL;</div><div class="line">    <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">        intrStatus = <a class="code" href="group__group__isouart__interrupt__functions.html#gaa27998c25657a4a8c5225d995d2044cc">Cy_ISOUART_GetInterruptStatus</a>(ISOUART);</div><div class="line">    } <span class="keywordflow">while</span> (0UL == (intrStatus &amp; CY_ISOUART_INTR_MASTER_LOW_FRAME_RECEIVED));</div><div class="line"></div><div class="line">    <span class="comment">/* Clear interrupt flags. */</span></div><div class="line">    <a class="code" href="group__group__isouart__interrupt__functions.html#ga59a17f6508ba472e5626b8082da1ab04">Cy_ISOUART_ClearInterrupt</a>(ISOUART, intrStatus);</div><div class="line"></div><div class="line">    <span class="comment">/* Read the write response from low interface (because of MOT topology)</span></div><div class="line"><span class="comment">     * and verify the CRC of the write response.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    uint8_t regVal_low = <a class="code" href="group__group__isouart__host__functions.html#gaef4277791822d589ceb1322921c441e9">Cy_ISOUART_HostReadLowInterface</a>(ISOUART);</div><div class="line">    <span class="keywordtype">bool</span> ret_low = <a class="code" href="group__group__isouart__host__functions.html#gab5834661246ac6c970933a526a46bb2f">Cy_ISOUART_HostVerifyCRC</a>(regVal_low);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<span class="keyword">false</span> == ret_low)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Handle incorrect CRC data in write response. */</span></div><div class="line">    }</div></div><!-- fragment --></dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>CAT2 Peripheral Driver Library</b> by <b>Infineon Technologies</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
