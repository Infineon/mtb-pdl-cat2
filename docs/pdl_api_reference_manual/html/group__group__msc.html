<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CAT2 Peripheral Driver Library: MSC          (Multi-Sense Converter)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CAT2 Peripheral Driver Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__msc.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">API Reference</a>  </div>
  <div class="headertitle">
<div class="title">MSC (Multi-Sense Converter)</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<p>The MSC HW block represents the devices of the fifth CAPSENSE&trade; generation. </p>
<p>It enables multiple sensing capabilities on PSoC&trade; devices, including self-cap and mutual-cap capacitive touch-sense solutions.</p>
<p>The CAPSENSE&trade; solution includes:</p><ul>
<li>The CAPSENSE&trade; Configurator tool, which is a configuration wizard to create and configure CAPSENSE&trade; widgets. It can be launched in ModusToolbox&trade; from the MSC personality as well as in standalone mode. It contains separate documentation on how to create and configure widgets, parameters, and algorithm descriptions.</li>
<li>An API to control the design from the application program. This documentation describes the API with code snippets about how to use them.</li>
<li>The CAPSENSE&trade; Tuner tool for real-time tuning, testing, and debugging, for easy and smooth design of human interfaces on customer products. The Tuner tool communicates with a device through a HW bridge and communication drivers (EzI2C, UART, etc.) and allows monitoring of widget statuses, sensor signals, detected touch positions, gestures, etc. The application program does not need to interact with the MSC driver and/or other drivers such as GPIO or SysClk directly. All of that is configured and managed by the middleware.</li>
</ul>
<div class="image">
<img src="capsense_solution_msc.png" alt="capsense_solution_msc.png" width="800px"/>
<div class="caption">
CAPSENSE&trade; Solution</div></div>
 <p>This section describes only the MSC driver. Refer to the corresponding sections for documentation of middleware supported by the MSC HW block.</p>
<p>The MSC driver is a low-level peripheral driver that provides an interface to a complex mixed signal of the MSC HW block.</p>
<p>The MSC driver alone does not provide system-level functions. Instead, it is used by upper-level middleware to configure the MSC HW block required by an application.</p>
<p>The MSC HW block can support only one function at a time. To allow seamless time-multiplex implementation of functionality and to avoid conflicting access to hardware from the upper level, the MSC driver also implements a lock semaphore mechanism.</p>
<p>The MSC driver supports re-entrance. If a device contains several MSC HW blocks, the same MSC driver is used to configure any HW block. For that, each function of the MSC driver contains a base address to define the MSC HW block to which the MSC driver communicates.</p>
<p>There is no restriction on the MSC Driver usage in RTOS.</p>
<h1><a class="anchor" id="group_msc_config_usage"></a>
Usage</h1>
<p>The MSC driver is a simple wrapper driver specifically designed to be used by higher level middleware. Hence, is highly not recommended to use the MSC driver directly in the application program. To incorporate MSC HW block functionality in the application program, an associated middleware should be used.</p>
<p>The MSC Driver can be used to implement a custom sensing solution. In such a case, the application program must acquire and lock the MSC HW block prior to accessing it.</p>
<p>Setting up and using the MSC driver can be summed up in these four stages:</p><ul>
<li>Define configuration in the config structure.</li>
<li>Allocate context structure variable for the driver.</li>
<li>Capture the MSC HW block.</li>
<li>Execute the action required to perform any kind of conversion.</li>
</ul>
<p>The following code snippet demonstrates how to capture the MSC HW block for custom implementation:</p>
<div class="fragment"><div class="line">    </div><div class="line">    <span class="comment">/* </span></div><div class="line"><span class="comment">    * Scenario: Need to capture MSC HW block to perform a conversion. </span></div><div class="line"><span class="comment">    * This scenario does not cover Pins, Clock, Interrupt, configuration.</span></div><div class="line"><span class="comment">    */</span></div><div class="line">    </div><div class="line">    <span class="comment">/*...*/</span></div><div class="line">    <a class="code" href="group__group__msc__enums.html#gaf04ee091d22c0f0d7820cf28b42e7f77">cy_en_msc_key_t</a> key;</div><div class="line">    <a class="code" href="group__group__msc__enums.html#ga9fe48c8f643391f670829dacd2ff6ceb">cy_en_msc_status_t</a> status;</div><div class="line">    </div><div class="line">    <span class="comment">/* Allocate MSC configuration structure and initialize it with user&#39;s configuration */</span></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structcy__stc__msc__base__config__t.html">cy_stc_msc_base_config_t</a> customConfig = CUSTOM_CONFIG;</div><div class="line"></div><div class="line">    <span class="comment">/* Check if the MSC block if free */</span></div><div class="line">    key = <a class="code" href="group__group__msc__functions.html#ga7300f00209d19dd41ad65b90b1d5d422">Cy_MSC_GetLockStatus</a>(MSC0, &amp;mscContext);</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__msc__enums.html#ggaf04ee091d22c0f0d7820cf28b42e7f77a73600c7ddb101a45bff79da3d3c3ee22">CY_MSC_NONE_KEY</a> == key)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Capture the MSC block and initialize it with user&#39;s configuration */</span></div><div class="line">        status = <a class="code" href="group__group__msc__functions.html#gacc0ea745c376a5f6b52d4fe2c26137d2">Cy_MSC_Init</a>(MSC0, &amp;customConfig, <a class="code" href="group__group__msc__enums.html#ggaf04ee091d22c0f0d7820cf28b42e7f77ad4cf4c0345815880e364fef38afa7080">CY_MSC_USER_DEFINED_KEY</a>, &amp;mscContext);</div><div class="line">        <span class="comment">/* Check if the MSC block was captured successfully */</span></div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="group__group__msc__enums.html#gga9fe48c8f643391f670829dacd2ff6ceba415eedb4cfdd83ff678aedacdc110ab8">CY_MSC_SUCCESS</a> == status)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Block is captured successfully. User&#39;s application code can be placed and executed here. */</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="comment">/*...*/</span></div><div class="line">    </div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>User's application code should follow these recommendations:<ol type="1">
<li>The last sensor configuration in the frame should have the LAST bit of SNS_CTL register set.</li>
<li>The START_FRAME bit of FRAME_CMD register should be set prior to calling the <a class="el" href="group__group__msc__functions.html#ga978f18dbbf24f2931a6129fc9339a24a" title="Sets configuration of sensor frame registers of the MSC HW block and starts the scan. ">Cy_MSC_ConfigureScan()</a> API. It should be set once per frame if the frame contains multiple sensor configurations, and each frame if the frame contains only one sensor configuration.</li>
<li>The START_SCAN bit of SNS_CTL register should be set in the sensor frame to start the conversion.</li>
</ol>
</dd></dl>
<p>The entire solution, like CAPSENSE&trade;, in addition to the MSC HW block, incorporates the following instances:</p>
<ul>
<li><a class="el" href="group__group__msc.html#group_msc_config_clocks">Clocks</a></li>
<li><a class="el" href="group__group__msc.html#group_msc_config_interrupts">Interrupts</a></li>
<li><a class="el" href="group__group__msc.html#group_msc_config_pin">GPIO Pins</a></li>
</ul>
<p>The MSC driver does not configure those blocks and they should be managed by an upper level. When using CAPSENSE&trade;, those blocks are managed by the middleware.</p>
<h2><a class="anchor" id="group_msc_config_clocks"></a>
Clocks</h2>
<p>The MSC HW block requires a peripheral clock (clk_peri) input. It can be assigned using two methods:</p><ul>
<li>Using the Device Configurator (Peripheral-Clocks tab).</li>
<li>Using the SysClk (System Clock) driver. Refer to <a class="el" href="group__group__sysclk.html">SysClk (System Clock)</a> driver section for more details. If middleware is used, the clock is managed by middleware.</li>
</ul>
<h2><a class="anchor" id="group_msc_config_pin"></a>
GPIO Pins</h2>
<p>CAPSENSE&trade; provides the ability to form a user interface using widgets. Each widget consists of one or more sensors. These sensors are connected to the GPIO pins.</p>
<p>The MSC HW block supports two types of the connection GPIO pin-to-block:</p>
<ol type="1">
<li>Through analog buses.</li>
</ol>
<p>This is a legacy connection through an analog multiplexed bus (AMUXBUS) available in previous generations of CAPSENSE&trade; devices.</p>
<p>Any analog-capable GPIO pin that can be connected to an analog multiplexed bus (AMUXBUS) can be connected to the MSC HW block as an input / sensor.</p>
<p>A GPIO input can be assigned to the MSC HW block using the following methods:</p><ul>
<li>Using the Device Configurator (Pins tab).</li>
<li>Using the GPIO (General Purpose Input Output) driver. Refer to the <a class="el" href="group__group__gpio.html">GPIO (General Purpose Input Output)</a> driver section.</li>
</ul>
<p>If middleware is used, pin configuration is managed by the middleware. Under the MSC driver custom implementation, the application program must manage the pin connections.</p>
<p>Each AMUXBUS can be split into multiple segments. Ensure that the MSC HW block and a GPIO belong to the same bus segment or join the segments to establish the connection GPIO-to-MSC HW block.</p>
<p>For more information about pin configuration, refer to the <a class="el" href="group__group__gpio.html">GPIO (General Purpose Input Output)</a> driver.</p>
<ol type="1">
<li>With a direct pin-to-block wire.</li>
</ol>
<p>The enhanced direct HW-wire connection pin-to-MSC HW block is available in the devices of the fifth generation CAPSENSE&trade;.</p>
<p>Only dedicated pins can be used for such a type of connection. Refer to the device datasheet for the exact pin definition.</p>
<p>A GPIO input can be assigned to the MSC HW block only by proper configuration of the MSC HW block. If middleware is used, pin configuration is managed by the middleware.</p>
<p>Under the MSC driver custom implementation, the application program must manage the pin connections.</p><ul>
<li>Configure a pin to High-Z analog mode without any connection to analog buses.</li>
<li>Configure the pin connection inside the MSC HW block.</li>
</ul>
<p>The advantages of this type of a connection under the CAPSENSE&trade; MW usage are the following:</p><ul>
<li>CAPSENSE&trade; MW pre-calculates all needed configurations in advance (during initialization)</li>
<li>CAPSENSE&trade; MW triggers the next scanning by writing to several registers of the MSC HW block (instead of disconnecting a previously scanned sensor and connecting a new sensor). If in your case, the scanning refresh rate is as an important characteristic, use the second connection type.</li>
</ul>
<h2><a class="anchor" id="group_msc_config_interrupts"></a>
Interrupts</h2>
<p>The MSC HW block has one interrupt. The MSC HW block can generate interrupts on the following events:</p>
<ul>
<li>End of scan: scanning of a single sensor is complete.</li>
<li>End of frame: scanning of a whole set of sensors (frame) is complete.</li>
</ul>
<p>Additionally, the MSC interrupt can wake the device from the Sleep power mode. The MSC HW block is powered down in the Deep Sleep power mode. So, it cannot be used as a wake-up source in this power mode.</p>
<p>If a CAPSENSE&trade; is used, the interrupt service routine is managed by middleware. When using the MSC driver for custom implementation or other middleware, the application program must manage the interrupt service routine.</p>
<p>Implement an interrupt routine and assign it to the MSC interrupt. Use the pre-defined enumeration as the interrupt source of the MSC HW block. The MSC interrupt to the NVIC is raised any time the intersection (logic AND) of the interrupt flags and the corresponding interrupt masks are non-zero. The peripheral interrupt status register should be read in the ISR to detect which condition generated the interrupt. The appropriate interrupt registers should be cleared so that subsequent interrupts can be handled.</p>
<p>The following code snippet demonstrates how to implement a routine to handle the interrupt. The routine is called when a MSC interrupt is triggered.</p>
<div class="fragment"><div class="line"></div><div class="line">    <span class="keywordtype">void</span> snippet_Cy_MSC_IntHandler(<span class="keywordtype">void</span>)</div><div class="line">    {</div><div class="line">        uint32_t intrStatus;</div><div class="line"></div><div class="line">        <span class="comment">/* Read interrupt status register */</span></div><div class="line">        intrStatus = <a class="code" href="group__group__msc__functions.html#gaa3fd30f4bdda2c15d7a5893f1b7accdf">Cy_MSC_ReadReg</a>(MSC0, <a class="code" href="group__group__msc__reg__const.html#gae48f5040a961aa4f57c29da590a3b5a3">CY_MSC_REG_OFFSET_INTR</a>);</div><div class="line"></div><div class="line">        <span class="comment">/* Check an event that triggered the interrupt */</span></div><div class="line">        <span class="keywordflow">if</span> ((intrStatus &amp; MSC_INTR_SET_SCAN_Msk) == MSC_INTR_SET_SCAN_Msk)</div><div class="line">        {</div><div class="line">            <span class="comment">/* End of scan occurred, get the result and do something with it here */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* Clear pending interrupt */</span></div><div class="line">        <a class="code" href="group__group__msc__functions.html#ga71f834fa6681635cb621565482ddda9c">Cy_MSC_WriteReg</a>(MSC0, <a class="code" href="group__group__msc__reg__const.html#gae48f5040a961aa4f57c29da590a3b5a3">CY_MSC_REG_OFFSET_INTR</a>, intrStatus);</div><div class="line">        (void)<a class="code" href="group__group__msc__functions.html#gaa3fd30f4bdda2c15d7a5893f1b7accdf">Cy_MSC_ReadReg</a>(MSC0, <a class="code" href="group__group__msc__reg__const.html#gae48f5040a961aa4f57c29da590a3b5a3">CY_MSC_REG_OFFSET_INTR</a>);</div><div class="line">    }</div><div class="line">    </div></div><!-- fragment --><p> The following code snippet demonstrates how to configure and enable the MSC interrupt:</p>
<div class="fragment"><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structcy__stc__sysint__t.html">cy_stc_sysint_t</a> MSC0_ISR_cfg =</div><div class="line">    {</div><div class="line">        .<a class="code" href="structcy__stc__sysint__t.html#a6da08d81da65a7f93d3e4c46a4b8d950">intrSrc</a> = msc_0_interrupt_IRQn,  <span class="comment">/* Interrupt source is the MSC interrupt */</span></div><div class="line">        .intrPriority = 3u,             <span class="comment">/* Interrupt priority is 3 */</span></div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">/* Configure the interrupt with vector at snippet_Cy_MSC_IntHandler() */</span></div><div class="line">    (void)<a class="code" href="group__group__sysint__functions.html#gab2ff6820a898e9af3f780000054eea5d">Cy_SysInt_Init</a>(&amp;MSC0_ISR_cfg, snippet_Cy_MSC_IntHandler);</div><div class="line"></div><div class="line">    <span class="comment">/* Enable the interrupt */</span></div><div class="line">    NVIC_EnableIRQ(MSC0_ISR_cfg.<a class="code" href="structcy__stc__sysint__t.html#a6da08d81da65a7f93d3e4c46a4b8d950">intrSrc</a>);</div><div class="line"></div><div class="line">    <span class="comment">/* Enable the MSC SCAN interrupt mask */</span></div><div class="line">    <a class="code" href="group__group__msc__functions.html#ga71f834fa6681635cb621565482ddda9c">Cy_MSC_WriteReg</a>(MSC0, <a class="code" href="group__group__msc__reg__const.html#gaf95297f33a86acd2c3818c505656c9e6">CY_MSC_REG_OFFSET_INTR_MASK</a>, MSC_INTR_MASK_SCAN_Msk);</div><div class="line">    </div></div><!-- fragment --><p> For more information, refer to the <a class="el" href="group__group__sysint.html">SysInt (System Interrupt)</a> driver.</p>
<p>Alternatively, instead of handling the interrupts, the <a class="el" href="group__group__msc__functions.html#gaef8babe356b88df6496c00af5eaa2856">Cy_MSC_GetConversionStatus()</a> function allows for firmware polling of the MSC block status.</p>
<h1><a class="anchor" id="group_msc_config_power_modes"></a>
Power Modes</h1>
<p>The MSC HW block can operate in Active and Sleep CPU power modes. It is also possible to switch between Low power and Ultra Low power system modes. In Deep Sleep power mode, the MSC HW block is powered off. When the device wakes up from Deep Sleep, the MSC HW block resumes operation without the need for re-initialization.</p>
<dl class="section note"><dt>Note</dt><dd><ol type="1">
<li>The MSC driver does not provide a callback function to facilitate the low-power mode transitions. The responsibility belongs to an upper level that uses the MSC HW block to ensure the MSC HW block is not busy prior to a power mode transition.</li>
<li>A power mode transition is not recommended while the MSC HW block is busy. The MSC HW block status must be checked using the Cy_MSC_GetStatus() function prior to a power mode transition. Instead, use the same power mode for active operation of the MSC HW block. This restriction is not applicable to Sleep mode and the device can seamlessly enter and exit Sleep mode while the MSC HW block is busy.</li>
</ol>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd><ol type="1">
<li>Do not enter Deep Sleep power mode if the MSC HW block conversion is in progress. Unexpected behavior may occur.</li>
<li>The MSC HW block initializes in several microseconds after Power on / Deep Sleep exit. Refer to the technical reference manual (TRM) and the device datasheet for the exact number.</li>
</ol>
</dd></dl>
<p>Refer to the <a class="el" href="group__group__syspm.html">SysPm (System Power Management)</a> driver for more information about low-power mode transitions.</p>
<h1><a class="anchor" id="group_msc_more_information"></a>
More Information</h1>
<p>Important information about the CAPSENSE&trade; technology overview, appropriate Infineon device for the design, CAPSENSE&trade; system and sensor design guidelines, different interfaces and tuning guidelines necessary for a successful design of a CAPSENSE&trade; system is available in the Getting Started with CAPSENSE&trade; document and the product-specific CAPSENSE&trade; design guide. Infineon highly recommends starting with these documents. They can be found on the Infineon web site at www.infineon.com</p>
<p>For more information, refer to the following documents:</p>
<ul>
<li>CAPSENSE&trade; Overview:<ul>
<li><a href="https://github.com/Infineon/capsense"><b>CAPSENSE&trade; Middleware Library</b></a></li>
<li><a href="https://infineon.github.io/capsense/capsense_api_reference_manual/html/index.html"><b>CAPSENSE&trade; Middleware API Reference Guide</b></a></li>
<li><a href="https://documentation.infineon.com/html/modustoolbox-software/en/latest/tool-guide/ModusToolbox_CapSense_Configurator_Guide.html"><b>ModusToolbox&trade; CAPSENSE&trade; Configurator Tool Guide</b></a></li>
<li><a href="https://documentation.infineon.com/html/modustoolbox-software/en/latest/tool-guide/ModusToolbox_CapSense_Tuner_Guide.html"><b>ModusToolbox&trade; CAPSENSE&trade; Tuner Tool Guide</b></a></li>
<li><a href="https://www.infineon.com/dgdl/Infineon-AN85951_PSoC_4_and_PSoC_6_MCU_CapSense_Design_Guide-ApplicationNotes-v27_00-EN.pdf?fileId=8ac78c8c7cdc391c017d0723535d4661"><b>CAPSENSE&trade; Design Guide</b></a></li>
</ul>
</li>
<li>ModusToolbox&trade; Overview:<ul>
<li><a href="https://www.infineon.com/cms/en/design-support/tools/sdk/modustoolbox-software"><b>ModusToolbox&trade; Software Environment, Quick Start Guide, Documentation, and Videos</b></a></li>
<li><a href="https://documentation.infineon.com/html/modustoolbox-software/en/latest/tool-guide/ModusToolbox_Device_Configurator_Guide.html"><b>ModusToolbox&trade; Device Configurator Tool Guide</b></a></li>
</ul>
</li>
<li>Infineon Kits:<ul>
<li><a href="https://www.infineon.com/cms/en/product/evaluation-boards/cy8ckit-041s-max/"><b>CY8CKIT-041S-MAX PSoC&trade; 4100S Max pioneer kit</b></a></li>
</ul>
</li>
<li>General Information:<ul>
<li><a href="https://infineon.github.io/mtb-pdl-cat2/pdl_api_reference_manual/html/index.html"><b>PDL API Reference</b></a></li>
<li><a href="https://www.infineon.com/dgdl/Infineon-PSoC_4100S_and_PSoC_4100S_Plus_PSoC_4_Architecture_TRM-AdditionalTechnicalInformation-v12_00-EN.pdf?fileId=8ac78c8c7d0d8da4017d0f9433460188"><b>PSoC&trade; 4100S and PSoC&trade; 4100S Plus: PSoC&trade; 4 Architecture Technical Reference Manual (TRM)</b></a></li>
<li><a href="https://github.com/Infineon"><b>Infineon Technologies GitHub</b></a></li>
<li><a href="http://www.infineon.com"><b>Infineon Technologies</b></a></li>
</ul>
</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The links to another software component's documentation (middleware and PDL) point to GitHub to the latest available version of the software. To get documentation of the specified version, download from GitHub and unzip the component archive. The documentation is available in the <em>docs</em> folder.</dd></dl>
<h1><a class="anchor" id="group_msc_changelog"></a>
Changelog</h1>
<table class="doxtable">
<tr>
<th>Version</th><th>Changes</th><th>Reason for Change </th></tr>
<tr>
<td>1.10.2 </td><td>Minor documentation updates </td><td>Documentation improvement  </td></tr>
<tr>
<td>1.10.1 </td><td>Update the paths to the code snippets </td><td>PDL structure update  </td></tr>
<tr>
<td>1.10 </td><td>Added <a class="el" href="group__group__msc__functions.html#ga0921e6a5b84094b5b7ca967bb0f20c35" title="Acquires and locks the MSC HW block without changing its configuration. ">Cy_MSC_Capture()</a> function </td><td>CAPSENSE&trade; memory consumption optimization  </td></tr>
<tr>
<td>1.0 </td><td>The initial version </td><td></td></tr>
</table>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
API Reference</h2></td></tr>
<tr class="memitem:group__group__msc__macros"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__msc__macros.html">Macros</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__msc__functions"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__msc__functions.html">Functions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__msc__data__structures"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__msc__data__structures.html">Data Structures</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__msc__enums"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__msc__enums.html">Enumerated Types</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>CAT2 Peripheral Driver Library</b> by <b>Infineon Technologies</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
