<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CAT2 Peripheral Driver Library: Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CAT2 Peripheral Driver Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__flash__functions.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Functions<div class="ingroups"><a class="el" href="group__group__flash.html">Flash        (Flash System Routine)</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gafaa220a63444c4e5a5abe9b8c2cec721"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html#gafaa220a63444c4e5a5abe9b8c2cec721">Cy_Flash_WriteRow</a> (uint32_t rowAddr, const uint32_t *data)</td></tr>
<tr class="memdesc:gafaa220a63444c4e5a5abe9b8c2cec721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases a row of Flash or Supervisory Flash and programs it with the new data.  <a href="#gafaa220a63444c4e5a5abe9b8c2cec721">More...</a><br /></td></tr>
<tr class="separator:gafaa220a63444c4e5a5abe9b8c2cec721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafed287628c010c2258f73c5777b52292"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html#gafed287628c010c2258f73c5777b52292">Cy_Flash_StartWrite</a> (uint32_t rowAddr, const uint32_t *data)</td></tr>
<tr class="memdesc:gafed287628c010c2258f73c5777b52292"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates a write to a row of Flash.  <a href="#gafed287628c010c2258f73c5777b52292">More...</a><br /></td></tr>
<tr class="separator:gafed287628c010c2258f73c5777b52292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47bffaa3c6e82aed0e0c1589fb7b6551"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html#ga47bffaa3c6e82aed0e0c1589fb7b6551">Cy_Flash_ResumeWrite</a> (void)</td></tr>
<tr class="memdesc:ga47bffaa3c6e82aed0e0c1589fb7b6551"><td class="mdescLeft">&#160;</td><td class="mdescRight">The non-blocking write row API <a class="el" href="group__group__flash__functions.html#gafed287628c010c2258f73c5777b52292">Cy_Flash_StartWrite()</a> requires that this function be called 3 times to complete the write.  <a href="#ga47bffaa3c6e82aed0e0c1589fb7b6551">More...</a><br /></td></tr>
<tr class="separator:ga47bffaa3c6e82aed0e0c1589fb7b6551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga436020eae198750c56b93dbabdf6dc6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html#ga436020eae198750c56b93dbabdf6dc6d">Cy_Flash_IsOperationComplete</a> (void)</td></tr>
<tr class="memdesc:ga436020eae198750c56b93dbabdf6dc6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current status of the Flash write operation.  <a href="#ga436020eae198750c56b93dbabdf6dc6d">More...</a><br /></td></tr>
<tr class="separator:ga436020eae198750c56b93dbabdf6dc6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29ac711091186d8a7790be298fb6148b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__flash__functions.html#ga29ac711091186d8a7790be298fb6148b">Cy_Flash_RowChecksum</a> (uint32_t rowAddr, uint32_t *checksumPtr)</td></tr>
<tr class="memdesc:ga29ac711091186d8a7790be298fb6148b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a checksum value of the specified Flash or Supervisory Flash row.  <a href="#ga29ac711091186d8a7790be298fb6148b">More...</a><br /></td></tr>
<tr class="separator:ga29ac711091186d8a7790be298fb6148b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="gafaa220a63444c4e5a5abe9b8c2cec721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafaa220a63444c4e5a5abe9b8c2cec721">&#9670;&nbsp;</a></span>Cy_Flash_WriteRow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a> Cy_Flash_WriteRow </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rowAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases a row of Flash or Supervisory Flash and programs it with the new data. </p>
<p>Does not return until the write operation is complete. Refer to the device datasheet for the details.</p>
<p>This API will automatically enable IMO and modify the clock settings for the device. Writing to Flash requires 48 MHz IMO and changes be made to the HFCLK settings. The configuration is restored before returning. HFCLK will have several frequency changes during the operation of this API between a minimum frequency of the current IMO frequency divided by 8 and a maximum frequency of 12 MHz. This will impact the operation of most of the hardware in the device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowAddr</td><td>Address of the Flash or Supervisory Flash row to which the data needs to be written. The address shall be aligned to the beginning of the row.</td></tr>
    <tr><td class="paramname">data</td><td>Array of bytes to write. The size of the array must be equal to the Flash row size defined by <a class="el" href="group__group__flash__config__macros.html#ga407c9c16fafa7275c911133eaf8563a4">CY_FLASH_SIZEOF_ROW</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__group__flash__enumerated__types.html">Enumerated Types</a></dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Define and initialize data to write */</span></div><div class="line">    uint32_t data[<a class="code" href="group__group__flash__config__macros.html#ga407c9c16fafa7275c911133eaf8563a4">CY_FLASH_SIZEOF_ROW</a> / <span class="keyword">sizeof</span>(uint32_t)];</div></div><!-- fragment --><div class="fragment"><div class="line">    <a class="code" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a> status;</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize data */</span></div><div class="line">    memset(data, 0x5A, <a class="code" href="group__group__flash__config__macros.html#ga407c9c16fafa7275c911133eaf8563a4">CY_FLASH_SIZEOF_ROW</a>);</div><div class="line"></div><div class="line">    <span class="comment">/* Write data at the specified row address */</span></div><div class="line">    status = <a class="code" href="group__group__flash__functions.html#gafaa220a63444c4e5a5abe9b8c2cec721">Cy_Flash_WriteRow</a>(0x00020000UL, data);</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__flash__enumerated__types.html#ggae3ceedae602af2dd75864cf38246f496a897d5be5e24dc4bc3dd18fed0dc46b02">CY_FLASH_DRV_SUCCESS</a> != status)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Handle error here */</span></div><div class="line">    }</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="gafed287628c010c2258f73c5777b52292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafed287628c010c2258f73c5777b52292">&#9670;&nbsp;</a></span>Cy_Flash_StartWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a> Cy_Flash_StartWrite </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rowAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiates a write to a row of Flash. </p>
<p>A call to this API is non-blocking. Use <a class="el" href="group__group__flash__functions.html#ga47bffaa3c6e82aed0e0c1589fb7b6551">Cy_Flash_ResumeWrite()</a> to resume Flash writes and <a class="el" href="group__group__flash__functions.html#ga436020eae198750c56b93dbabdf6dc6d">Cy_Flash_IsOperationComplete()</a> to ascertain status of the write operation. Supervisory Flash does not support non-blocking write.</p>
<p>This API will automatically enable IMO and modify the clock settings for the device. Writing to Flash requires 48 MHz IMO and changes be made to the HFCLK settings. The configuration is restored to original configuration by calling <a class="el" href="group__group__flash__functions.html#ga436020eae198750c56b93dbabdf6dc6d">Cy_Flash_IsOperationComplete()</a>. HFCLK will have several frequency changes during the operation of these API between a minimum frequency of the current IMO frequency divided by 8 and a maximum frequency of 12 MHz. This will impact the operation of most of the hardware in the device.</p>
<p>This API will automatically enable IMO and modify the clock settings for the device. Writing to Flash requires 48 MHz IMO and changes be made to the HFCLK settings. The configuration is restored to original configuration by calling <a class="el" href="group__group__flash__functions.html#ga436020eae198750c56b93dbabdf6dc6d">Cy_Flash_IsOperationComplete()</a>. HFCLK will have several frequency changes during the operation of this API and <a class="el" href="group__group__flash__functions.html#ga436020eae198750c56b93dbabdf6dc6d">Cy_Flash_IsOperationComplete()</a> API between a minimum frequency of the current IMO frequency divided by 8 and a maximum frequency of 12 MHz. This will impact the operation of most of the hardware in the device.</p>
<p>The devices require HFCLK to be sourced by 48 MHz IMO during Flash write. The IMO must be enabled before calling this function. This API will modify IMO configuration; it can be later restored to original configuration by calling <a class="el" href="group__group__flash__functions.html#ga436020eae198750c56b93dbabdf6dc6d">Cy_Flash_IsOperationComplete()</a>.</p>
<p>The non-blocking write row API <a class="el" href="group__group__flash__functions.html#gafed287628c010c2258f73c5777b52292">Cy_Flash_StartWrite()</a> requires <a class="el" href="group__group__flash__functions.html#ga47bffaa3c6e82aed0e0c1589fb7b6551">Cy_Flash_ResumeWrite()</a> to be called 3 times to complete the write. This can be done by configuring SPCIF interrupt and placing a call to this API.</p>
<p>For Cortex-M0+ based devices, if the user wants to keep the vector table in Flash when performing non-blocking Flash write then they need to make sure the vector table is placed in the Flash macro which is not getting programmed by configuring the VTOR register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowAddr</td><td>Address of the Flash row to which the data needs to be written. The address shall be aligned to the beginning of the row. Supervisory Flash is not supported.</td></tr>
    <tr><td class="paramname">data</td><td>Array of bytes to write. The size of the array must be equal to the Flash row size. The Flash row size for the selected device is defined by the <a class="el" href="group__group__flash__config__macros.html#ga407c9c16fafa7275c911133eaf8563a4">CY_FLASH_SIZEOF_ROW</a> macro. Refer to the device datasheet for the details.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__group__flash__enumerated__types.html">Enumerated Types</a>. Returns <a class="el" href="group__group__flash__enumerated__types.html#ggae3ceedae602af2dd75864cf38246f496a5244becc5d012c5195e6d04719575ed1">CY_FLASH_DRV_OPERATION_STARTED</a> in case of successful start.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The non-blocking operation does not return success status CY_FLASH_DRV_SUCCESS until the last <a class="el" href="group__group__flash__functions.html#ga47bffaa3c6e82aed0e0c1589fb7b6551">Cy_Flash_ResumeWrite()</a> API is complete. The CPUSS_SYSARG register will be reflecting the SRAM address during an ongoing non-blocking operation.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Define and initialize data to write */</span></div><div class="line">    uint32_t data[<a class="code" href="group__group__flash__config__macros.html#ga407c9c16fafa7275c911133eaf8563a4">CY_FLASH_SIZEOF_ROW</a> / <span class="keyword">sizeof</span>(uint32_t)];</div></div><!-- fragment --><div class="fragment"><div class="line">    <span class="comment">/* Store number of the Flash interrupts */</span></div><div class="line">    uint32_t intCount = 0U;</div><div class="line"></div><div class="line">    <span class="comment">/* Define flash interrupt configuration structure */</span></div><div class="line">    <a class="code" href="structcy__stc__sysint__t.html">cy_stc_sysint_t</a> int_cfg = {</div><div class="line">        .<a class="code" href="structcy__stc__sysint__t.html#a6da08d81da65a7f93d3e4c46a4b8d950">intrSrc</a> = cpuss_interrupt_spcif_IRQn,</div><div class="line">        .intrPriority = 0u</div><div class="line">    };</div><div class="line"></div><div class="line">    <span class="comment">/* Flash interrupt handler */</span></div><div class="line">    <span class="keywordtype">void</span> flash_isr(<span class="keywordtype">void</span>)</div><div class="line">    {</div><div class="line">        <span class="comment">/* The function returns the SRAM address if API execution is successful.</span></div><div class="line"><span class="comment">        *  The actual status returned only for call to complete the last operation.</span></div><div class="line"><span class="comment">        */</span></div><div class="line">        (void) <a class="code" href="group__group__flash__functions.html#ga47bffaa3c6e82aed0e0c1589fb7b6551">Cy_Flash_ResumeWrite</a>();</div><div class="line">        intCount++;</div><div class="line">    }</div></div><!-- fragment --><div class="fragment"><div class="line">    <a class="code" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a> status;</div><div class="line"></div><div class="line">    <span class="comment">/* Initialize data */</span></div><div class="line">    memset(data, 0x5A, <a class="code" href="group__group__flash__config__macros.html#ga407c9c16fafa7275c911133eaf8563a4">CY_FLASH_SIZEOF_ROW</a>);</div><div class="line"></div><div class="line">    <span class="comment">/* Configure Flash interrupt */</span></div><div class="line">    <a class="code" href="group__group__sysint__functions.html#gab2ff6820a898e9af3f780000054eea5d">Cy_SysInt_Init</a>(&amp;int_cfg, &amp;flash_isr);</div><div class="line">    NVIC_EnableIRQ(int_cfg.<a class="code" href="structcy__stc__sysint__t.html#a6da08d81da65a7f93d3e4c46a4b8d950">intrSrc</a>);</div><div class="line"></div><div class="line">    <span class="comment">/* Initiate non-blocking flash write (system clocks are updated) */</span></div><div class="line">    status = <a class="code" href="group__group__flash__functions.html#gafed287628c010c2258f73c5777b52292">Cy_Flash_StartWrite</a>(0x00020000UL, data);</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__flash__enumerated__types.html#ggae3ceedae602af2dd75864cf38246f496a5244becc5d012c5195e6d04719575ed1">CY_FLASH_DRV_OPERATION_STARTED</a> != status)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Handle error here */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (intCount &lt; 3U)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Do something else while 3 flash interrupts are processed */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Check status and restore system clocks */</span></div><div class="line">    status = <a class="code" href="group__group__flash__functions.html#ga436020eae198750c56b93dbabdf6dc6d">Cy_Flash_IsOperationComplete</a>();</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__flash__enumerated__types.html#ggae3ceedae602af2dd75864cf38246f496a897d5be5e24dc4bc3dd18fed0dc46b02">CY_FLASH_DRV_SUCCESS</a> != status)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Handle error here */</span></div><div class="line">    }</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga47bffaa3c6e82aed0e0c1589fb7b6551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47bffaa3c6e82aed0e0c1589fb7b6551">&#9670;&nbsp;</a></span>Cy_Flash_ResumeWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a> Cy_Flash_ResumeWrite </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The non-blocking write row API <a class="el" href="group__group__flash__functions.html#gafed287628c010c2258f73c5777b52292">Cy_Flash_StartWrite()</a> requires that this function be called 3 times to complete the write. </p>
<p>This can be done by configuring SPCIF interrupt and placing a call to this API.</p>
<p>It is advised not to prolong calling this API for more than 25 ms.</p>
<dl class="section note"><dt>Note</dt><dd>The non-blocking operation does not return success status CY_FLASH_DRV_SUCCESS until the last Resume API is complete. The CPUSS_SYSARG register will be reflecting the SRAM address during an ongoing non-blocking operation.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__group__flash__enumerated__types.html">Enumerated Types</a> </dd></dl>

</div>
</div>
<a id="ga436020eae198750c56b93dbabdf6dc6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga436020eae198750c56b93dbabdf6dc6d">&#9670;&nbsp;</a></span>Cy_Flash_IsOperationComplete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a> Cy_Flash_IsOperationComplete </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the current status of the Flash write operation. </p>
<dl class="section note"><dt>Note</dt><dd>The non-blocking operation does not return success status <a class="el" href="group__group__flash__enumerated__types.html#ggae3ceedae602af2dd75864cf38246f496a897d5be5e24dc4bc3dd18fed0dc46b02">CY_FLASH_DRV_SUCCESS</a> until the last <a class="el" href="group__group__flash__functions.html#ga47bffaa3c6e82aed0e0c1589fb7b6551">Cy_Flash_ResumeWrite()</a> is complete. The CPUSS_SYSARG register will be reflecting the SRAM address during an ongoing non-blocking operation.</dd></dl>
<p>Calling this API before starting a non-blocking write row operation using the <a class="el" href="group__group__flash__functions.html#gafed287628c010c2258f73c5777b52292">Cy_Flash_StartWrite</a> API will cause improper operation.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a> </dd></dl>

</div>
</div>
<a id="ga29ac711091186d8a7790be298fb6148b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga29ac711091186d8a7790be298fb6148b">&#9670;&nbsp;</a></span>Cy_Flash_RowChecksum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a> Cy_Flash_RowChecksum </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rowAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>checksumPtr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a checksum value of the specified Flash or Supervisory Flash row. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowAddr</td><td>The address of the row. The address shall be aligned to the beginning of the row.</td></tr>
    <tr><td class="paramname">checksumPtr</td><td>The pointer to the address where checksum is to be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a></dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <a class="code" href="group__group__flash__enumerated__types.html#gae3ceedae602af2dd75864cf38246f496">cy_en_flashdrv_status_t</a> status;</div><div class="line">    uint32_t checksum = 0U;</div><div class="line"></div><div class="line">    <span class="comment">/* Calculate checksum of the data at the specified row address */</span></div><div class="line">    status = <a class="code" href="group__group__flash__functions.html#ga29ac711091186d8a7790be298fb6148b">Cy_Flash_RowChecksum</a>(0x00020000UL, &amp;checksum);</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__flash__enumerated__types.html#ggae3ceedae602af2dd75864cf38246f496a897d5be5e24dc4bc3dd18fed0dc46b02">CY_FLASH_DRV_SUCCESS</a> != status)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Handle error here */</span></div><div class="line">    }</div></div><!-- fragment --></dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>CAT2 Peripheral Driver Library</b> by <b>Infineon Technologies</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
