<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CAT2 Peripheral Driver Library: Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CAT2 Peripheral Driver Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__wdt__functions.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Functions<div class="ingroups"><a class="el" href="group__group__wdt.html">WDT          (Watchdog Timer)</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaac6f64babfb1855f9ba8aecccc19ecb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdt__functions.html#gaac6f64babfb1855f9ba8aecccc19ecb4">Cy_WDT_Init</a> (void)</td></tr>
<tr class="memdesc:gaac6f64babfb1855f9ba8aecccc19ecb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the Watchdog timer to its default state:  <a href="#gaac6f64babfb1855f9ba8aecccc19ecb4">More...</a><br /></td></tr>
<tr class="separator:gaac6f64babfb1855f9ba8aecccc19ecb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82aec7e454d05d03dfd1d6fd5e573d5e"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdt__functions.html#ga82aec7e454d05d03dfd1d6fd5e573d5e">Cy_WDT_Enable</a> (void)</td></tr>
<tr class="memdesc:ga82aec7e454d05d03dfd1d6fd5e573d5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables watchdog timer reset generation.  <a href="#ga82aec7e454d05d03dfd1d6fd5e573d5e">More...</a><br /></td></tr>
<tr class="separator:ga82aec7e454d05d03dfd1d6fd5e573d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05f8bb5603ce46caf842bd0ad254f604"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdt__functions.html#ga05f8bb5603ce46caf842bd0ad254f604">Cy_WDT_IsEnabled</a> (void)</td></tr>
<tr class="memdesc:ga05f8bb5603ce46caf842bd0ad254f604"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the WDT enable/disable state.  <a href="#ga05f8bb5603ce46caf842bd0ad254f604">More...</a><br /></td></tr>
<tr class="separator:ga05f8bb5603ce46caf842bd0ad254f604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga709f597d56e7f7fb6717d5ff671491fa"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdt__functions.html#ga709f597d56e7f7fb6717d5ff671491fa">Cy_WDT_Disable</a> (void)</td></tr>
<tr class="memdesc:ga709f597d56e7f7fb6717d5ff671491fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables the WDT reset generation.  <a href="#ga709f597d56e7f7fb6717d5ff671491fa">More...</a><br /></td></tr>
<tr class="separator:ga709f597d56e7f7fb6717d5ff671491fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e7105cb2482131f03140a223caf5cc1"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdt__functions.html#ga1e7105cb2482131f03140a223caf5cc1">Cy_WDT_GetCount</a> (void)</td></tr>
<tr class="memdesc:ga1e7105cb2482131f03140a223caf5cc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the current WDT counter value.  <a href="#ga1e7105cb2482131f03140a223caf5cc1">More...</a><br /></td></tr>
<tr class="separator:ga1e7105cb2482131f03140a223caf5cc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e707a8236e6dcd90eede7e726a2648f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdt__functions.html#ga1e707a8236e6dcd90eede7e726a2648f">Cy_WDT_SetMatch</a> (uint32_t match)</td></tr>
<tr class="memdesc:ga1e707a8236e6dcd90eede7e726a2648f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the WDT counter match comparison value.  <a href="#ga1e707a8236e6dcd90eede7e726a2648f">More...</a><br /></td></tr>
<tr class="separator:ga1e707a8236e6dcd90eede7e726a2648f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77552627bbcbe8ded86f52b67f5f12b3"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdt__functions.html#ga77552627bbcbe8ded86f52b67f5f12b3">Cy_WDT_GetMatch</a> (void)</td></tr>
<tr class="memdesc:ga77552627bbcbe8ded86f52b67f5f12b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the WDT counter match comparison value.  <a href="#ga77552627bbcbe8ded86f52b67f5f12b3">More...</a><br /></td></tr>
<tr class="separator:ga77552627bbcbe8ded86f52b67f5f12b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafad1413ff11cfb3e3e2b5d9854dc793e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdt__functions.html#gafad1413ff11cfb3e3e2b5d9854dc793e">Cy_WDT_SetIgnoreBits</a> (uint32_t bitsNum)</td></tr>
<tr class="memdesc:gafad1413ff11cfb3e3e2b5d9854dc793e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configures the number of the most significant bits of the Watchdog timer that are not checked against the match.  <a href="#gafad1413ff11cfb3e3e2b5d9854dc793e">More...</a><br /></td></tr>
<tr class="separator:gafad1413ff11cfb3e3e2b5d9854dc793e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ec661a60927ab0c15e654540f55c95b"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdt__functions.html#ga3ec661a60927ab0c15e654540f55c95b">Cy_WDT_GetIgnoreBits</a> (void)</td></tr>
<tr class="memdesc:ga3ec661a60927ab0c15e654540f55c95b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the number of the most significant bits of the Watchdog timer that are not checked against the match.  <a href="#ga3ec661a60927ab0c15e654540f55c95b">More...</a><br /></td></tr>
<tr class="separator:ga3ec661a60927ab0c15e654540f55c95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6caa17bf5bcb0c365f60e602e653fed"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdt__functions.html#gab6caa17bf5bcb0c365f60e602e653fed">Cy_WDT_MaskInterrupt</a> (void)</td></tr>
<tr class="memdesc:gab6caa17bf5bcb0c365f60e602e653fed"><td class="mdescLeft">&#160;</td><td class="mdescRight">After masking interrupts from the WDT, they are not passed to the CPU.  <a href="#gab6caa17bf5bcb0c365f60e602e653fed">More...</a><br /></td></tr>
<tr class="separator:gab6caa17bf5bcb0c365f60e602e653fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38c69c98675d6024a7d73acb41b24399"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdt__functions.html#ga38c69c98675d6024a7d73acb41b24399">Cy_WDT_UnmaskInterrupt</a> (void)</td></tr>
<tr class="memdesc:ga38c69c98675d6024a7d73acb41b24399"><td class="mdescLeft">&#160;</td><td class="mdescRight">After unmasking interrupts from the WDT, they are passed to CPU.  <a href="#ga38c69c98675d6024a7d73acb41b24399">More...</a><br /></td></tr>
<tr class="separator:ga38c69c98675d6024a7d73acb41b24399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad62ce7b3562cf1754659eed3fab0e22a"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdt__functions.html#gad62ce7b3562cf1754659eed3fab0e22a">Cy_WDT_GetInterruptStatusMasked</a> (void)</td></tr>
<tr class="memdesc:gad62ce7b3562cf1754659eed3fab0e22a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an interrupt request register masked by an interrupt mask.  <a href="#gad62ce7b3562cf1754659eed3fab0e22a">More...</a><br /></td></tr>
<tr class="separator:gad62ce7b3562cf1754659eed3fab0e22a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga727d9ae6fdba36809bf631985a3eb987"><td class="memItemLeft" align="right" valign="top"><a id="ga727d9ae6fdba36809bf631985a3eb987"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdt__functions.html#ga727d9ae6fdba36809bf631985a3eb987">Cy_WDT_ClearInterrupt</a> (void)</td></tr>
<tr class="memdesc:ga727d9ae6fdba36809bf631985a3eb987"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the WDT interrupt request which is set as configured by WDT action and limits. <br /></td></tr>
<tr class="separator:ga727d9ae6fdba36809bf631985a3eb987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a86bbc9823552318191ea6c153e99fa"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdt__functions.html#ga8a86bbc9823552318191ea6c153e99fa">Cy_WDT_ClearWatchdog</a> (void)</td></tr>
<tr class="memdesc:ga8a86bbc9823552318191ea6c153e99fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears ("feeds") the watchdog, to prevent a XRES device reset.  <a href="#ga8a86bbc9823552318191ea6c153e99fa">More...</a><br /></td></tr>
<tr class="separator:ga8a86bbc9823552318191ea6c153e99fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a0d9b4d5c6454af7213b32c4db7671c"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdt__functions.html#ga5a0d9b4d5c6454af7213b32c4db7671c">Cy_WDT_Lock</a> (void)</td></tr>
<tr class="memdesc:ga5a0d9b4d5c6454af7213b32c4db7671c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks out configuration changes to the Watchdog Timer register.  <a href="#ga5a0d9b4d5c6454af7213b32c4db7671c">More...</a><br /></td></tr>
<tr class="separator:ga5a0d9b4d5c6454af7213b32c4db7671c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c4e41c9c1b0d575747d1a984e63a6b0"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdt__functions.html#ga0c4e41c9c1b0d575747d1a984e63a6b0">Cy_WDT_Unlock</a> (void)</td></tr>
<tr class="memdesc:ga0c4e41c9c1b0d575747d1a984e63a6b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlocks the Watchdog Timer configuration register.  <a href="#ga0c4e41c9c1b0d575747d1a984e63a6b0">More...</a><br /></td></tr>
<tr class="separator:ga0c4e41c9c1b0d575747d1a984e63a6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d651ba3f26230b7bf18ca730d342450"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdt__functions.html#ga7d651ba3f26230b7bf18ca730d342450">Cy_WDT_Locked</a> (void)</td></tr>
<tr class="memdesc:ga7d651ba3f26230b7bf18ca730d342450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the WDT lock state.  <a href="#ga7d651ba3f26230b7bf18ca730d342450">More...</a><br /></td></tr>
<tr class="separator:ga7d651ba3f26230b7bf18ca730d342450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3068b5f898aaecbb16a7e747eb2ac6a"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdt__functions.html#gac3068b5f898aaecbb16a7e747eb2ac6a">Cy_WDT_SetLowerLimit</a> (uint32_t match)</td></tr>
<tr class="memdesc:gac3068b5f898aaecbb16a7e747eb2ac6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set lower limit for watchdog.  <a href="#gac3068b5f898aaecbb16a7e747eb2ac6a">More...</a><br /></td></tr>
<tr class="separator:gac3068b5f898aaecbb16a7e747eb2ac6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga370b6a151be8d6a9facd471589c9dd5a"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdt__functions.html#ga370b6a151be8d6a9facd471589c9dd5a">Cy_WDT_SetUpperLimit</a> (uint32_t match)</td></tr>
<tr class="memdesc:ga370b6a151be8d6a9facd471589c9dd5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set upper limit for watchdog.  <a href="#ga370b6a151be8d6a9facd471589c9dd5a">More...</a><br /></td></tr>
<tr class="separator:ga370b6a151be8d6a9facd471589c9dd5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa398184eb16a3a080d4e96c32641c0e8"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdt__functions.html#gaa398184eb16a3a080d4e96c32641c0e8">Cy_WDT_SetWarnLimit</a> (uint32_t match)</td></tr>
<tr class="memdesc:gaa398184eb16a3a080d4e96c32641c0e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set warn limit for watchdog.  <a href="#gaa398184eb16a3a080d4e96c32641c0e8">More...</a><br /></td></tr>
<tr class="separator:gaa398184eb16a3a080d4e96c32641c0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea903a29e21c0e159352a816c326fe72"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdt__functions.html#gaea903a29e21c0e159352a816c326fe72">Cy_WDT_SetLowerAction</a> (<a class="el" href="group__group__wdt__enums.html#gad825b14b5e132304da2877abc00d20ce">cy_en_wdt_lower_upper_action_t</a> action)</td></tr>
<tr class="memdesc:gaea903a29e21c0e159352a816c326fe72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set action taken if this watchdog is serviced before LOWER_LIMIT is reached.  <a href="#gaea903a29e21c0e159352a816c326fe72">More...</a><br /></td></tr>
<tr class="separator:gaea903a29e21c0e159352a816c326fe72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ede82be1107d76de2fd9fb1fd243915"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdt__functions.html#ga0ede82be1107d76de2fd9fb1fd243915">Cy_WDT_SetUpperAction</a> (<a class="el" href="group__group__wdt__enums.html#gad825b14b5e132304da2877abc00d20ce">cy_en_wdt_lower_upper_action_t</a> action)</td></tr>
<tr class="memdesc:ga0ede82be1107d76de2fd9fb1fd243915"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set action taken if this watchdog is not serviced before UPPER_LIMIT is reached.  <a href="#ga0ede82be1107d76de2fd9fb1fd243915">More...</a><br /></td></tr>
<tr class="separator:ga0ede82be1107d76de2fd9fb1fd243915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf86e75ba80f13612682449113e891c5e"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdt__functions.html#gaf86e75ba80f13612682449113e891c5e">Cy_WDT_SetWarnAction</a> (<a class="el" href="group__group__wdt__enums.html#ga81dab00f6381d41c0f7ed9765cf09d41">cy_en_wdt_warn_action_t</a> action)</td></tr>
<tr class="memdesc:gaf86e75ba80f13612682449113e891c5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set action taken when the count value reaches WARN_LIMIT.  <a href="#gaf86e75ba80f13612682449113e891c5e">More...</a><br /></td></tr>
<tr class="separator:gaf86e75ba80f13612682449113e891c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c8d2fa84afb395152979a6a033ac676"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdt__functions.html#ga0c8d2fa84afb395152979a6a033ac676">Cy_WDT_SetAutoService</a> (<a class="el" href="group__group__wdt__enums.html#gaf201333763681a3df52e02e745b3164a">cy_en_wdt_enable_t</a> enable)</td></tr>
<tr class="memdesc:ga0c8d2fa84afb395152979a6a033ac676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set automatically service when the count value reaches WARN_LIMIT.  <a href="#ga0c8d2fa84afb395152979a6a033ac676">More...</a><br /></td></tr>
<tr class="separator:ga0c8d2fa84afb395152979a6a033ac676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccb50fc9fcea1fd761ea74d1254e852e"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdt__functions.html#gaccb50fc9fcea1fd761ea74d1254e852e">Cy_WDT_SetDeepSleepPause</a> (<a class="el" href="group__group__wdt__enums.html#gaf201333763681a3df52e02e745b3164a">cy_en_wdt_enable_t</a> enable)</td></tr>
<tr class="memdesc:gaccb50fc9fcea1fd761ea74d1254e852e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether the WDT counter runs/pauses when the system is in DEEPSLEEP.  <a href="#gaccb50fc9fcea1fd761ea74d1254e852e">More...</a><br /></td></tr>
<tr class="separator:gaccb50fc9fcea1fd761ea74d1254e852e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa29c8fc8616e2340c7bb7560788b0616"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdt__functions.html#gaa29c8fc8616e2340c7bb7560788b0616">Cy_WDT_SetDebugRun</a> (<a class="el" href="group__group__wdt__enums.html#gaf201333763681a3df52e02e745b3164a">cy_en_wdt_enable_t</a> enable)</td></tr>
<tr class="memdesc:gaa29c8fc8616e2340c7bb7560788b0616"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the debug run value.  <a href="#gaa29c8fc8616e2340c7bb7560788b0616">More...</a><br /></td></tr>
<tr class="separator:gaa29c8fc8616e2340c7bb7560788b0616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44b0861b8d7b8553f84842da51e9c423"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdt__functions.html#ga44b0861b8d7b8553f84842da51e9c423">Cy_WDT_SetService</a> (void)</td></tr>
<tr class="memdesc:ga44b0861b8d7b8553f84842da51e9c423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set service of the watchdog.  <a href="#ga44b0861b8d7b8553f84842da51e9c423">More...</a><br /></td></tr>
<tr class="separator:ga44b0861b8d7b8553f84842da51e9c423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12073c183281ce947b965d060712aa7e"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdt__functions.html#ga12073c183281ce947b965d060712aa7e">Cy_WDT_SetCount</a> (uint32_t count)</td></tr>
<tr class="memdesc:ga12073c183281ce947b965d060712aa7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the WDT counter value.  <a href="#ga12073c183281ce947b965d060712aa7e">More...</a><br /></td></tr>
<tr class="separator:ga12073c183281ce947b965d060712aa7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9270f9edce62b929919ea835a5279e2a"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdt__functions.html#ga9270f9edce62b929919ea835a5279e2a">Cy_WDT_SetInterrupt</a> (void)</td></tr>
<tr class="memdesc:ga9270f9edce62b929919ea835a5279e2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Triggers an interrupt with software.  <a href="#ga9270f9edce62b929919ea835a5279e2a">More...</a><br /></td></tr>
<tr class="separator:ga9270f9edce62b929919ea835a5279e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaac6f64babfb1855f9ba8aecccc19ecb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac6f64babfb1855f9ba8aecccc19ecb4">&#9670;&nbsp;</a></span>Cy_WDT_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_WDT_Init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the Watchdog timer to its default state: </p>
<ul>
<li>WDT disabled</li>
<li>WDT match value is 4096</li>
<li>None of ignore bits are set: the whole WDT counter bits are checked against the match value.</li>
</ul>
<p>This function clears the WDT interrupt.</p>
<p>For PSOC4 HVMS/PA devices the given default setting of the WDT:</p><ul>
<li>The WDT is unlocked and disabled.</li>
<li>The WDT Lower Limit value is set to 0 and Lower action to None.</li>
<li>The WDT Warn Limit value is set to 0 and Warn action to None.</li>
<li>The WDT Upper Limit value is set to 32768 (~1 sec when clk_lf = 32KHz) and Upper action to Reset.</li>
<li>The WDT is locked again. </li>
</ul>

</div>
</div>
<a id="ga82aec7e454d05d03dfd1d6fd5e573d5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga82aec7e454d05d03dfd1d6fd5e573d5e">&#9670;&nbsp;</a></span>Cy_WDT_Enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_WDT_Enable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables watchdog timer reset generation. </p>
<dl class="section warning"><dt>Warning</dt><dd>For PSOC4 HVMS/PA the Watchdog timer should be unlocked before being enabled. Call the <a class="el" href="group__group__wdt__functions.html#ga0c4e41c9c1b0d575747d1a984e63a6b0">Cy_WDT_Unlock()</a> API to unlock the WDT.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>May take up to three <a class="el" href="group__group__sysclk__lf.html">Low-Frequency Clock</a> cycles to take effect. Do not enter DeepSleep if the WDT enabling doesn't take effect. It can be done by waiting until <a class="el" href="group__group__wdt__functions.html#ga05f8bb5603ce46caf842bd0ad254f604">Cy_WDT_IsEnabled()</a> returns true.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="keywordflow">if</span>(<span class="keyword">false</span> == <a class="code" href="group__group__wdt__functions.html#ga7d651ba3f26230b7bf18ca730d342450">Cy_WDT_Locked</a>())</div><div class="line">    {</div><div class="line">        <a class="code" href="group__group__wdt__functions.html#ga82aec7e454d05d03dfd1d6fd5e573d5e">Cy_WDT_Enable</a>();</div><div class="line">        <span class="keywordflow">while</span>(!<a class="code" href="group__group__wdt__functions.html#ga05f8bb5603ce46caf842bd0ad254f604">Cy_WDT_IsEnabled</a>())</div><div class="line">        {</div><div class="line">            <span class="comment">/* Do nothing. Wait until the WDT Enable takes effect.</span></div><div class="line"><span class="comment">            May take up to three clk_lf cycles to take effect. */</span></div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga05f8bb5603ce46caf842bd0ad254f604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05f8bb5603ce46caf842bd0ad254f604">&#9670;&nbsp;</a></span>Cy_WDT_IsEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool Cy_WDT_IsEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the WDT enable/disable state. </p>
<dl class="section return"><dt>Returns</dt><dd>The WDT state.<ul>
<li>true : Counter is enabled (counting up).</li>
<li>false : Counter is disabled (not clocked).</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="keywordflow">if</span>(<span class="keyword">false</span> == <a class="code" href="group__group__wdt__functions.html#ga7d651ba3f26230b7bf18ca730d342450">Cy_WDT_Locked</a>())</div><div class="line">    {</div><div class="line">        <a class="code" href="group__group__wdt__functions.html#ga82aec7e454d05d03dfd1d6fd5e573d5e">Cy_WDT_Enable</a>();</div><div class="line">        <span class="keywordflow">while</span>(!<a class="code" href="group__group__wdt__functions.html#ga05f8bb5603ce46caf842bd0ad254f604">Cy_WDT_IsEnabled</a>())</div><div class="line">        {</div><div class="line">            <span class="comment">/* Do nothing. Wait until the WDT Enable takes effect.</span></div><div class="line"><span class="comment">            May take up to three clk_lf cycles to take effect. */</span></div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga709f597d56e7f7fb6717d5ff671491fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga709f597d56e7f7fb6717d5ff671491fa">&#9670;&nbsp;</a></span>Cy_WDT_Disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_WDT_Disable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables the WDT reset generation. </p>
<dl class="section warning"><dt>Warning</dt><dd>For PSOC4 HVMS/PA the Watchdog timer should be unlocked before being disabled. Call the <a class="el" href="group__group__wdt__functions.html#ga0c4e41c9c1b0d575747d1a984e63a6b0">Cy_WDT_Unlock()</a> API to unlock the WDT.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>When disable the WDT, the counter is cleared.</dd>
<dd>
May take up to three <a class="el" href="group__group__sysclk__lf.html">Low-Frequency Clock</a> cycles to take effect. It can be done by waiting until <a class="el" href="group__group__wdt__functions.html#ga05f8bb5603ce46caf842bd0ad254f604">Cy_WDT_IsEnabled()</a> returns false.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="keywordflow">if</span>(!<a class="code" href="group__group__wdt__functions.html#ga7d651ba3f26230b7bf18ca730d342450">Cy_WDT_Locked</a>())</div><div class="line">    {</div><div class="line">        <a class="code" href="group__group__wdt__functions.html#ga709f597d56e7f7fb6717d5ff671491fa">Cy_WDT_Disable</a>();</div><div class="line">        <span class="keywordflow">while</span>(<a class="code" href="group__group__wdt__functions.html#ga05f8bb5603ce46caf842bd0ad254f604">Cy_WDT_IsEnabled</a>())</div><div class="line">        {</div><div class="line">            <span class="comment">/* Do nothing. Wait until the WDT Disable takes effect.</span></div><div class="line"><span class="comment">            May take up to three clk_lf cycles to take effect. */</span></div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga1e7105cb2482131f03140a223caf5cc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e7105cb2482131f03140a223caf5cc1">&#9670;&nbsp;</a></span>Cy_WDT_GetCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_WDT_GetCount </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the current WDT counter value. </p>
<dl class="section return"><dt>Returns</dt><dd>A live counter value. </dd></dl>

</div>
</div>
<a id="ga1e707a8236e6dcd90eede7e726a2648f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e707a8236e6dcd90eede7e726a2648f">&#9670;&nbsp;</a></span>Cy_WDT_SetMatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_WDT_SetMatch </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>match</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the WDT counter match comparison value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">match</td><td>The valid range is [0-65535]. The value to be used to match against the counter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Not applicable for PSOC4 HVMS/PA. </dd></dl>

</div>
</div>
<a id="ga77552627bbcbe8ded86f52b67f5f12b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77552627bbcbe8ded86f52b67f5f12b3">&#9670;&nbsp;</a></span>Cy_WDT_GetMatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_WDT_GetMatch </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the WDT counter match comparison value. </p>
<dl class="section return"><dt>Returns</dt><dd>The counter match value.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Not applicable for PSOC4 HVMS/PA. </dd></dl>

</div>
</div>
<a id="gafad1413ff11cfb3e3e2b5d9854dc793e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafad1413ff11cfb3e3e2b5d9854dc793e">&#9670;&nbsp;</a></span>Cy_WDT_SetIgnoreBits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_WDT_SetIgnoreBits </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bitsNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configures the number of the most significant bits of the Watchdog timer that are not checked against the match. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitsNum</td><td>The number of the most significant bits. The valid range is [0-15].</td></tr>
  </table>
  </dd>
</dl>
<p>The value of bitsNum controls the time-to-reset of the Watchdog timer. This happens after 3 successive matches.</p>
<dl class="section note"><dt>Note</dt><dd>Certain products may enforce a minimum value for this register through design time configuration.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function changes the WDT interrupt period, therefore the device can go into an infinite WDT reset loop. This may happen if a WDT reset occurs faster that a device start-up.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Not applicable for PSOC4 HVMS/PA. </dd></dl>

</div>
</div>
<a id="ga3ec661a60927ab0c15e654540f55c95b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ec661a60927ab0c15e654540f55c95b">&#9670;&nbsp;</a></span>Cy_WDT_GetIgnoreBits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_WDT_GetIgnoreBits </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the number of the most significant bits of the Watchdog timer that are not checked against the match. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of the most significant bits.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Not applicable for PSOC4 HVMS/PA. </dd></dl>

</div>
</div>
<a id="gab6caa17bf5bcb0c365f60e602e653fed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6caa17bf5bcb0c365f60e602e653fed">&#9670;&nbsp;</a></span>Cy_WDT_MaskInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_WDT_MaskInterrupt </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>After masking interrupts from the WDT, they are not passed to the CPU. </p>
<p>This function does not disable the WDT-reset generation. </p>

</div>
</div>
<a id="ga38c69c98675d6024a7d73acb41b24399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38c69c98675d6024a7d73acb41b24399">&#9670;&nbsp;</a></span>Cy_WDT_UnmaskInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_WDT_UnmaskInterrupt </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>After unmasking interrupts from the WDT, they are passed to CPU. </p>
<p>This function does not impact the reset generation. </p>

</div>
</div>
<a id="gad62ce7b3562cf1754659eed3fab0e22a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad62ce7b3562cf1754659eed3fab0e22a">&#9670;&nbsp;</a></span>Cy_WDT_GetInterruptStatusMasked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool Cy_WDT_GetInterruptStatusMasked </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an interrupt request register masked by an interrupt mask. </p>
<p>Returns the result of the bitwise AND operation between the corresponding interrupt request and mask bits.</p>
<dl class="section return"><dt>Returns</dt><dd>The masked interrupt status.<ul>
<li>true : Masked interrupt occurs.</li>
<li>false : No Masked interrupt occurs.</li>
</ul>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For PSOC4 HVMS/PA, due to internal synchronization, it takes up to 8 SYSCLK cycles to read from this register and during this time AHB bus is stalled. </dd></dl>

</div>
</div>
<a id="ga8a86bbc9823552318191ea6c153e99fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a86bbc9823552318191ea6c153e99fa">&#9670;&nbsp;</a></span>Cy_WDT_ClearWatchdog()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_WDT_ClearWatchdog </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears ("feeds") the watchdog, to prevent a XRES device reset. </p>
<p>This function simply call <a class="el" href="group__group__wdt__functions.html#ga727d9ae6fdba36809bf631985a3eb987">Cy_WDT_ClearInterrupt()</a> function. </p>

</div>
</div>
<a id="ga5a0d9b4d5c6454af7213b32c4db7671c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a0d9b4d5c6454af7213b32c4db7671c">&#9670;&nbsp;</a></span>Cy_WDT_Lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_WDT_Lock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locks out configuration changes to the Watchdog Timer register. </p>
<p>After this function is called, the WDT configuration cannot be changed until <a class="el" href="group__group__wdt__functions.html#ga0c4e41c9c1b0d575747d1a984e63a6b0">Cy_WDT_Unlock()</a> is called.</p>
<dl class="section warning"><dt>Warning</dt><dd>The WDT lock state is not retained during system Deep Sleep. After the wakeup from system Deep Sleep the WDT is locked.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Applicable to PSOC4 HVMS/PA only.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="keywordflow">if</span>(!<a class="code" href="group__group__wdt__functions.html#ga7d651ba3f26230b7bf18ca730d342450">Cy_WDT_Locked</a>())</div><div class="line">    {</div><div class="line">        <a class="code" href="group__group__wdt__functions.html#ga5a0d9b4d5c6454af7213b32c4db7671c">Cy_WDT_Lock</a>();</div><div class="line">    }</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga0c4e41c9c1b0d575747d1a984e63a6b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c4e41c9c1b0d575747d1a984e63a6b0">&#9670;&nbsp;</a></span>Cy_WDT_Unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_WDT_Unlock </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlocks the Watchdog Timer configuration register. </p>
<p>The Watchdog timer should be unlocked before:</p><ul>
<li>ILO being enabled/disabled</li>
<li>PILO being enabled/disabled</li>
<li>the LFCLK source being changed</li>
<li>WDT being reconfigured</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>The WDT lock state is not retained during system Deep Sleep. After the wakeup from system Deep Sleep the WDT is locked.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Applicable to PSOC4 HVMS/PA only.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="group__group__wdt__functions.html#ga7d651ba3f26230b7bf18ca730d342450">Cy_WDT_Locked</a>())</div><div class="line">    {</div><div class="line">        <a class="code" href="group__group__wdt__functions.html#ga0c4e41c9c1b0d575747d1a984e63a6b0">Cy_WDT_Unlock</a>();</div><div class="line">    }</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga7d651ba3f26230b7bf18ca730d342450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d651ba3f26230b7bf18ca730d342450">&#9670;&nbsp;</a></span>Cy_WDT_Locked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool Cy_WDT_Locked </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the WDT lock state. </p>
<dl class="section return"><dt>Returns</dt><dd>The WDT lock state.<ul>
<li>true : if WDT is locked.</li>
<li>false : if WDT is unlocked.</li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The WDT lock state is not retained during system Deep Sleep. After the wakeup from system Deep Sleep the WDT is locked.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Applicable to PSOC4 HVMS/PA only.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="group__group__wdt__functions.html#ga7d651ba3f26230b7bf18ca730d342450">Cy_WDT_Locked</a>())</div><div class="line">    {</div><div class="line">        <a class="code" href="group__group__wdt__functions.html#ga0c4e41c9c1b0d575747d1a984e63a6b0">Cy_WDT_Unlock</a>();</div><div class="line">    }</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="gac3068b5f898aaecbb16a7e747eb2ac6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3068b5f898aaecbb16a7e747eb2ac6a">&#9670;&nbsp;</a></span>Cy_WDT_SetLowerLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_WDT_SetLowerLimit </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>match</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set lower limit for watchdog. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">match</td><td>- Value to be matched</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Applicable to PSOC4 HVMS/PA only.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The Watchdog timer should be unlocked and disabled before being configured. Call the <a class="el" href="group__group__wdt__functions.html#ga0c4e41c9c1b0d575747d1a984e63a6b0">Cy_WDT_Unlock()</a> API to unlock the WDT.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><a class="el" href="group__group__wdt.html#group_wdt_section_use_case_3_srsshv">Use case 3. The WDT counter in interrupt mode.</a> </dd></dl>

</div>
</div>
<a id="ga370b6a151be8d6a9facd471589c9dd5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga370b6a151be8d6a9facd471589c9dd5a">&#9670;&nbsp;</a></span>Cy_WDT_SetUpperLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_WDT_SetUpperLimit </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>match</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set upper limit for watchdog. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">match</td><td>- Value to be matched</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Applicable to PSOC4 HVMS/PA only.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The Watchdog timer should be unlocked and disabled before being configured. Call the <a class="el" href="group__group__wdt__functions.html#ga0c4e41c9c1b0d575747d1a984e63a6b0">Cy_WDT_Unlock()</a> API to unlock the WDT.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><a class="el" href="group__group__wdt.html#group_wdt_section_use_case_3_srsshv">Use case 3. The WDT counter in interrupt mode.</a> </dd></dl>

</div>
</div>
<a id="gaa398184eb16a3a080d4e96c32641c0e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa398184eb16a3a080d4e96c32641c0e8">&#9670;&nbsp;</a></span>Cy_WDT_SetWarnLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_WDT_SetWarnLimit </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>match</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set warn limit for watchdog. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">match</td><td>- Value to be matched</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Applicable to PSOC4 HVMS/PA only.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The Watchdog timer should be unlocked and disabled before being configured. Call the <a class="el" href="group__group__wdt__functions.html#ga0c4e41c9c1b0d575747d1a984e63a6b0">Cy_WDT_Unlock()</a> API to unlock the WDT.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><a class="el" href="group__group__wdt.html#group_wdt_section_use_case_3_srsshv">Use case 3. The WDT counter in interrupt mode.</a> </dd></dl>

</div>
</div>
<a id="gaea903a29e21c0e159352a816c326fe72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea903a29e21c0e159352a816c326fe72">&#9670;&nbsp;</a></span>Cy_WDT_SetLowerAction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_WDT_SetLowerAction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__wdt__enums.html#gad825b14b5e132304da2877abc00d20ce">cy_en_wdt_lower_upper_action_t</a>&#160;</td>
          <td class="paramname"><em>action</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set action taken if this watchdog is serviced before LOWER_LIMIT is reached. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">action</td><td><a class="el" href="group__group__wdt__enums.html#gad825b14b5e132304da2877abc00d20ce">cy_en_wdt_lower_upper_action_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Applicable to PSOC4 HVMS/PA only.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The Watchdog timer should be unlocked and disabled before being configured. Call the <a class="el" href="group__group__wdt__functions.html#ga0c4e41c9c1b0d575747d1a984e63a6b0">Cy_WDT_Unlock()</a> API to unlock the WDT.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><a class="el" href="group__group__wdt.html#group_wdt_section_use_case_3_srsshv">Use case 3. The WDT counter in interrupt mode.</a> </dd></dl>

</div>
</div>
<a id="ga0ede82be1107d76de2fd9fb1fd243915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ede82be1107d76de2fd9fb1fd243915">&#9670;&nbsp;</a></span>Cy_WDT_SetUpperAction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_WDT_SetUpperAction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__wdt__enums.html#gad825b14b5e132304da2877abc00d20ce">cy_en_wdt_lower_upper_action_t</a>&#160;</td>
          <td class="paramname"><em>action</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set action taken if this watchdog is not serviced before UPPER_LIMIT is reached. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">action</td><td><a class="el" href="group__group__wdt__enums.html#gad825b14b5e132304da2877abc00d20ce">cy_en_wdt_lower_upper_action_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Applicable to PSOC4 HVMS/PA only.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The Watchdog timer should be unlocked and disabled before being configured. Call the <a class="el" href="group__group__wdt__functions.html#ga0c4e41c9c1b0d575747d1a984e63a6b0">Cy_WDT_Unlock()</a> API to unlock the WDT.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><a class="el" href="group__group__wdt.html#group_wdt_section_use_case_3_srsshv">Use case 3. The WDT counter in interrupt mode.</a> </dd></dl>

</div>
</div>
<a id="gaf86e75ba80f13612682449113e891c5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf86e75ba80f13612682449113e891c5e">&#9670;&nbsp;</a></span>Cy_WDT_SetWarnAction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_WDT_SetWarnAction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__wdt__enums.html#ga81dab00f6381d41c0f7ed9765cf09d41">cy_en_wdt_warn_action_t</a>&#160;</td>
          <td class="paramname"><em>action</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set action taken when the count value reaches WARN_LIMIT. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">action</td><td><a class="el" href="group__group__wdt__enums.html#ga81dab00f6381d41c0f7ed9765cf09d41">cy_en_wdt_warn_action_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Applicable to PSOC4 HVMS/PA only.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The Watchdog timer should be unlocked and disabled before being configured. Call the <a class="el" href="group__group__wdt__functions.html#ga0c4e41c9c1b0d575747d1a984e63a6b0">Cy_WDT_Unlock()</a> API to unlock the WDT.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><a class="el" href="group__group__wdt.html#group_wdt_section_use_case_3_srsshv">Use case 3. The WDT counter in interrupt mode.</a> </dd></dl>

</div>
</div>
<a id="ga0c8d2fa84afb395152979a6a033ac676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c8d2fa84afb395152979a6a033ac676">&#9670;&nbsp;</a></span>Cy_WDT_SetAutoService()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_WDT_SetAutoService </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__wdt__enums.html#gaf201333763681a3df52e02e745b3164a">cy_en_wdt_enable_t</a>&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set automatically service when the count value reaches WARN_LIMIT. </p>
<p>This function is used for WARN_LIMIT. This allows creation of a periodic interrupt if this counter is not needed as a watchdog. This configuration is ignored when LOWER_ACTION or when UPPER_ACTION is set to trigger a reset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td><a class="el" href="group__group__wdt__enums.html#gaf201333763681a3df52e02e745b3164a">cy_en_wdt_enable_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Applicable to PSOC4 HVMS/PA only.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The Watchdog timer should be unlocked and disabled before being configured. Call the <a class="el" href="group__group__wdt__functions.html#ga0c4e41c9c1b0d575747d1a984e63a6b0">Cy_WDT_Unlock()</a> API to unlock the WDT.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><a class="el" href="group__group__wdt.html#group_wdt_section_use_case_3_srsshv">Use case 3. The WDT counter in interrupt mode.</a> </dd></dl>

</div>
</div>
<a id="gaccb50fc9fcea1fd761ea74d1254e852e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaccb50fc9fcea1fd761ea74d1254e852e">&#9670;&nbsp;</a></span>Cy_WDT_SetDeepSleepPause()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_WDT_SetDeepSleepPause </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__wdt__enums.html#gaf201333763681a3df52e02e745b3164a">cy_en_wdt_enable_t</a>&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set whether the WDT counter runs/pauses when the system is in DEEPSLEEP. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td><a class="el" href="group__group__wdt__enums.html#gaf201333763681a3df52e02e745b3164a">cy_en_wdt_enable_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Applicable to PSOC4 HVMS/PA only.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The Watchdog timer should be unlocked and disabled before being configured. Call the <a class="el" href="group__group__wdt__functions.html#ga0c4e41c9c1b0d575747d1a984e63a6b0">Cy_WDT_Unlock()</a> API to unlock the WDT. </dd></dl>

</div>
</div>
<a id="gaa29c8fc8616e2340c7bb7560788b0616"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa29c8fc8616e2340c7bb7560788b0616">&#9670;&nbsp;</a></span>Cy_WDT_SetDebugRun()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_WDT_SetDebugRun </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__group__wdt__enums.html#gaf201333763681a3df52e02e745b3164a">cy_en_wdt_enable_t</a>&#160;</td>
          <td class="paramname"><em>enable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the debug run value. </p>
<p>It needs when using debugger.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td><a class="el" href="group__group__wdt__enums.html#gaf201333763681a3df52e02e745b3164a">cy_en_wdt_enable_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Applicable to PSOC4 HVMS/PA only.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The Watchdog timer should be unlocked and disabled before being configured. Call the <a class="el" href="group__group__wdt__functions.html#ga0c4e41c9c1b0d575747d1a984e63a6b0">Cy_WDT_Unlock()</a> API to unlock the WDT. </dd></dl>

</div>
</div>
<a id="ga44b0861b8d7b8553f84842da51e9c423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44b0861b8d7b8553f84842da51e9c423">&#9670;&nbsp;</a></span>Cy_WDT_SetService()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_WDT_SetService </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set service of the watchdog. </p>
<p>This resets the count value to zero. If WDT is disabled, service will not trigger a LOWER_ACTION and will not clear a preloaded count value.</p>
<dl class="section note"><dt>Note</dt><dd>Applicable to PSOC4 HVMS/PA only.</dd>
<dd>
May take up to three <a class="el" href="group__group__sysclk__lf.html">Low-Frequency Clock</a> cycles to take effect.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The Watchdog timer should be unlocked and disabled before being configured. Call the <a class="el" href="group__group__wdt__functions.html#ga0c4e41c9c1b0d575747d1a984e63a6b0">Cy_WDT_Unlock()</a> API to unlock the WDT. </dd></dl>

</div>
</div>
<a id="ga12073c183281ce947b965d060712aa7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga12073c183281ce947b965d060712aa7e">&#9670;&nbsp;</a></span>Cy_WDT_SetCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_WDT_SetCount </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the WDT counter value. </p>
<p>When WDT is disabled and unlocked, the count value can be written for verification and debugging purposes. Software writes are always ignored when the WDT is enabled. Set the WDT counter value may lag the actual count value by up to one <a class="el" href="group__group__sysclk__lf.html">Low-Frequency Clock</a> cycle, due to internal synchronization.</p>
<dl class="section note"><dt>Note</dt><dd>Applicable to PSOC4 HVMS/PA only.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The Watchdog timer should be unlocked and disabled before being configured. Call the <a class="el" href="group__group__wdt__functions.html#ga0c4e41c9c1b0d575747d1a984e63a6b0">Cy_WDT_Unlock()</a> API to unlock the WDT. </dd></dl>

</div>
</div>
<a id="ga9270f9edce62b929919ea835a5279e2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9270f9edce62b929919ea835a5279e2a">&#9670;&nbsp;</a></span>Cy_WDT_SetInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_WDT_SetInterrupt </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Triggers an interrupt with software. </p>
<p>Can be used to set interrupts for firmware testing.</p>
<dl class="section note"><dt>Note</dt><dd>Applicable to PSOC4 HVMS/PA only.</dd>
<dd>
Due to internal synchronization, it takes up to 8 <a class="el" href="group__group__sysclk__clk__sys.html">System Clock</a> cycles to update after a W1S or reading from this register and during this time AHB bus is stalled. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>CAT2 Peripheral Driver Library</b> by <b>Infineon Technologies</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
