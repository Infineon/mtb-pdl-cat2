<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CAT2 Peripheral Driver Library: SRAM Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CAT2 Peripheral Driver Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__isouart__sram__functions.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">SRAM Functions<div class="ingroups"><a class="el" href="group__group__isouart.html">IsoUART      (Isolated UART)</a> &raquo; <a class="el" href="group__group__isouart__functions.html">Functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga974d4b0dfad2b098161c85843c733436"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__isouart__sram__functions.html#ga974d4b0dfad2b098161c85843c733436">Cy_ISOUART_NodeConfigSramRowAttr</a> (ISOUART_Type *base, uint32_t index, uint8_t trigIntId, bool isInvalid, bool isReadOnly)</td></tr>
<tr class="memdesc:ga974d4b0dfad2b098161c85843c733436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure iso UART SRAM attributes.  <a href="#ga974d4b0dfad2b098161c85843c733436">More...</a><br /></td></tr>
<tr class="separator:ga974d4b0dfad2b098161c85843c733436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13bf7ea2057d2b4290455ba10310fe1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__isouart__sram__functions.html#ga13bf7ea2057d2b4290455ba10310fe1f">Cy_ISOUART_HostSetSramSize</a> (ISOUART_Type *base, uint32_t lowSramSize, uint32_t highSramSize)</td></tr>
<tr class="memdesc:ga13bf7ea2057d2b4290455ba10310fe1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set SRAM size for data reception.  <a href="#ga13bf7ea2057d2b4290455ba10310fe1f">More...</a><br /></td></tr>
<tr class="separator:ga13bf7ea2057d2b4290455ba10310fe1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga447f68ca071d0ac67340937f63a999a8"><td class="memItemLeft" align="right" valign="top">volatile uint32_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__isouart__sram__functions.html#ga447f68ca071d0ac67340937f63a999a8">Cy_ISOUART_HostGetSramBaseAddr</a> (ISOUART_Type *base, <a class="el" href="group__group__isouart__enums.html#gacf2d3e5d86ed1ad3bb584ef929f93fae">cy_en_isouart_interface_side_t</a> iSide)</td></tr>
<tr class="memdesc:ga447f68ca071d0ac67340937f63a999a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get iso UART SRAM base address of the specified interface.  <a href="#ga447f68ca071d0ac67340937f63a999a8">More...</a><br /></td></tr>
<tr class="separator:ga447f68ca071d0ac67340937f63a999a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61f5b2480294e583304a7db5dca360e4"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__isouart__sram__functions.html#ga61f5b2480294e583304a7db5dca360e4">Cy_ISOUART_ReadSramRow16</a> (ISOUART_Type *base, uint32_t index)</td></tr>
<tr class="memdesc:ga61f5b2480294e583304a7db5dca360e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a 16-bit data field from the specified iso UART SRAM row.  <a href="#ga61f5b2480294e583304a7db5dca360e4">More...</a><br /></td></tr>
<tr class="separator:ga61f5b2480294e583304a7db5dca360e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d906793c82b584f3463c2f5b676ad75"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__isouart__sram__functions.html#ga3d906793c82b584f3463c2f5b676ad75">Cy_ISOUART_ReadSramRow32</a> (ISOUART_Type *base, uint32_t index)</td></tr>
<tr class="memdesc:ga3d906793c82b584f3463c2f5b676ad75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a 32-bit data from two consecutive iso UART SRAM rows.  <a href="#ga3d906793c82b584f3463c2f5b676ad75">More...</a><br /></td></tr>
<tr class="separator:ga3d906793c82b584f3463c2f5b676ad75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3eb90840cd167295ba76551ae2e82c18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__isouart__sram__functions.html#ga3eb90840cd167295ba76551ae2e82c18">Cy_ISOUART_WriteSramRow16</a> (ISOUART_Type *base, uint32_t index, uint16_t data)</td></tr>
<tr class="memdesc:ga3eb90840cd167295ba76551ae2e82c18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a 16-bit value to the data field of the specified iso UART SRAM row.  <a href="#ga3eb90840cd167295ba76551ae2e82c18">More...</a><br /></td></tr>
<tr class="separator:ga3eb90840cd167295ba76551ae2e82c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafad1ea423899b8fc450fd00a72041c9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__isouart__sram__functions.html#gafad1ea423899b8fc450fd00a72041c9b">Cy_ISOUART_WriteSramRow32</a> (ISOUART_Type *base, uint32_t index, uint32_t data)</td></tr>
<tr class="memdesc:gafad1ea423899b8fc450fd00a72041c9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a 32-bit data to two consecutive iso UART SRAM rows.  <a href="#gafad1ea423899b8fc450fd00a72041c9b">More...</a><br /></td></tr>
<tr class="separator:gafad1ea423899b8fc450fd00a72041c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1ce26fcb50542c344c2e3fab7c6281c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__isouart__sram__functions.html#gab1ce26fcb50542c344c2e3fab7c6281c">Cy_ISOUART_HostReadSramRaw</a> (ISOUART_Type *base, <a class="el" href="group__group__isouart__enums.html#gacf2d3e5d86ed1ad3bb584ef929f93fae">cy_en_isouart_interface_side_t</a> iSide, uint32_t packetNum, <a class="el" href="structcy__stc__isouart__raw__frame__t.html">cy_stc_isouart_raw_frame_t</a> *frame)</td></tr>
<tr class="memdesc:gab1ce26fcb50542c344c2e3fab7c6281c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads RAW data frames from the iso UART SRAM of specified interface.  <a href="#gab1ce26fcb50542c344c2e3fab7c6281c">More...</a><br /></td></tr>
<tr class="separator:gab1ce26fcb50542c344c2e3fab7c6281c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2c475bbf77332590cfdf723ab6ceb22"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__isouart__sram__functions.html#gae2c475bbf77332590cfdf723ab6ceb22">Cy_ISOUART_HostReadSramUnpack</a> (ISOUART_Type *base, <a class="el" href="group__group__isouart__enums.html#gacf2d3e5d86ed1ad3bb584ef929f93fae">cy_en_isouart_interface_side_t</a> iSide, uint32_t packetNum)</td></tr>
<tr class="memdesc:gae2c475bbf77332590cfdf723ab6ceb22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads UNPACKED data from the iso UART SRAM of specified interface.  <a href="#gae2c475bbf77332590cfdf723ab6ceb22">More...</a><br /></td></tr>
<tr class="separator:gae2c475bbf77332590cfdf723ab6ceb22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92ae566e03aa083139bf2c94e08ad377"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__isouart__sram__functions.html#ga92ae566e03aa083139bf2c94e08ad377">Cy_ISOUART_EnableEcc</a> (ISOUART_Type *base)</td></tr>
<tr class="memdesc:ga92ae566e03aa083139bf2c94e08ad377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable ECC for iso UART SRAM.  <a href="#ga92ae566e03aa083139bf2c94e08ad377">More...</a><br /></td></tr>
<tr class="separator:ga92ae566e03aa083139bf2c94e08ad377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacafc4846bc62dc6f83f6f898cbfe268d"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__isouart__sram__functions.html#gacafc4846bc62dc6f83f6f898cbfe268d">Cy_ISOUART_DisableEcc</a> (ISOUART_Type *base)</td></tr>
<tr class="memdesc:gacafc4846bc62dc6f83f6f898cbfe268d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable ECC for iso UART SRAM.  <a href="#gacafc4846bc62dc6f83f6f898cbfe268d">More...</a><br /></td></tr>
<tr class="separator:gacafc4846bc62dc6f83f6f898cbfe268d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e139dbdbfc6aa31574e17c689ce2e00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__isouart__sram__functions.html#ga3e139dbdbfc6aa31574e17c689ce2e00">Cy_ISOUART_EnableEccInjection</a> (ISOUART_Type *base, uint32_t index, uint32_t parity)</td></tr>
<tr class="memdesc:ga3e139dbdbfc6aa31574e17c689ce2e00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable ECC error injection for iso UART SRAM.  <a href="#ga3e139dbdbfc6aa31574e17c689ce2e00">More...</a><br /></td></tr>
<tr class="separator:ga3e139dbdbfc6aa31574e17c689ce2e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b60c0869abff9fd6d584bc23c8e3e46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__isouart__sram__functions.html#ga6b60c0869abff9fd6d584bc23c8e3e46">Cy_ISOUART_DisableEccInjection</a> (ISOUART_Type *base)</td></tr>
<tr class="memdesc:ga6b60c0869abff9fd6d584bc23c8e3e46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable ECC error injection for iso UART SRAM.  <a href="#ga6b60c0869abff9fd6d584bc23c8e3e46">More...</a><br /></td></tr>
<tr class="separator:ga6b60c0869abff9fd6d584bc23c8e3e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5288e3b523c43e80fea3d3640a659f58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__isouart__sram__functions.html#ga5288e3b523c43e80fea3d3640a659f58">Cy_ISOUART_GetEccStatus</a> (const ISOUART_Type *base, <a class="el" href="structcy__stc__isouart__ecc__status__t.html">cy_stc_isouart_ecc_status_t</a> *status)</td></tr>
<tr class="memdesc:ga5288e3b523c43e80fea3d3640a659f58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ECC status of iso UART SRAM.  <a href="#ga5288e3b523c43e80fea3d3640a659f58">More...</a><br /></td></tr>
<tr class="separator:ga5288e3b523c43e80fea3d3640a659f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga974d4b0dfad2b098161c85843c733436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga974d4b0dfad2b098161c85843c733436">&#9670;&nbsp;</a></span>Cy_ISOUART_NodeConfigSramRowAttr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_ISOUART_NodeConfigSramRowAttr </td>
          <td>(</td>
          <td class="paramtype">ISOUART_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>trigIntId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isInvalid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isReadOnly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure iso UART SRAM attributes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base address for the iso UART. </td></tr>
    <tr><td class="paramname">index</td><td>Index of iso UART SRAM row. The valid range is 0...127. </td></tr>
    <tr><td class="paramname">trigIntId</td><td>ID of trigger and interrupt struct to be tied to this SRAM row. The valid range is 0...17. </td></tr>
    <tr><td class="paramname">isInvalid</td><td>Specifies whether the row is invalid or not. If TRUE, the specified index is marked as invalid. Any access to the invalid row by the host via iso UART will be reported as address error. </td></tr>
    <tr><td class="paramname">isReadOnly</td><td>Specifies whether the row is read only or not. If TRUE, the specified index is marked as read only. A write access to the read only row by the host via iso UART will be reported as access error. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is valid for Node. <br />
As an exception, this function may also be used by a Host configured in internal loopback mode to simulate Node behavior for testing purposes. </dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: Configure the iso UART Node interrupt trigger structure and SRAM row attributes.</span></div><div class="line"><span class="comment">     * This setup enables Primary Access interrupt on write operations to SRAM address 0.</span></div><div class="line"><span class="comment">     * The interrupt handler (IntrHandler) will process the triggered interrupt.</span></div><div class="line"><span class="comment">     */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Use trigger structure ID 1 to configure */</span></div><div class="line">    <span class="keyword">const</span> uint8_t intrTrigStructId = 1U;</div><div class="line"></div><div class="line">    <span class="comment">/* Configure interrupt trigger structure */</span></div><div class="line">    <a class="code" href="group__group__isouart__node__functions.html#gaedd07fc6dee98285aae07c5369e454bd">Cy_ISOUART_NodeConfigTriggerInt</a>(ISOUART,</div><div class="line">                                intrTrigStructId,          <span class="comment">/* Trigger structure ID */</span></div><div class="line">                                <a class="code" href="group__group__isouart__enums.html#ggaf8903b939cf9627b4f0ecc3710911830af9eed768db9b0a056c92d1d866c04dee">CY_ISOUART_EVENT_NONE</a>,     <span class="comment">/* Trigger source */</span></div><div class="line">                                <a class="code" href="group__group__isouart__enums.html#ggaf8903b939cf9627b4f0ecc3710911830ae0be52d935dc408264f723486a492699">CY_ISOUART_EVENT_WRITE</a>,    <span class="comment">/* Primary interrupt source */</span></div><div class="line">                                <a class="code" href="group__group__isouart__enums.html#ggaf8903b939cf9627b4f0ecc3710911830af9eed768db9b0a056c92d1d866c04dee">CY_ISOUART_EVENT_NONE</a>);    <span class="comment">/* Secondary interrupt source */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Configure SRAM row attributes for address 0 */</span></div><div class="line">    <a class="code" href="group__group__isouart__sram__functions.html#ga974d4b0dfad2b098161c85843c733436">Cy_ISOUART_NodeConfigSramRowAttr</a>(ISOUART,</div><div class="line">                                    SRAM_ADDRESS,       <span class="comment">/* SRAM address */</span></div><div class="line">                                    intrTrigStructId,   <span class="comment">/* Trigger structure ID */</span></div><div class="line">                                    <span class="keyword">false</span>,              <span class="comment">/* Invalid address disabled */</span></div><div class="line">                                    <span class="keyword">false</span>);             <span class="comment">/* Read protection disabled */</span></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga13bf7ea2057d2b4290455ba10310fe1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13bf7ea2057d2b4290455ba10310fe1f">&#9670;&nbsp;</a></span>Cy_ISOUART_HostSetSramSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_ISOUART_HostSetSramSize </td>
          <td>(</td>
          <td class="paramtype">ISOUART_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>lowSramSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>highSramSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set SRAM size for data reception. </p>
<p>The required SRAM size depends on the read command types (read, broadcast read, multi read). This function is intended to be used for re-allocating SRAM size suitable for the read command being sent. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base address for the iso UART. </td></tr>
    <tr><td class="paramname">lowSramSize</td><td>SRAM size in low side. The valid range is 0..127. In RAW mode, this parameter must be divisible by 3. </td></tr>
    <tr><td class="paramname">highSramSize</td><td>SRAM size in high side. The valid range is 0..127. In RAW mode, this parameter must be divisible by 3. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is valid only for Host. The sum of lowSramSize and highSramSize must not exceed total SRAM size. The SRAM size shall only be changed when iso UART is disabled or both interfaces are in Slave mode. </dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: Perform read operation from specific node in Master-on-Top topology.</span></div><div class="line"><span class="comment">     * This demonstrates SRAM size configuration, reading data from node, and unpacked data retrieval.</span></div><div class="line"><span class="comment">     * This example uses polling to wait for command completion instead of interrupt-driven approach.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">const</span> uint32_t address = 0UL;   <span class="comment">/* SRAM address to read from. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Disable iso UART block. */</span></div><div class="line">    <a class="code" href="group__group__isouart__common__functions.html#gab90f55e8aeabb059fdc6f1d90884d3b2">Cy_ISOUART_Disable</a>(ISOUART);</div><div class="line"></div><div class="line">    <span class="comment">/* For the proper handling, set the interface SRAM size to the expected size by the transaction.</span></div><div class="line"><span class="comment">     * NOTE: The SRAM size shall only be changed when iso UART is disabled or both interfaces are in Slave mode.</span></div><div class="line"><span class="comment">     * e.g. for unpack mode, normal read command = 1</span></div><div class="line"><span class="comment">     * e.g. for raw mode, normal read command = 3</span></div><div class="line"><span class="comment">     * e.g. for unpack mode, multi read command = 1 x number of multi read</span></div><div class="line"><span class="comment">     * e.g. for unpack mode, BC read command = 1 x number of nodes in the chain</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <a class="code" href="group__group__isouart__sram__functions.html#ga13bf7ea2057d2b4290455ba10310fe1f">Cy_ISOUART_HostSetSramSize</a>(ISOUART, 1UL, 0UL); <span class="comment">/* Set the Low side 1 row, High side 0 row. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Enable iso UART to operate. */</span></div><div class="line">    <a class="code" href="group__group__isouart__common__functions.html#gadf7a574beb29a2411f540cf8356f6c16">Cy_ISOUART_Enable</a>(ISOUART);</div><div class="line"></div><div class="line">    <span class="comment">/* Perform Read operation. */</span></div><div class="line">    <a class="code" href="group__group__isouart__host__functions.html#ga1ca934c5454237de73583ef5a9ad919f">Cy_ISOUART_HostSendReadCommand</a>(ISOUART, blockId, nodeId, address);</div><div class="line">    <span class="comment">/* Wait for Read command completion by polling SRAM_FULL interrupt status</span></div><div class="line"><span class="comment">     * (interface side depends on topology) instead of using interrupt service routine.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    uint32_t intrStatus = 0UL;</div><div class="line">    <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">        intrStatus = <a class="code" href="group__group__isouart__interrupt__functions.html#gaa27998c25657a4a8c5225d995d2044cc">Cy_ISOUART_GetInterruptStatus</a>(ISOUART);</div><div class="line">    } <span class="keywordflow">while</span> (0UL == (intrStatus &amp; CY_ISOUART_INTR_MASTER_LOW_SRAM_FULL));</div><div class="line"></div><div class="line">    <span class="comment">/* Clear interrupt flags. */</span></div><div class="line">    <a class="code" href="group__group__isouart__interrupt__functions.html#ga59a17f6508ba472e5626b8082da1ab04">Cy_ISOUART_ClearInterrupt</a>(ISOUART, intrStatus);</div><div class="line"></div><div class="line">    <span class="comment">/* Read data from low interface SRAM. */</span></div><div class="line">    uint16_t readData = <a class="code" href="group__group__isouart__sram__functions.html#gae2c475bbf77332590cfdf723ab6ceb22">Cy_ISOUART_HostReadSramUnpack</a>(ISOUART, <a class="code" href="group__group__isouart__enums.html#ggacf2d3e5d86ed1ad3bb584ef929f93faeab383854c267880dc0fd76cac0bb8e574">CY_ISOUART_IF_LOW</a>, 0UL);</div><div class="line">    <span class="comment">/* Process the read data */</span></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga447f68ca071d0ac67340937f63a999a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga447f68ca071d0ac67340937f63a999a8">&#9670;&nbsp;</a></span>Cy_ISOUART_HostGetSramBaseAddr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">volatile uint32_t* Cy_ISOUART_HostGetSramBaseAddr </td>
          <td>(</td>
          <td class="paramtype">ISOUART_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__isouart__enums.html#gacf2d3e5d86ed1ad3bb584ef929f93fae">cy_en_isouart_interface_side_t</a>&#160;</td>
          <td class="paramname"><em>iSide</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get iso UART SRAM base address of the specified interface. </p>
<p>This is a helper function for combination with DMA. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base address for the iso UART. </td></tr>
    <tr><td class="paramname">iSide</td><td>Interface side. See <a class="el" href="group__group__isouart__enums.html#gacf2d3e5d86ed1ad3bb584ef929f93fae">cy_en_isouart_interface_side_t</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the start address of the iso UART SRAM for the specified interface side. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is valid only for Host. </dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: Get SRAM base address for the required interface to configure DMA transfers.</span></div><div class="line"><span class="comment">    * This API provides the starting address of SRAM for specified interface (High or Low)</span></div><div class="line"><span class="comment">    * which can be used as source or destination address in DMA descriptors.</span></div><div class="line"><span class="comment">    */</span></div><div class="line"><span class="preprocessor">    #define CHANN_NUM   (0UL)</span></div><div class="line"></div><div class="line">    <span class="comment">/* Get SRAM base address for Low interface */</span></div><div class="line">    <span class="keyword">volatile</span> uint32_t *sramBaseAddr = <a class="code" href="group__group__isouart__sram__functions.html#ga447f68ca071d0ac67340937f63a999a8">Cy_ISOUART_HostGetSramBaseAddr</a>(ISOUART, <a class="code" href="group__group__isouart__enums.html#ggacf2d3e5d86ed1ad3bb584ef929f93faeab383854c267880dc0fd76cac0bb8e574">CY_ISOUART_IF_LOW</a>);</div><div class="line"></div><div class="line">    <span class="comment">/* Configure DMA descriptor with obtained SRAM base address */</span></div><div class="line">    <a class="code" href="group__group__dmac__descriptor__functions.html#ga2c3b3f9e0ae139756b41a3f9b37c11d7">Cy_DMAC_Descriptor_SetSrcAddress</a>(DMAC, CHANN_NUM, <a class="code" href="group__group__dmac__enums.html#ggae6e4f76b1b081feaafa58b3d4d275136aefde4bfe79935c460a35d261c85fd07b">CY_DMAC_DESCRIPTOR_PING</a>, sramBaseAddr);</div><div class="line"></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga61f5b2480294e583304a7db5dca360e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga61f5b2480294e583304a7db5dca360e4">&#9670;&nbsp;</a></span>Cy_ISOUART_ReadSramRow16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t Cy_ISOUART_ReadSramRow16 </td>
          <td>(</td>
          <td class="paramtype">ISOUART_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a 16-bit data field from the specified iso UART SRAM row. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base address for the iso UART. </td></tr>
    <tr><td class="paramname">index</td><td>Index of iso UART SRAM row. The valid range is 0...127. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>16-bit value read from the iso UART SRAM row. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is valid for both Host and Node. </dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"><span class="comment">/* Scenario: Handle iso UART Node interrupts including Wake-up and Primary Access events.</span></div><div class="line"><span class="comment"> * This handler processes write operations to SRAM address 0 and wakeup signals from Host.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keywordtype">void</span> IntrHandler(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    uint32_t intrStatus = <a class="code" href="group__group__isouart__interrupt__functions.html#gab6fca3a063d0446136bfa052cc2f783d">Cy_ISOUART_GetInterruptStatusMasked</a>(ISOUART);</div><div class="line">    <a class="code" href="group__group__isouart__interrupt__functions.html#ga59a17f6508ba472e5626b8082da1ab04">Cy_ISOUART_ClearInterrupt</a>(ISOUART, intrStatus);</div><div class="line"></div><div class="line">    <span class="comment">/* Check for Wake-up interrupt on both interfaces. */</span></div><div class="line">    <span class="keywordflow">if</span> (0UL != (intrStatus &amp; (<a class="code" href="group__group__isouart__macros__interrupt__masks.html#gae3315982fa3a31eb7f70a4420bc7d411">CY_ISOUART_INTR_WAKE_HIGH</a> | <a class="code" href="group__group__isouart__macros__interrupt__masks.html#gaa02aeb963d6f7fc0f9dbb4f43cafdf8a">CY_ISOUART_INTR_WAKE_LOW</a>)))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Handle Wake-up interrupt. */</span></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Check for Primary Access interrupt. */</span></div><div class="line">    <span class="keywordflow">if</span> (0UL != (intrStatus &amp; <a class="code" href="group__group__isouart__macros__interrupt__masks.html#gaf9982e3cd55c37f522a3cb9837ea92d1">CY_ISOUART_INTR_REG_ACCESS_P</a>))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Get the interrupt address and event type. */</span></div><div class="line">        uint8_t intrAddress = <a class="code" href="group__group__isouart__interrupt__functions.html#ga663de66a7a4d74eb9ecaad4e1207fae9">Cy_ISOUART_NodeGetIntrAddrPrim</a>(ISOUART);</div><div class="line">        <a class="code" href="group__group__isouart__enums.html#gaf8903b939cf9627b4f0ecc3710911830">cy_en_isouart_event_t</a> intrEvent = <a class="code" href="group__group__isouart__interrupt__functions.html#ga78cd7822d8d207f00242e1f7fe97760d">Cy_ISOUART_NodeGetIntrEventPrim</a>(ISOUART);</div><div class="line"></div><div class="line">        <span class="comment">/* Check if write command was sent to the expected SRAM address. */</span></div><div class="line">        <span class="keywordflow">if</span> ((SRAM_ADDRESS == intrAddress) &amp;&amp; (<a class="code" href="group__group__isouart__enums.html#ggaf8903b939cf9627b4f0ecc3710911830ae0be52d935dc408264f723486a492699">CY_ISOUART_EVENT_WRITE</a> == intrEvent))</div><div class="line">        {</div><div class="line">            <span class="comment">/* Read the received data from SRAM. */</span></div><div class="line">            receivedData = <a class="code" href="group__group__isouart__sram__functions.html#ga61f5b2480294e583304a7db5dca360e4">Cy_ISOUART_ReadSramRow16</a>(ISOUART, intrAddress);</div><div class="line">            <span class="comment">/* Process received data. */</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga3d906793c82b584f3463c2f5b676ad75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d906793c82b584f3463c2f5b676ad75">&#9670;&nbsp;</a></span>Cy_ISOUART_ReadSramRow32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_ISOUART_ReadSramRow32 </td>
          <td>(</td>
          <td class="paramtype">ISOUART_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a 32-bit data from two consecutive iso UART SRAM rows. </p>
<p>The output 32-bit data is configured as follows:</p><ul>
<li>Bits [15:0] contain the data from the even index (index).</li>
<li>Bits [31:16] contain the data from the odd index (index + 1). <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base address for the iso UART. </td></tr>
    <tr><td class="paramname">index</td><td>Index of iso UART SRAM row (must be even). The valid range is 0...126, and this parameter must be an even value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>32-bit value read from two consecutive iso UART SRAM rows. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is valid for both Host and Node. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="ga3eb90840cd167295ba76551ae2e82c18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3eb90840cd167295ba76551ae2e82c18">&#9670;&nbsp;</a></span>Cy_ISOUART_WriteSramRow16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_ISOUART_WriteSramRow16 </td>
          <td>(</td>
          <td class="paramtype">ISOUART_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a 16-bit value to the data field of the specified iso UART SRAM row. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base address for the iso UART. </td></tr>
    <tr><td class="paramname">index</td><td>Index of iso UART SRAM row. The valid range is 0...127. </td></tr>
    <tr><td class="paramname">data</td><td>16-bit value to be written to the SRAM row. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is valid for both Host and Node. </dd></dl>

</div>
</div>
<a id="gafad1ea423899b8fc450fd00a72041c9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafad1ea423899b8fc450fd00a72041c9b">&#9670;&nbsp;</a></span>Cy_ISOUART_WriteSramRow32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_ISOUART_WriteSramRow32 </td>
          <td>(</td>
          <td class="paramtype">ISOUART_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a 32-bit data to two consecutive iso UART SRAM rows. </p>
<p>The input 32-bit data should be configured as follows:</p><ul>
<li>Bits [15:0] should contain the data for the even index.</li>
<li>Bits [31:16] should contain the data for the odd index. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base address for the iso UART. </td></tr>
    <tr><td class="paramname">index</td><td>Index of iso UART SRAM row (must be even). The valid range is 0...126, and this parameter must be an even value. </td></tr>
    <tr><td class="paramname">data</td><td>32-bit value to be written to two consecutive SRAM rows. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is valid for both Host and Node. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="gab1ce26fcb50542c344c2e3fab7c6281c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1ce26fcb50542c344c2e3fab7c6281c">&#9670;&nbsp;</a></span>Cy_ISOUART_HostReadSramRaw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_ISOUART_HostReadSramRaw </td>
          <td>(</td>
          <td class="paramtype">ISOUART_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__isouart__enums.html#gacf2d3e5d86ed1ad3bb584ef929f93fae">cy_en_isouart_interface_side_t</a>&#160;</td>
          <td class="paramname"><em>iSide</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>packetNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__isouart__raw__frame__t.html">cy_stc_isouart_raw_frame_t</a> *&#160;</td>
          <td class="paramname"><em>frame</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads RAW data frames from the iso UART SRAM of specified interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base address for the iso UART. </td></tr>
    <tr><td class="paramname">iSide</td><td>Interface side to be read. See <a class="el" href="group__group__isouart__enums.html#gacf2d3e5d86ed1ad3bb584ef929f93fae">cy_en_isouart_interface_side_t</a>. </td></tr>
    <tr><td class="paramname">packetNum</td><td>Packet number to be read. Valid range is [0, (allocated SRAM size for iSide / 3) - 1]. </td></tr>
    <tr><td class="paramname">frame</td><td>Pointer to the structure for storing RAW frame data. See <a class="el" href="structcy__stc__isouart__raw__frame__t.html">cy_stc_isouart_raw_frame_t</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is valid only when:<ul>
<li>The interface is initialized as Host mode.</li>
<li>The receiver mode is configured as <a class="el" href="group__group__isouart__enums.html#ggada45cd4ff842f52208cb24ef9d182546a2d44894027440b410eea2a73db043559">CY_ISOUART_RECEIVER_MODE_RAW</a>. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gae2c475bbf77332590cfdf723ab6ceb22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2c475bbf77332590cfdf723ab6ceb22">&#9670;&nbsp;</a></span>Cy_ISOUART_HostReadSramUnpack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t Cy_ISOUART_HostReadSramUnpack </td>
          <td>(</td>
          <td class="paramtype">ISOUART_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__isouart__enums.html#gacf2d3e5d86ed1ad3bb584ef929f93fae">cy_en_isouart_interface_side_t</a>&#160;</td>
          <td class="paramname"><em>iSide</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>packetNum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads UNPACKED data from the iso UART SRAM of specified interface. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base address for the iso UART. </td></tr>
    <tr><td class="paramname">iSide</td><td>Interface side to be read. See <a class="el" href="group__group__isouart__enums.html#gacf2d3e5d86ed1ad3bb584ef929f93fae">cy_en_isouart_interface_side_t</a>. </td></tr>
    <tr><td class="paramname">packetNum</td><td>Packet number to be read. Valid range is [0, allocated SRAM size for iSide - 1]. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Unpacked data (16-bit value). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is valid only when:<ul>
<li>The interface is initialized as Host mode.</li>
<li>The receiver mode is configured as <a class="el" href="group__group__isouart__enums.html#ggada45cd4ff842f52208cb24ef9d182546a1679c08d80fe2ce05cbe0283791cdfe7">CY_ISOUART_RECEIVER_MODE_UNPACKED</a>. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: Perform read operation from specific node in Master-on-Top topology.</span></div><div class="line"><span class="comment">     * This demonstrates SRAM size configuration, reading data from node, and unpacked data retrieval.</span></div><div class="line"><span class="comment">     * This example uses polling to wait for command completion instead of interrupt-driven approach.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">const</span> uint32_t address = 0UL;   <span class="comment">/* SRAM address to read from. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Disable iso UART block. */</span></div><div class="line">    <a class="code" href="group__group__isouart__common__functions.html#gab90f55e8aeabb059fdc6f1d90884d3b2">Cy_ISOUART_Disable</a>(ISOUART);</div><div class="line"></div><div class="line">    <span class="comment">/* For the proper handling, set the interface SRAM size to the expected size by the transaction.</span></div><div class="line"><span class="comment">     * NOTE: The SRAM size shall only be changed when iso UART is disabled or both interfaces are in Slave mode.</span></div><div class="line"><span class="comment">     * e.g. for unpack mode, normal read command = 1</span></div><div class="line"><span class="comment">     * e.g. for raw mode, normal read command = 3</span></div><div class="line"><span class="comment">     * e.g. for unpack mode, multi read command = 1 x number of multi read</span></div><div class="line"><span class="comment">     * e.g. for unpack mode, BC read command = 1 x number of nodes in the chain</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <a class="code" href="group__group__isouart__sram__functions.html#ga13bf7ea2057d2b4290455ba10310fe1f">Cy_ISOUART_HostSetSramSize</a>(ISOUART, 1UL, 0UL); <span class="comment">/* Set the Low side 1 row, High side 0 row. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Enable iso UART to operate. */</span></div><div class="line">    <a class="code" href="group__group__isouart__common__functions.html#gadf7a574beb29a2411f540cf8356f6c16">Cy_ISOUART_Enable</a>(ISOUART);</div><div class="line"></div><div class="line">    <span class="comment">/* Perform Read operation. */</span></div><div class="line">    <a class="code" href="group__group__isouart__host__functions.html#ga1ca934c5454237de73583ef5a9ad919f">Cy_ISOUART_HostSendReadCommand</a>(ISOUART, blockId, nodeId, address);</div><div class="line">    <span class="comment">/* Wait for Read command completion by polling SRAM_FULL interrupt status</span></div><div class="line"><span class="comment">     * (interface side depends on topology) instead of using interrupt service routine.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    uint32_t intrStatus = 0UL;</div><div class="line">    <span class="keywordflow">do</span></div><div class="line">    {</div><div class="line">        intrStatus = <a class="code" href="group__group__isouart__interrupt__functions.html#gaa27998c25657a4a8c5225d995d2044cc">Cy_ISOUART_GetInterruptStatus</a>(ISOUART);</div><div class="line">    } <span class="keywordflow">while</span> (0UL == (intrStatus &amp; CY_ISOUART_INTR_MASTER_LOW_SRAM_FULL));</div><div class="line"></div><div class="line">    <span class="comment">/* Clear interrupt flags. */</span></div><div class="line">    <a class="code" href="group__group__isouart__interrupt__functions.html#ga59a17f6508ba472e5626b8082da1ab04">Cy_ISOUART_ClearInterrupt</a>(ISOUART, intrStatus);</div><div class="line"></div><div class="line">    <span class="comment">/* Read data from low interface SRAM. */</span></div><div class="line">    uint16_t readData = <a class="code" href="group__group__isouart__sram__functions.html#gae2c475bbf77332590cfdf723ab6ceb22">Cy_ISOUART_HostReadSramUnpack</a>(ISOUART, <a class="code" href="group__group__isouart__enums.html#ggacf2d3e5d86ed1ad3bb584ef929f93faeab383854c267880dc0fd76cac0bb8e574">CY_ISOUART_IF_LOW</a>, 0UL);</div><div class="line">    <span class="comment">/* Process the read data */</span></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga92ae566e03aa083139bf2c94e08ad377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92ae566e03aa083139bf2c94e08ad377">&#9670;&nbsp;</a></span>Cy_ISOUART_EnableEcc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_ISOUART_EnableEcc </td>
          <td>(</td>
          <td class="paramtype">ISOUART_Type *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable ECC for iso UART SRAM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base address for the iso UART. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is valid for both Host and Node. </dd></dl>

</div>
</div>
<a id="gacafc4846bc62dc6f83f6f898cbfe268d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacafc4846bc62dc6f83f6f898cbfe268d">&#9670;&nbsp;</a></span>Cy_ISOUART_DisableEcc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_ISOUART_DisableEcc </td>
          <td>(</td>
          <td class="paramtype">ISOUART_Type *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable ECC for iso UART SRAM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base address for the iso UART. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is valid for both Host and Node. </dd></dl>

</div>
</div>
<a id="ga3e139dbdbfc6aa31574e17c689ce2e00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e139dbdbfc6aa31574e17c689ce2e00">&#9670;&nbsp;</a></span>Cy_ISOUART_EnableEccInjection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_ISOUART_EnableEccInjection </td>
          <td>(</td>
          <td class="paramtype">ISOUART_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>parity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable ECC error injection for iso UART SRAM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base address for the iso UART. </td></tr>
    <tr><td class="paramname">index</td><td>Index of iso UART SRAM row where an error will be injected. The valid range is 0...127. </td></tr>
    <tr><td class="paramname">parity</td><td>ECC parity to use for ECC error injection at SRAM index. The valid range is 0...127. During the ECC error injection is enabled, when the SRAM[index] is written, ECC parity is forced to be updated with this value instead of the value calculated by HW. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is valid for both Host and Node. <br />
During the ECC error injection is enabled, access to the SRAM[index] will never cause bus error on uncorrectable ECC error or address error. Reporting to FAULT structure is valid even if the ECC error injection is enabled. The ECC error injection mechanism actually updates the SRAM parity, so the inserted ECC error will still cause the error after the ECC error injection is disabled. It's recommended to re-initialize the SRAM[index] with 32 bits write after disabling the ECC error injection to reset the ECC parity with correct value. </dd></dl>

</div>
</div>
<a id="ga6b60c0869abff9fd6d584bc23c8e3e46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b60c0869abff9fd6d584bc23c8e3e46">&#9670;&nbsp;</a></span>Cy_ISOUART_DisableEccInjection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_ISOUART_DisableEccInjection </td>
          <td>(</td>
          <td class="paramtype">ISOUART_Type *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable ECC error injection for iso UART SRAM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base address for the iso UART. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is valid for both Host and Node. </dd></dl>

</div>
</div>
<a id="ga5288e3b523c43e80fea3d3640a659f58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5288e3b523c43e80fea3d3640a659f58">&#9670;&nbsp;</a></span>Cy_ISOUART_GetEccStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_ISOUART_GetEccStatus </td>
          <td>(</td>
          <td class="paramtype">const ISOUART_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__isouart__ecc__status__t.html">cy_stc_isouart_ecc_status_t</a> *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get ECC status of iso UART SRAM. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base address for the iso UART. </td></tr>
    <tr><td class="paramname">status</td><td>Pointer to a status structure to be filled. See <a class="el" href="structcy__stc__isouart__ecc__status__t.html">cy_stc_isouart_ecc_status_t</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function is valid for both Host and Node. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>CAT2 Peripheral Driver Library</b> by <b>Infineon Technologies</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
