<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CAT2 Peripheral Driver Library: WDT          (Watchdog Timer)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CAT2 Peripheral Driver Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__wdt.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#groups">Modules</a>  </div>
  <div class="headertitle">
<div class="title">WDT (Watchdog Timer)</div>  </div>
</div><!--header-->
<div class="contents">

<p>The Watchdog timer (WDT) has a 16-bit (or 32-bit resolution for PSOC4 HVMS/PA devices) free-running up-counter with programmable limit values.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="groups"></a>
Modules</h2></td></tr>
<tr class="memitem:group__group__wdt__macros"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdt__macros.html">Macros</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__wdt__enums"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdt__enums.html">Enumerated Types</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:group__group__wdt__functions"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdt__functions.html">Functions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The Watchdog timer (WDT) has a 16-bit (or 32-bit resolution for PSOC4 HVMS/PA devices) free-running up-counter with programmable limit values. </p>
<p>The functions and other declarations used in this driver are in cy_wdt.h. You can include cy_pdl.h to get access to all functions and declarations in the PDL.</p>
<p>The WDT can issue counter match interrupts, and a device reset if its interrupts are not handled. Use the Watchdog timer for two main purposes:</p>
<p>The <b> First use case </b> is recovering from a CPU or firmware failure. A timeout period is set up in the Watchdog timer, and if a timeout occurs, the device is reset (WRES). <br />
 The <b>Second use case</b> is to generate periodic interrupts.</p>
<p>You can use the WDT to generate periodic interrupts. However, the <a class="el" href="group__group__sysclk__ilo.html">Internal Low-Speed Oscillator (ILO)</a> (or <a class="el" href="group__group__sysclk__lf.html">Low-Frequency Clock</a> for PSOC4 HVMS/PA devices) is the clock source for the WDT, so its accuracy should be considered. Use the ILO compensation (<a class="el" href="group__group__sysclk__ilo__funcs.html#ga17cc56e4b20c8a43076b3a544affb6a4">Cy_SysClk_IloCompensate()</a>) technique to increase ILO accuracy or use <a class="el" href="group__group__sysclk__calclk.html">Clock Calibration</a> together with <a class="el" href="group__group__sysclk__trim.html">Clock Trim (IMO, PILO)</a> technique to increase <a class="el" href="group__group__sysclk__lf.html">Low-Frequency Clock</a> accuracy for PSOC4 HVMS/PA devices.<br />
Other options may provide a more precise periodic interrupt. See <a class="el" href="group__group__wdc.html">WDC (Watchdog Counters)</a> (using <a class="el" href="group__group__sysclk__wco.html">Watch Crystal Oscillator (WCO)</a> as clock source) or <a class="el" href="group__group__arm__system__timer.html">SysTick (ARM System Timer)</a> (in active power mode).</p>
<dl class="section note"><dt>Note</dt><dd>The <a class="el" href="group__group__wdc.html">WDC (Watchdog Counters)</a> and <a class="el" href="group__group__sysclk__wco.html">Watch Crystal Oscillator (WCO)</a> not applicable for PSOC4 HVMS/PA.</dd></dl>
<p>A "reset cause" register exists, and the firmware should check this register at a start-up <a class="el" href="group__group__syslib__functions.html#gac8aa61d2f8052886c676f4f592d1693d">Cy_SysLib_GetResetReason()</a>. An appropriate action can be taken if a WRES reset is detected.</p>
<p>The user's firmware periodically resets the timeout period (clears or "feeds" the watchdog) before a timeout occurs. If the firmware fails to do so, that is considered to be a CPU crash or a firmware failure, and the reason for a device reset. The WDT can generate an interrupt instead of a device reset. The Interrupt Service Routine (ISR) can handle the interrupt either as a periodic interrupt, or as an early indication of a firmware failure and respond accordingly. However, it is not recommended to use the WDT for periodic interrupt generation. The <a class="el" href="group__group__wdc.html">WDC (Watchdog Counters)</a> can be used to generate periodic interrupts if such are presented in the device.</p>
<p><b> Functional Description </b></p>
<p>The WDT generates an interrupt when the count value in the counter equals the configured match value.</p>
<p>Note that the counter is not reset on a match. In such case the WDT reset period is: WDT_Reset_Period = ILO_Period * (2*2^(16-IgnoreBits) + MatchValue); When the counter reaches a match value, it generates an interrupt and then keeps counting up until it overflows and rolls back to zero and reaches the match value again, at which point another interrupt is generated.</p>
<p>To use a WDT to generate a periodic interrupt, the match value should be incremented in the ISR. As a result, the next WDT interrupt is generated when the counter reaches a new match value.</p>
<p>You can also reduce the entire WDT counter period by specifying the number of most significant bits that are ignored in the WDT counter. For example, if the <a class="el" href="group__group__wdt__functions.html#gafad1413ff11cfb3e3e2b5d9854dc793e">Cy_WDT_SetIgnoreBits()</a> function is called with parameter 3, the WDT counter becomes a 13-bit free-running up-counter.</p>
<p><b> PSOC4 HVMS/PA Functional Design Details </b></p>
<p>For PSOC4 HVMS/PA devices, the WDT can be configured to act on different counter limits where a reset is triggered if the watchdog is not serviced before the upper limit. In the window mode, a reset is triggered if the servicing occurs before the lower limit is reached. The warning limit triggers an interrupt to request servicing. Each of these actions can be activated independently. The WDT is enabled and specific registers are locked by default. An unlocking sequence is required to prevent accidental accesses. The WDT operates in active, sleep, and deepsleep modes. After a WDT reset the device returns to active mode.</p>
<div class="image">
<img src="basic_wdt_functional_diagram.png" alt="basic_wdt_functional_diagram.png"/>
<div class="caption">
PSOC4 HVMS/PA Basic WDT functional diagram</div></div>
<p> <b> Register Locking </b></p>
<dl class="section note"><dt>Note</dt><dd>Applicable to PSOC4 HVMS/PA only.</dd></dl>
<p>You can prevent accidental corruption of the WDT configuration by calling the <a class="el" href="group__group__wdt__functions.html#ga5a0d9b4d5c6454af7213b32c4db7671c">Cy_WDT_Lock()</a> function. When the WDT is locked, any writing to the WDT_*, CLK_ILO_CONFIG, CLK_SELECT.LFCLK_SEL, and CLK_TRIM_ILO_CTL registers is ignored. Call the <a class="el" href="group__group__wdt__functions.html#ga0c4e41c9c1b0d575747d1a984e63a6b0">Cy_WDT_Unlock()</a> function to allow registers modification, mentioned above.</p>
<dl class="section note"><dt>Note</dt><dd>The WDT lock state is not retained during system Deep Sleep. After the wakeup from system Deep Sleep the WDT is locked.</dd></dl>
<p><b> Power Modes </b></p>
<p>WDT can operate in all possible low power modes.</p>
<p>In CPU Active mode, an interrupt request from the WDT is sent to the CPU. In CPU Sleep, CPU Deep Sleep mode, the CPU subsystem is powered down, so the interrupt request from the WDT is sent directly to the WakeUp Interrupt Controller (WIC) which will then wake up the CPU. The CPU then acknowledges the interrupt request and executes the ISR.</p>
<p><b> Clock Source </b></p>
<p>The WDT is clocked by the ILO (or <a class="el" href="group__group__sysclk__lf.html">Low-Frequency Clock</a> for PSOC4 HVMS/PA devices). The WDT must be disabled before disabling the ILO (or <a class="el" href="group__group__sysclk__lf.html">Low-Frequency Clock</a>). Need to consider ILO (or <a class="el" href="group__group__sysclk__lf.html">Low-Frequency Clock</a>) accuracy while configuring WDT intervals to make sure that unwanted device resets do not occur on some devices.</p>
<p>Refer to the device datasheet for more information on the oscillator accuracy.</p>
<p><b> Clearing WDT </b></p>
<p>The ILO (or <a class="el" href="group__group__sysclk__lf.html">Low-Frequency Clock</a>) clock is asynchronous to the SysClk. Therefore it generally takes three ILO (or <a class="el" href="group__group__sysclk__lf.html">Low-Frequency Clock</a>) cycles for WDT register changes to come into effect. It is important to remember that a WDT should be cleared at least <b>four cycles</b> (3 + 1 for sure) before a timeout occurs, especially when small match values / low-toggle bit numbers are used.</p>
<dl class="section warning"><dt>Warning</dt><dd>It may happen that a WDT reset can be generated faster than a device start-up. To prevent this, calculate the start-up time and WDT reset time. The WDT reset time should be always greater than device start-up time.</dd></dl>
<p><b> Reset Detection </b></p>
<p>Use the <a class="el" href="group__group__syslib__functions.html#gac8aa61d2f8052886c676f4f592d1693d">Cy_SysLib_GetResetReason()</a> function to detect whether the WDT has triggered a device reset.</p>
<p><b> Interrupt Configuration </b></p>
<p>If the WDT is configured to generate an interrupt, pending interrupts must be cleared within the ISR (otherwise, the interrupt will be generated continuously). A pending interrupt to the WDT block must be cleared by calling the <a class="el" href="group__group__wdt__functions.html#ga727d9ae6fdba36809bf631985a3eb987">Cy_WDT_ClearInterrupt()</a> function. The call to the function will clear the unhandled WDT interrupt counter.</p>
<p>Use the WDT ISR as a timer to trigger certain actions and to change a next WDT match or limit value.</p>
<p>Ensure that the interrupts from the WDT are passed to the CPU to avoid unregistered interrupts. Unregistered WDT interrupts result in a continuous device reset. To avoid this, call <a class="el" href="group__group__wdt__functions.html#ga38c69c98675d6024a7d73acb41b24399">Cy_WDT_UnmaskInterrupt()</a>. After that, call the WDT API functions for interrupt handling/clearing.</p>
<p>It is not recommended to reset the watchdog counter in the WDT interrupt service routine (ISR), if WDT is being used as a reset source to protect the system against crashes. If necessary, use the warning interrupt to set a flag in the ISR. Local processing loops can observe that flag and break out of their loop. This allows the main loop to reach the servicing code (and clear the flag for the next pass through the main loop).</p>
<h1><a class="anchor" id="group_wdt_configuration"></a>
Configuration Considerations</h1>
<p>To start the WDT, make sure that ILO (or <a class="el" href="group__group__sysclk__lf.html">Low-Frequency Clock</a>) is enabled. After the ILO (or <a class="el" href="group__group__sysclk__lf.html">Low-Frequency Clock</a>) is enabled, ensure that the watchdog reset is disabled by calling the <a class="el" href="group__group__wdt__functions.html#ga709f597d56e7f7fb6717d5ff671491fa">Cy_WDT_Disable()</a> function. Set the WDT match value by calling <a class="el" href="group__group__wdt__functions.html#ga1e707a8236e6dcd90eede7e726a2648f">Cy_WDT_SetMatch()</a> with the required match value. If needed, set the ignore bits for reducing the WDT counter period by calling <a class="el" href="group__group__wdt__functions.html#gafad1413ff11cfb3e3e2b5d9854dc793e">Cy_WDT_SetIgnoreBits()</a> function. After the WDT configuration is set, call <a class="el" href="group__group__wdt__functions.html#ga82aec7e454d05d03dfd1d6fd5e573d5e">Cy_WDT_Enable()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The watchdog counter is a free-running counter that cannot be disabled.</dd>
<dd>
Enable a WDT if the power supply can produce sudden brownout events that may compromise the CPU functionality. This ensures that the system can recover after a brownout.</dd></dl>
<p>When the WDT is used to protect against system crashes, the WDT interrupt should be cleared by a portion of the code that is not directly associated with the WDT interrupt. Otherwise, it is possible that the main firmware loop has crashed or is in an endless loop, but the WDT interrupt vector continues to operate and service the WDT. The user should:</p><ul>
<li>Feed the watchdog by clearing the interrupt bit regularly in the main body of the firmware code.</li>
<li>Guarantee that the interrupt is cleared at least once every WDT period.</li>
<li>Use the WDT ISR only as a timer to trigger certain actions and to change the next match value.</li>
</ul>
<h1><a class="anchor" id="group_wdt_section_use_case_1"></a>
Use case 1. Configure the WDT for periodic interrupt.</h1>
<p>Set parameters of the WDT.</p>
<div class="fragment"><div class="line"><span class="comment">/* The number of WDT ticks for the 1s interrupt generation, </span></div><div class="line"><span class="comment">* at the ILO clock frequency of 40 kHz. </span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="preprocessor">#define WDT_TICKS_40000                         (40000U)</span></div><div class="line"><span class="comment">/* WDT ignore bits */</span></div><div class="line"><span class="preprocessor">#define WDT_IGNORE_BITS_0                       (0U)</span></div></div><!-- fragment --><p> Create an interrupt config structure and interrupt handler.</p>
<div class="fragment"><div class="line"><span class="comment">/* Assign WDT interrupt number and priority */</span></div><div class="line"><span class="preprocessor">#define WDT_INTR_NUM                            ((IRQn_Type) srss_interrupt_wdt_IRQn)</span></div><div class="line"><span class="preprocessor">#define WDT_INTR_PRIORITY                       (3U)</span></div><div class="line"></div><div class="line"><span class="comment">/* Populate configuration structure */</span></div><div class="line"><a class="code" href="structcy__stc__sysint__t.html">cy_stc_sysint_t</a> wdtIntrConfig =</div><div class="line">{</div><div class="line">    .<a class="code" href="structcy__stc__sysint__t.html#a6da08d81da65a7f93d3e4c46a4b8d950">intrSrc</a>      = WDT_INTR_NUM,</div><div class="line">    .intrPriority = WDT_INTR_PRIORITY,</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/* Interrupt handler */</span></div><div class="line"><span class="keywordtype">void</span> WDT_Isr(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* To adjust the WDT interrupt period using the match value, update</span></div><div class="line"><span class="comment">    * that match value in every WDT interrupt by assigning a new match value. </span></div><div class="line"><span class="comment">    * Calculate the new match value: </span></div><div class="line"><span class="comment">    * */</span></div><div class="line">    uint16_t setValue = (uint16_t) <a class="code" href="group__group__wdt__functions.html#ga1e7105cb2482131f03140a223caf5cc1">Cy_WDT_GetCount</a>() + (uint16_t) WDT_TICKS_40000;</div><div class="line"></div><div class="line">    <span class="comment">/* Update match value */</span></div><div class="line">    <a class="code" href="group__group__wdt__functions.html#ga1e707a8236e6dcd90eede7e726a2648f">Cy_WDT_SetMatch</a>(setValue);</div><div class="line"></div><div class="line">    <span class="comment">/* Clear WDT interrupt */</span></div><div class="line">    <a class="code" href="group__group__wdt__functions.html#ga727d9ae6fdba36809bf631985a3eb987">Cy_WDT_ClearInterrupt</a>();</div><div class="line">}</div></div><!-- fragment --><p> Hook the interrupt service routine and enable interrupt than config the WDT.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> wdtConfig_useCase_1(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Disable the system reset generation. After a device reset, reset by WDT is</span></div><div class="line"><span class="comment">    * enabled by default. </span></div><div class="line"><span class="comment">    */</span></div><div class="line">    <a class="code" href="group__group__wdt__functions.html#ga709f597d56e7f7fb6717d5ff671491fa">Cy_WDT_Disable</a>();</div><div class="line"></div><div class="line">    <span class="comment">/* Hook interrupt service routine and enable interrupt */</span></div><div class="line">    (void) <a class="code" href="group__group__sysint__functions.html#gab2ff6820a898e9af3f780000054eea5d">Cy_SysInt_Init</a>(&amp;wdtIntrConfig, &amp;WDT_Isr);</div><div class="line">    NVIC_EnableIRQ(WDT_INTR_NUM);</div><div class="line"></div><div class="line">    <span class="comment">/* Config WDT: set the match value - 40000 and ignore bits - 0.*/</span></div><div class="line">    <a class="code" href="group__group__wdt__functions.html#ga1e707a8236e6dcd90eede7e726a2648f">Cy_WDT_SetMatch</a>(WDT_TICKS_40000);</div><div class="line">    <a class="code" href="group__group__wdt__functions.html#gafad1413ff11cfb3e3e2b5d9854dc793e">Cy_WDT_SetIgnoreBits</a>(WDT_IGNORE_BITS_0);</div><div class="line"></div><div class="line">    <span class="comment">/* Clear the interrupt */</span></div><div class="line">    <a class="code" href="group__group__wdt__functions.html#ga727d9ae6fdba36809bf631985a3eb987">Cy_WDT_ClearInterrupt</a>();</div><div class="line"></div><div class="line">    <span class="comment">/* Unmask WDT interrupt */</span></div><div class="line">    <a class="code" href="group__group__wdt__functions.html#ga38c69c98675d6024a7d73acb41b24399">Cy_WDT_UnmaskInterrupt</a>();</div><div class="line">}</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>Additionally, global interrupts should be enabled.</dd>
<dd>
Before the WDT initialization, ensure that the WDT clock source is enabled. Refer to <a class="el" href="group__group__sysclk__ilo.html">Internal Low-Speed Oscillator (ILO)</a> of SysClk driver documentation.</dd></dl>
<h1><a class="anchor" id="group_wdt_section_use_case_2"></a>
Use case 2. Configure the WDT for the system reset generation after a configurable interval.</h1>
<p>In this case, the WDT resets every third WDT event of the system(1.2287s at ILO 40kHz).</p>
<p>As part of this code, the snippet uses the formula from the <b> Functional Description </b>.</p>
<div class="fragment"><div class="line"><span class="comment">/* The number of WDT ticks */</span></div><div class="line"><span class="preprocessor">#define WDT_TICKS_16383                         (16383U)</span></div><div class="line"><span class="comment">/* WDT ignore bits */</span></div><div class="line"><span class="preprocessor">#define WDT_IGNORE_BITS_2                       (2U)</span></div></div><!-- fragment --><div class="fragment"><div class="line"><span class="keywordtype">void</span> wdtConfig_useCase_2(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Disable the system reset generation. After a device reset, reset by WDT is</span></div><div class="line"><span class="comment">    * enabled by default. </span></div><div class="line"><span class="comment">    */</span></div><div class="line">    <a class="code" href="group__group__wdt__functions.html#ga709f597d56e7f7fb6717d5ff671491fa">Cy_WDT_Disable</a>();</div><div class="line"></div><div class="line">    <span class="comment">/* Config WDT: set the match value to 16383 because this value</span></div><div class="line"><span class="comment">    * is equivalent to a timer period with 2 ignore bits.</span></div><div class="line"><span class="comment">    * Set ignore bits to 2. Based on these parameters, </span></div><div class="line"><span class="comment">    * the WDT_Reset_Period = 0,000025 * (2 * 2^14 + 16383) = 1.2287s.</span></div><div class="line"><span class="comment">    */</span></div><div class="line">    <a class="code" href="group__group__wdt__functions.html#ga1e707a8236e6dcd90eede7e726a2648f">Cy_WDT_SetMatch</a>(WDT_TICKS_16383);</div><div class="line">    <a class="code" href="group__group__wdt__functions.html#gafad1413ff11cfb3e3e2b5d9854dc793e">Cy_WDT_SetIgnoreBits</a>(WDT_IGNORE_BITS_2);</div><div class="line"></div><div class="line">    <span class="comment">/* Enables the watchdog timer reset generation. */</span></div><div class="line">    <a class="code" href="group__group__wdt__functions.html#ga82aec7e454d05d03dfd1d6fd5e573d5e">Cy_WDT_Enable</a>();</div><div class="line">}</div></div><!-- fragment --> <h1><a class="anchor" id="group_wdt_section_use_case_3_srsshv"></a>
Use case 3. The WDT counter in interrupt mode.</h1>
<dl class="section note"><dt>Note</dt><dd>Applicable to PSOC4 HVMS/PA only.</dd></dl>
<p>The timing diagram below shows the behavior of the WDT counter in interrupt mode. LOWER and UPPER actions are disabled. An interrupt is issued each time the counter matches the WARN_LIMIT. The interrupt period is calculated by 2^32 x LFCLK clock cycles. The WDT counter could be cleared (serviced) in two ways:</p><ul>
<li>manually by calling <a class="el" href="group__group__wdt__functions.html#ga44b0861b8d7b8553f84842da51e9c423">Cy_WDT_SetService()</a> function</li>
<li>automatically by calling <a class="el" href="group__group__wdt__functions.html#ga0c8d2fa84afb395152979a6a033ac676">Cy_WDT_SetAutoService()</a> function</li>
</ul>
<div class="image">
<img src="wdt_interrupt_mode_operation_diagram.png" alt="wdt_interrupt_mode_operation_diagram.png"/>
<div class="caption">
WDT counter operation with WARN interrupt only</div></div>
<p> Set parameters of the WDT.</p>
<div class="fragment"><div class="line"><span class="comment">/* The number of WDT ticks for the 1s interrupt generation */</span></div><div class="line"><span class="preprocessor">#if defined(CY_CFG_SYSCLK_PILO_ENABLED)</span></div><div class="line">    <span class="comment">/* Enabled ILO clock 40 kHz */</span></div><div class="line"><span class="preprocessor">    #define WDT_TICKS   (CY_SYSCLK_ILO_FREQ)</span></div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    <span class="comment">/* Enabled PILO clock 32.768 kHz*/</span></div><div class="line"><span class="preprocessor">    #define WDT_TICKS   (CY_SYSCLK_PILO_FREQ)</span></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p> Create an interrupt config structure and interrupt handler.</p>
<div class="fragment"><div class="line"><span class="comment">/* Assign WDT interrupt number and priority */</span></div><div class="line"><span class="preprocessor">#define WDT_INTR_NUM                            ((IRQn_Type) srss_wdt_irq_IRQn)</span></div><div class="line"><span class="preprocessor">#define WDT_INTR_PRIORITY                       (3U)</span></div><div class="line"></div><div class="line"><span class="comment">/* Populate configuration structure */</span></div><div class="line"><a class="code" href="structcy__stc__sysint__t.html">cy_stc_sysint_t</a> wdtIntrConfig =</div><div class="line">{</div><div class="line">    .<a class="code" href="structcy__stc__sysint__t.html#a6da08d81da65a7f93d3e4c46a4b8d950">intrSrc</a>      = WDT_INTR_NUM,</div><div class="line">    .intrPriority = WDT_INTR_PRIORITY,</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/* Interrupt handler */</span></div><div class="line"><span class="keywordtype">void</span> WDT_Isr(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">/* Clear WDT interrupt.</span></div><div class="line"><span class="comment">    Clearing the interrupt does not reset the watchdog counter. */</span></div><div class="line">    <a class="code" href="group__group__wdt__functions.html#ga727d9ae6fdba36809bf631985a3eb987">Cy_WDT_ClearInterrupt</a>();</div><div class="line">}</div></div><!-- fragment --><p> Hook the interrupt service routine and enable interrupt than config the WDT.</p>
<div class="fragment"><div class="line">    <span class="comment">/* The Watchdog timer should be unlocked before being disabled. */</span></div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="group__group__wdt__functions.html#ga7d651ba3f26230b7bf18ca730d342450">Cy_WDT_Locked</a>())</div><div class="line">    {</div><div class="line">        <a class="code" href="group__group__wdt__functions.html#ga0c4e41c9c1b0d575747d1a984e63a6b0">Cy_WDT_Unlock</a>();</div><div class="line">    }</div><div class="line">    <span class="comment">/* Disable the WDT. After a device reset, WDT is enabled by default. */</span></div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="group__group__wdt__functions.html#ga05f8bb5603ce46caf842bd0ad254f604">Cy_WDT_IsEnabled</a>())</div><div class="line">    {</div><div class="line">        <a class="code" href="group__group__wdt__functions.html#ga709f597d56e7f7fb6717d5ff671491fa">Cy_WDT_Disable</a>();</div><div class="line">        <span class="keywordflow">while</span>(<a class="code" href="group__group__wdt__functions.html#ga05f8bb5603ce46caf842bd0ad254f604">Cy_WDT_IsEnabled</a>())</div><div class="line">        {</div><div class="line">            <span class="comment">/* Do nothing. Wait until the WDT Disable takes effect.</span></div><div class="line"><span class="comment">            May take up to three clk_lf cycles to take effect. */</span></div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Hook interrupt service routine and enable interrupt */</span></div><div class="line">    <a class="code" href="group__group__sysint__enums.html#ga01619b224f9d5c23915e51783ea184c8">cy_en_sysint_status_t</a> sysintStatus = <a class="code" href="group__group__sysint__functions.html#gab2ff6820a898e9af3f780000054eea5d">Cy_SysInt_Init</a>(&amp;wdtIntrConfig, WDT_Isr);</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__sysint__enums.html#gga01619b224f9d5c23915e51783ea184c8af7db469e7f8cd5cb7917d1324005eb89">CY_SYSINT_SUCCESS</a> != sysintStatus)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Insert the error handling here */</span></div><div class="line">        CY_ASSERT(0);</div><div class="line">    }</div><div class="line">    NVIC_EnableIRQ(WDT_INTR_NUM); <span class="comment">/* Enable the interrupt. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Set LOWER_LIMIT to &quot;0&quot; and LOWER_ACTION to None */</span></div><div class="line">    <a class="code" href="group__group__wdt__functions.html#gac3068b5f898aaecbb16a7e747eb2ac6a">Cy_WDT_SetLowerLimit</a>(<a class="code" href="group__group__wdt__macros.html#gac2cc638fae680036c69059994f3e271c">CY_WDT_DEFAULT_LOWER_LIMIT</a>);</div><div class="line">    <a class="code" href="group__group__wdt__functions.html#gaea903a29e21c0e159352a816c326fe72">Cy_WDT_SetLowerAction</a>(<a class="code" href="group__group__wdt__enums.html#ggad825b14b5e132304da2877abc00d20ceadcffbdfe369efbe05935189e54e92bba">CY_WDT_LOW_UPPER_LIMIT_ACTION_NONE</a>);</div><div class="line"></div><div class="line">    <a class="code" href="group__group__wdt__functions.html#gaa398184eb16a3a080d4e96c32641c0e8">Cy_WDT_SetWarnLimit</a>(WDT_TICKS); <span class="comment">/* 32 768 (~1 sec when clk_lf = 32KHz) */</span></div><div class="line">    <span class="comment">/* Set warn action to trigger an interrupt */</span></div><div class="line">    <a class="code" href="group__group__wdt__functions.html#gaf86e75ba80f13612682449113e891c5e">Cy_WDT_SetWarnAction</a>(<a class="code" href="group__group__wdt__enums.html#gga81dab00f6381d41c0f7ed9765cf09d41a0ba35b16e2c268630616a1023e9434eb">CY_WDT_WARN_ACTION_INT</a>);</div><div class="line"></div><div class="line">    <a class="code" href="group__group__wdt__functions.html#ga370b6a151be8d6a9facd471589c9dd5a">Cy_WDT_SetUpperLimit</a>(3 * WDT_TICKS); <span class="comment">/* 98 304 (~3 sec when clk_lf = 32KHz) */</span></div><div class="line">    <a class="code" href="group__group__wdt__functions.html#ga0ede82be1107d76de2fd9fb1fd243915">Cy_WDT_SetUpperAction</a>(<a class="code" href="group__group__wdt__enums.html#ggad825b14b5e132304da2877abc00d20ceadcffbdfe369efbe05935189e54e92bba">CY_WDT_LOW_UPPER_LIMIT_ACTION_NONE</a>);</div><div class="line"></div><div class="line">    <span class="comment">/* Set automatically service when the count value reaches WARN_LIMIT.</span></div><div class="line"><span class="comment">    This allows creation of a periodic interrupt if this counter is not needed as a watchdog.</span></div><div class="line"><span class="comment">    This configuration is ignored when LOWER_ACTION or when UPPER_ACTION is set to trigger a reset. */</span></div><div class="line">    <a class="code" href="group__group__wdt__functions.html#ga0c8d2fa84afb395152979a6a033ac676">Cy_WDT_SetAutoService</a>(CY_WDT_ENABLE);</div><div class="line"></div><div class="line">    <a class="code" href="group__group__wdt__functions.html#ga82aec7e454d05d03dfd1d6fd5e573d5e">Cy_WDT_Enable</a>();</div><div class="line"></div><div class="line">    <span class="comment">/* Lock WDT configuration changes. */</span></div><div class="line">    <a class="code" href="group__group__wdt__functions.html#ga5a0d9b4d5c6454af7213b32c4db7671c">Cy_WDT_Lock</a>();</div><div class="line"></div><div class="line">    <span class="comment">/* Clear the interrupt */</span></div><div class="line">    <a class="code" href="group__group__wdt__functions.html#ga727d9ae6fdba36809bf631985a3eb987">Cy_WDT_ClearInterrupt</a>();</div><div class="line"></div><div class="line">    <span class="comment">/* Unmask interrupts from the WDT, they are passed to CPU */</span></div><div class="line">    <a class="code" href="group__group__wdt__functions.html#ga38c69c98675d6024a7d73acb41b24399">Cy_WDT_UnmaskInterrupt</a>();</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>Additionally, global interrupts should be enabled.</dd>
<dd>
Before the WDT initialization, ensure that the WDT clock source is enabled. Refer to <a class="el" href="group__group__sysclk__lf.html">Low-Frequency Clock</a> of SysClk driver documentation.</dd></dl>
<h1><a class="anchor" id="group_wdt_section_use_case_4"></a>
Use case 4. Configure the WDT counter in window mode.</h1>
<dl class="section note"><dt>Note</dt><dd>Applicable to PSOC4 HVMS/PA only.</dd></dl>
<p>The timing diagram below shows the behavior of the WDT counter in window mode. The timing diagram shows all scenarios of the WDT operation while LOWER_ACTION, WARN_ACTION, and UPPER_ACTION are enabled.</p><ul>
<li>Counter is serviced between LOWER_LIMIT and WARN_LIMIT: This is the regular behavior of the WDT. No WARN interrupt is issued and no RESET is done.</li>
<li>Counter is serviced between WARN_LIMIT and UPPER_LIMIT: The service is done late, a WARN interrupt is issued but no RESET is done.</li>
<li>Counter is not serviced at all: WARN interrupt is issued but the SERVICE bit is not set. When the counter reaches the UPPER_LIMIT a reset is executed.</li>
<li>Counter is serviced before the LOWER_LIMIT is reached: The counter is serviced too early; a reset is executed because the counter is cleared outside of the window.</li>
</ul>
<div class="image">
<img src="wdt_window_mode_operation_diagram.png" alt="wdt_window_mode_operation_diagram.png"/>
<div class="caption">
WDT counter operation in window mode</div></div>
 <dl class="section note"><dt>Note</dt><dd>The timing diagram illustrates the different scenarios with or without servicing the watchdog counter. It does not consider the WDT configuration, especially after a reset.</dd></dl>
<h1><a class="anchor" id="group_wdt_section_more_information"></a>
More Information</h1>
<p>For more information on the WDT peripheral, refer to the technical reference manual (TRM).</p>
<h1><a class="anchor" id="group_wdt_changelog"></a>
Changelog</h1>
<table class="doxtable">
<tr>
<th>Version</th><th>Changes</th><th>Reason for Change </th></tr>
<tr>
<td>1.10 </td><td>Added support for PSOC4 HVMS/PA platform.<br />
 Updated APIs to incorporate PSOC4 HVMS/PA platform configuration.<br />
 Documentation enhancement. Provided code snippets. </td><td>New device support.  </td></tr>
<tr>
<td>1.0.3 </td><td>Updated code snippets. </td><td>Documentation enhancement.  </td></tr>
<tr>
<td>1.0.2 </td><td>Update the paths to the code snippets. </td><td>PDL structure update.  </td></tr>
<tr>
<td>1.0.1 </td><td>Code snippets added. </td><td>Documentation enhancement.  </td></tr>
<tr>
<td>1.0 </td><td>Initial version </td><td></td></tr>
</table>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>CAT2 Peripheral Driver Library</b> by <b>Infineon Technologies</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
