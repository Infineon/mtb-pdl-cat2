<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CAT2 Peripheral Driver Library: Interrupt Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CAT2 Peripheral Driver Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__dsadc__interrupt__functions.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Interrupt Functions<div class="ingroups"><a class="el" href="group__group__dsadc.html">DSADC        (Delta-Sigma ADC)</a> &raquo; <a class="el" href="group__group__dsadc__functions.html">Functions</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>This set of functions are related to DSADC interrupts.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab73f0c19534e0fafd107e9cb8ccb71e2"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__dsadc__interrupt__functions.html#gab73f0c19534e0fafd107e9cb8ccb71e2">Cy_DSADC_ClearInterrupt</a> (PACSS_DCHAN_Type *base, uint32_t intrMask)</td></tr>
<tr class="memdesc:gab73f0c19534e0fafd107e9cb8ccb71e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the specified interrupt for the specified DCHAN.  <a href="#gab73f0c19534e0fafd107e9cb8ccb71e2">More...</a><br /></td></tr>
<tr class="separator:gab73f0c19534e0fafd107e9cb8ccb71e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86ddc0c7094590530a554752ad793a94"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__dsadc__interrupt__functions.html#ga86ddc0c7094590530a554752ad793a94">Cy_DSADC_GetInterruptStatus</a> (const PACSS_DCHAN_Type *base)</td></tr>
<tr class="memdesc:ga86ddc0c7094590530a554752ad793a94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the interrupt status for the specified DCHAN.  <a href="#ga86ddc0c7094590530a554752ad793a94">More...</a><br /></td></tr>
<tr class="separator:ga86ddc0c7094590530a554752ad793a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab30cb11deb2a3e788dcf45ba96137772"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__dsadc__interrupt__functions.html#gab30cb11deb2a3e788dcf45ba96137772">Cy_DSADC_SetInterrupt</a> (PACSS_DCHAN_Type *base, uint32_t intrMask)</td></tr>
<tr class="memdesc:gab30cb11deb2a3e788dcf45ba96137772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the interrupt source to check if HW operates correctly or to use it as a SW interrupt.  <a href="#gab30cb11deb2a3e788dcf45ba96137772">More...</a><br /></td></tr>
<tr class="separator:gab30cb11deb2a3e788dcf45ba96137772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga167b14c57a2df68bbef49c29e23b7eaa"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__dsadc__interrupt__functions.html#ga167b14c57a2df68bbef49c29e23b7eaa">Cy_DSADC_GetInterruptMask</a> (const PACSS_DCHAN_Type *base)</td></tr>
<tr class="memdesc:ga167b14c57a2df68bbef49c29e23b7eaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the interrupt mask for the specified DCHAN.  <a href="#ga167b14c57a2df68bbef49c29e23b7eaa">More...</a><br /></td></tr>
<tr class="separator:ga167b14c57a2df68bbef49c29e23b7eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaecf7fbae1fbb2e83ed08fb05682998f0"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__dsadc__interrupt__functions.html#gaecf7fbae1fbb2e83ed08fb05682998f0">Cy_DSADC_SetInterruptMask</a> (PACSS_DCHAN_Type *base, uint32_t intrMask)</td></tr>
<tr class="memdesc:gaecf7fbae1fbb2e83ed08fb05682998f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the specified interrupt for the specified DCHAN.  <a href="#gaecf7fbae1fbb2e83ed08fb05682998f0">More...</a><br /></td></tr>
<tr class="separator:gaecf7fbae1fbb2e83ed08fb05682998f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1aa41b63cf815ccb3f8224da4f1fa80c"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__dsadc__interrupt__functions.html#ga1aa41b63cf815ccb3f8224da4f1fa80c">Cy_DSADC_GetInterruptStatusMasked</a> (const PACSS_DCHAN_Type *base)</td></tr>
<tr class="memdesc:ga1aa41b63cf815ccb3f8224da4f1fa80c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the masked (enabled) interrupt status for the specified DCHAN.  <a href="#ga1aa41b63cf815ccb3f8224da4f1fa80c">More...</a><br /></td></tr>
<tr class="separator:ga1aa41b63cf815ccb3f8224da4f1fa80c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga26d1c0094ea3f352a320ee221fe153ad"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__dsadc__interrupt__functions.html#ga26d1c0094ea3f352a320ee221fe153ad">Cy_DSADC_GetInterruptCause</a> (const PACSS_MMIO_Type *base)</td></tr>
<tr class="memdesc:ga26d1c0094ea3f352a320ee221fe153ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the interrupt pending for each DCHAN or System interrupt pending.  <a href="#ga26d1c0094ea3f352a320ee221fe153ad">More...</a><br /></td></tr>
<tr class="separator:ga26d1c0094ea3f352a320ee221fe153ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c1f6be74d72f44626ab43f853d19945"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__dsadc__interrupt__functions.html#ga7c1f6be74d72f44626ab43f853d19945">Cy_DSADC_GetOverloadCause</a> (const PACSS_DCHAN_Type *base)</td></tr>
<tr class="memdesc:ga7c1f6be74d72f44626ab43f853d19945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the overload cause to check if the modulator output is all 0 or all 1.  <a href="#ga7c1f6be74d72f44626ab43f853d19945">More...</a><br /></td></tr>
<tr class="separator:ga7c1f6be74d72f44626ab43f853d19945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dd8f9a42a23df2020669234d8dc79b9"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__dsadc__interrupt__functions.html#ga3dd8f9a42a23df2020669234d8dc79b9">Cy_DSADC_AgcClearInterrupt</a> (PACSS_MMIO_Type *base)</td></tr>
<tr class="memdesc:ga3dd8f9a42a23df2020669234d8dc79b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the specified AGC MMIO interrupt.  <a href="#ga3dd8f9a42a23df2020669234d8dc79b9">More...</a><br /></td></tr>
<tr class="separator:ga3dd8f9a42a23df2020669234d8dc79b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15408dadc49537067af4f0477b28e500"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__dsadc__interrupt__functions.html#ga15408dadc49537067af4f0477b28e500">Cy_DSADC_AgcGetInterruptStatus</a> (PACSS_MMIO_Type *base)</td></tr>
<tr class="memdesc:ga15408dadc49537067af4f0477b28e500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the AGC MMIO interrupt status.  <a href="#ga15408dadc49537067af4f0477b28e500">More...</a><br /></td></tr>
<tr class="separator:ga15408dadc49537067af4f0477b28e500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae008d49e3cd7cf151a1c20e09ce03660"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__dsadc__interrupt__functions.html#gae008d49e3cd7cf151a1c20e09ce03660">Cy_DSADC_AgcSetInterrupt</a> (PACSS_MMIO_Type *base)</td></tr>
<tr class="memdesc:gae008d49e3cd7cf151a1c20e09ce03660"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write with '1' to set corresponding bit in interrupt request register.  <a href="#gae008d49e3cd7cf151a1c20e09ce03660">More...</a><br /></td></tr>
<tr class="separator:gae008d49e3cd7cf151a1c20e09ce03660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7c4c6b2b30f9ee1a0d12ac44b1afe16"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__dsadc__interrupt__functions.html#gaa7c4c6b2b30f9ee1a0d12ac44b1afe16">Cy_DSADC_AgcGetInterruptMask</a> (PACSS_MMIO_Type *base)</td></tr>
<tr class="memdesc:gaa7c4c6b2b30f9ee1a0d12ac44b1afe16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the AGC MMIO interrupt mask.  <a href="#gaa7c4c6b2b30f9ee1a0d12ac44b1afe16">More...</a><br /></td></tr>
<tr class="separator:gaa7c4c6b2b30f9ee1a0d12ac44b1afe16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c5dd320d240ddb6a0d7ab5d50f7500f"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__dsadc__interrupt__functions.html#ga7c5dd320d240ddb6a0d7ab5d50f7500f">Cy_DSADC_AgcSetInterruptMask</a> (PACSS_MMIO_Type *base)</td></tr>
<tr class="memdesc:ga7c5dd320d240ddb6a0d7ab5d50f7500f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the masked (enabled) MMIO interrupt status.  <a href="#ga7c5dd320d240ddb6a0d7ab5d50f7500f">More...</a><br /></td></tr>
<tr class="separator:ga7c5dd320d240ddb6a0d7ab5d50f7500f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadb575816b59de5a69c6c955f84fc3a60"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__dsadc__interrupt__functions.html#gadb575816b59de5a69c6c955f84fc3a60">Cy_DSADC_AgcGetInterruptStatusMasked</a> (PACSS_MMIO_Type *base)</td></tr>
<tr class="memdesc:gadb575816b59de5a69c6c955f84fc3a60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of the bitwise AND operation between the corresponding interrupt request and mask bits.  <a href="#gadb575816b59de5a69c6c955f84fc3a60">More...</a><br /></td></tr>
<tr class="separator:gadb575816b59de5a69c6c955f84fc3a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31a98bc5c94db0fc18a76648e41e1c9f"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__dsadc__interrupt__functions.html#ga31a98bc5c94db0fc18a76648e41e1c9f">Cy_DSADC_OcdClearInterrupt</a> (PACSS_MMIO_Type *base, uint32_t intrMask)</td></tr>
<tr class="memdesc:ga31a98bc5c94db0fc18a76648e41e1c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the specified OCD MMIO interrupt.  <a href="#ga31a98bc5c94db0fc18a76648e41e1c9f">More...</a><br /></td></tr>
<tr class="separator:ga31a98bc5c94db0fc18a76648e41e1c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaead06ad69e008773c0495fe4766c60dd"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__dsadc__interrupt__functions.html#gaead06ad69e008773c0495fe4766c60dd">Cy_DSADC_OcdGetInterruptStatus</a> (PACSS_MMIO_Type *base)</td></tr>
<tr class="memdesc:gaead06ad69e008773c0495fe4766c60dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the specified OCD MMIO interrupt status.  <a href="#gaead06ad69e008773c0495fe4766c60dd">More...</a><br /></td></tr>
<tr class="separator:gaead06ad69e008773c0495fe4766c60dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0dd9259be2661661c4b13ecfe8cc65eb"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__dsadc__interrupt__functions.html#ga0dd9259be2661661c4b13ecfe8cc65eb">Cy_DSADC_OcdSetInterrupt</a> (PACSS_MMIO_Type *base, uint32_t intrMask)</td></tr>
<tr class="memdesc:ga0dd9259be2661661c4b13ecfe8cc65eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write with '1' to set corresponding bit in interrupt request register.  <a href="#ga0dd9259be2661661c4b13ecfe8cc65eb">More...</a><br /></td></tr>
<tr class="separator:ga0dd9259be2661661c4b13ecfe8cc65eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad98cf6de393fab821f560edb77752113"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__dsadc__interrupt__functions.html#gad98cf6de393fab821f560edb77752113">Cy_DSADC_OcdGetInterruptMask</a> (PACSS_MMIO_Type *base)</td></tr>
<tr class="memdesc:gad98cf6de393fab821f560edb77752113"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the specified OCD MMIO interrupt mask.  <a href="#gad98cf6de393fab821f560edb77752113">More...</a><br /></td></tr>
<tr class="separator:gad98cf6de393fab821f560edb77752113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ee445e728b4cac35eb7b8d42fd19a0c"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__dsadc__interrupt__functions.html#ga3ee445e728b4cac35eb7b8d42fd19a0c">Cy_DSADC_OcdSetInterruptMask</a> (PACSS_MMIO_Type *base, uint32_t intrMask)</td></tr>
<tr class="memdesc:ga3ee445e728b4cac35eb7b8d42fd19a0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables the specified OCD MMIO interrupt mask.  <a href="#ga3ee445e728b4cac35eb7b8d42fd19a0c">More...</a><br /></td></tr>
<tr class="separator:ga3ee445e728b4cac35eb7b8d42fd19a0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa8b5af0680bb0d27aa1a664b6388fe0"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__dsadc__interrupt__functions.html#gafa8b5af0680bb0d27aa1a664b6388fe0">Cy_DSADC_OcdGetInterruptStatusMasked</a> (PACSS_MMIO_Type *base)</td></tr>
<tr class="memdesc:gafa8b5af0680bb0d27aa1a664b6388fe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the specified OCD MMIO interrupt masked (enabled) status.  <a href="#gafa8b5af0680bb0d27aa1a664b6388fe0">More...</a><br /></td></tr>
<tr class="separator:gafa8b5af0680bb0d27aa1a664b6388fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This set of functions are related to DSADC interrupts. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab73f0c19534e0fafd107e9cb8ccb71e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab73f0c19534e0fafd107e9cb8ccb71e2">&#9670;&nbsp;</a></span>Cy_DSADC_ClearInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_DSADC_ClearInterrupt </td>
          <td>(</td>
          <td class="paramtype">PACSS_DCHAN_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the specified interrupt for the specified DCHAN. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base address for the Digital Channel.</td></tr>
    <tr><td class="paramname">intrMask</td><td>The bitmask of statuses to clear. Select one or more values from <a class="el" href="group__group__dsadc__macros__interrupt.html">Interrupt Masks</a> and "OR" them together.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"><span class="comment">/* Interrupt handler. */</span></div><div class="line"><span class="keywordtype">void</span> DCHAN0_Isr(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    uint32_t intr_status, masked_status;</div><div class="line">    intr_status = <a class="code" href="group__group__dsadc__interrupt__functions.html#ga86ddc0c7094590530a554752ad793a94">Cy_DSADC_GetInterruptStatus</a>(PACSS_DCHAN0);</div><div class="line">    masked_status = <a class="code" href="group__group__dsadc__interrupt__functions.html#ga1aa41b63cf815ccb3f8224da4f1fa80c">Cy_DSADC_GetInterruptStatusMasked</a>(PACSS_DCHAN0);</div><div class="line">    <span class="comment">/* Check if interrupt occurs due to overload. */</span></div><div class="line">    <span class="keywordflow">if</span>(0 != (<a class="code" href="group__group__dsadc__macros__interrupt.html#ga43c3d1cb39e422862a97e605a3d0f58e">CY_DSADC_DCHAN_INTR_OVERLOAD</a> &amp; intr_status &amp; masked_status))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Check what cause overload. */</span></div><div class="line">        <span class="keywordflow">if</span>(0UL == <a class="code" href="group__group__dsadc__interrupt__functions.html#ga7c1f6be74d72f44626ab43f853d19945">Cy_DSADC_GetOverloadCause</a>(PACSS_DCHAN0))</div><div class="line">        {</div><div class="line">            <span class="comment">/* Overload is due to modulator output is all 0s. */</span></div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">            <span class="comment">/* Overload is due to modulator output is all 1s. */</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <span class="comment">/* Process unexpected behavior. */</span></div><div class="line">    }</div><div class="line">    <span class="comment">/* Clear all possible interrupt sources using combined interrupt mask. */</span></div><div class="line">    <a class="code" href="group__group__dsadc__interrupt__functions.html#gab73f0c19534e0fafd107e9cb8ccb71e2">Cy_DSADC_ClearInterrupt</a>(PACSS_DCHAN0, (uint32_t)(<a class="code" href="group__group__dsadc__macros__interrupt.html#ga55baf069a1d486555d2750e429a742f2">CY_DSADC_INTR_MASK</a>));</div><div class="line">}</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga86ddc0c7094590530a554752ad793a94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86ddc0c7094590530a554752ad793a94">&#9670;&nbsp;</a></span>Cy_DSADC_GetInterruptStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_DSADC_GetInterruptStatus </td>
          <td>(</td>
          <td class="paramtype">const PACSS_DCHAN_Type *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the interrupt status for the specified DCHAN. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base address for the Digital Channel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bitmask of interrupt statuses.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"><span class="comment">/* Interrupt handler. */</span></div><div class="line"><span class="keywordtype">void</span> DCHAN0_Isr(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    uint32_t intr_status, masked_status;</div><div class="line">    intr_status = <a class="code" href="group__group__dsadc__interrupt__functions.html#ga86ddc0c7094590530a554752ad793a94">Cy_DSADC_GetInterruptStatus</a>(PACSS_DCHAN0);</div><div class="line">    masked_status = <a class="code" href="group__group__dsadc__interrupt__functions.html#ga1aa41b63cf815ccb3f8224da4f1fa80c">Cy_DSADC_GetInterruptStatusMasked</a>(PACSS_DCHAN0);</div><div class="line">    <span class="comment">/* Check if interrupt occurs due to overload. */</span></div><div class="line">    <span class="keywordflow">if</span>(0 != (<a class="code" href="group__group__dsadc__macros__interrupt.html#ga43c3d1cb39e422862a97e605a3d0f58e">CY_DSADC_DCHAN_INTR_OVERLOAD</a> &amp; intr_status &amp; masked_status))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Check what cause overload. */</span></div><div class="line">        <span class="keywordflow">if</span>(0UL == <a class="code" href="group__group__dsadc__interrupt__functions.html#ga7c1f6be74d72f44626ab43f853d19945">Cy_DSADC_GetOverloadCause</a>(PACSS_DCHAN0))</div><div class="line">        {</div><div class="line">            <span class="comment">/* Overload is due to modulator output is all 0s. */</span></div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">            <span class="comment">/* Overload is due to modulator output is all 1s. */</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <span class="comment">/* Process unexpected behavior. */</span></div><div class="line">    }</div><div class="line">    <span class="comment">/* Clear all possible interrupt sources using combined interrupt mask. */</span></div><div class="line">    <a class="code" href="group__group__dsadc__interrupt__functions.html#gab73f0c19534e0fafd107e9cb8ccb71e2">Cy_DSADC_ClearInterrupt</a>(PACSS_DCHAN0, (uint32_t)(<a class="code" href="group__group__dsadc__macros__interrupt.html#ga55baf069a1d486555d2750e429a742f2">CY_DSADC_INTR_MASK</a>));</div><div class="line">}</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="gab30cb11deb2a3e788dcf45ba96137772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab30cb11deb2a3e788dcf45ba96137772">&#9670;&nbsp;</a></span>Cy_DSADC_SetInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_DSADC_SetInterrupt </td>
          <td>(</td>
          <td class="paramtype">PACSS_DCHAN_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the interrupt source to check if HW operates correctly or to use it as a SW interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base address for the Digital Channel.</td></tr>
    <tr><td class="paramname">intrMask</td><td>The bit field determines which interrupt will be triggered. Select one or more values from <a class="el" href="group__group__dsadc__macros__interrupt.html">Interrupt Masks</a> and "OR" them together.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: Set interrupt for overload. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Hook interrupt service routine. */</span></div><div class="line">    (void) <a class="code" href="group__group__sysint__functions.html#gab2ff6820a898e9af3f780000054eea5d">Cy_SysInt_Init</a>(&amp;DCHAN0IntrConfig, &amp;DCHAN0_Isr);</div><div class="line"></div><div class="line">    uint32_t intrMask;</div><div class="line">    intrMask = <a class="code" href="group__group__dsadc__interrupt__functions.html#ga167b14c57a2df68bbef49c29e23b7eaa">Cy_DSADC_GetInterruptMask</a>(PACSS_DCHAN0);</div><div class="line">    <span class="comment">/* Check whether overload interrupt source is enabled. */</span></div><div class="line">    <span class="keywordflow">if</span> ((uint32_t) <a class="code" href="group__group__dsadc__macros__interrupt.html#ga43c3d1cb39e422862a97e605a3d0f58e">CY_DSADC_DCHAN_INTR_OVERLOAD</a> != (intrMask &amp; (uint32_t)<a class="code" href="group__group__dsadc__macros__interrupt.html#ga43c3d1cb39e422862a97e605a3d0f58e">CY_DSADC_DCHAN_INTR_OVERLOAD</a>))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Enable overload interrupt. */</span></div><div class="line">        <a class="code" href="group__group__dsadc__interrupt__functions.html#gaecf7fbae1fbb2e83ed08fb05682998f0">Cy_DSADC_SetInterruptMask</a>(PACSS_DCHAN0, (uint32_t)CY_DSADC_DCHAN_INTR_OVERLOAD);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Enable interrupt for interrupt controller. */</span></div><div class="line">    NVIC_EnableIRQ(DCHAN0IntrConfig.intrSrc);</div><div class="line"></div><div class="line">    <span class="comment">/* Set overload interrupt. */</span></div><div class="line">    <a class="code" href="group__group__dsadc__interrupt__functions.html#gab30cb11deb2a3e788dcf45ba96137772">Cy_DSADC_SetInterrupt</a>(PACSS_DCHAN0, (uint32_t)(CY_DSADC_DCHAN_INTR_OVERLOAD));</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga167b14c57a2df68bbef49c29e23b7eaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga167b14c57a2df68bbef49c29e23b7eaa">&#9670;&nbsp;</a></span>Cy_DSADC_GetInterruptMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_DSADC_GetInterruptMask </td>
          <td>(</td>
          <td class="paramtype">const PACSS_DCHAN_Type *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the interrupt mask for the specified DCHAN. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base address for the Digital Channel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bit field determines which status changes can cause an interrupt.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: Set interrupt for overload. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Hook interrupt service routine. */</span></div><div class="line">    (void) <a class="code" href="group__group__sysint__functions.html#gab2ff6820a898e9af3f780000054eea5d">Cy_SysInt_Init</a>(&amp;DCHAN0IntrConfig, &amp;DCHAN0_Isr);</div><div class="line"></div><div class="line">    uint32_t intrMask;</div><div class="line">    intrMask = <a class="code" href="group__group__dsadc__interrupt__functions.html#ga167b14c57a2df68bbef49c29e23b7eaa">Cy_DSADC_GetInterruptMask</a>(PACSS_DCHAN0);</div><div class="line">    <span class="comment">/* Check whether overload interrupt source is enabled. */</span></div><div class="line">    <span class="keywordflow">if</span> ((uint32_t) CY_DSADC_DCHAN_INTR_OVERLOAD != (intrMask &amp; (uint32_t)CY_DSADC_DCHAN_INTR_OVERLOAD))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Enable overload interrupt. */</span></div><div class="line">        <a class="code" href="group__group__dsadc__interrupt__functions.html#gaecf7fbae1fbb2e83ed08fb05682998f0">Cy_DSADC_SetInterruptMask</a>(PACSS_DCHAN0, (uint32_t)CY_DSADC_DCHAN_INTR_OVERLOAD);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Enable interrupt for interrupt controller. */</span></div><div class="line">    NVIC_EnableIRQ(DCHAN0IntrConfig.intrSrc);</div><div class="line"></div><div class="line">    <span class="comment">/* Set overload interrupt. */</span></div><div class="line">    <a class="code" href="group__group__dsadc__interrupt__functions.html#gab30cb11deb2a3e788dcf45ba96137772">Cy_DSADC_SetInterrupt</a>(PACSS_DCHAN0, (uint32_t)(CY_DSADC_DCHAN_INTR_OVERLOAD));</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="gaecf7fbae1fbb2e83ed08fb05682998f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaecf7fbae1fbb2e83ed08fb05682998f0">&#9670;&nbsp;</a></span>Cy_DSADC_SetInterruptMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_DSADC_SetInterruptMask </td>
          <td>(</td>
          <td class="paramtype">PACSS_DCHAN_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the specified interrupt for the specified DCHAN. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base address for the Digital Channel.</td></tr>
    <tr><td class="paramname">intrMask</td><td>The bit field determines which status changes can cause an interrupt. Select one or more values from <a class="el" href="group__group__dsadc__macros__interrupt.html">Interrupt Masks</a> and "OR" them together.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: Set interrupt for overload. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Hook interrupt service routine. */</span></div><div class="line">    (void) <a class="code" href="group__group__sysint__functions.html#gab2ff6820a898e9af3f780000054eea5d">Cy_SysInt_Init</a>(&amp;DCHAN0IntrConfig, &amp;DCHAN0_Isr);</div><div class="line"></div><div class="line">    uint32_t intrMask;</div><div class="line">    intrMask = <a class="code" href="group__group__dsadc__interrupt__functions.html#ga167b14c57a2df68bbef49c29e23b7eaa">Cy_DSADC_GetInterruptMask</a>(PACSS_DCHAN0);</div><div class="line">    <span class="comment">/* Check whether overload interrupt source is enabled. */</span></div><div class="line">    <span class="keywordflow">if</span> ((uint32_t) CY_DSADC_DCHAN_INTR_OVERLOAD != (intrMask &amp; (uint32_t)CY_DSADC_DCHAN_INTR_OVERLOAD))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Enable overload interrupt. */</span></div><div class="line">        <a class="code" href="group__group__dsadc__interrupt__functions.html#gaecf7fbae1fbb2e83ed08fb05682998f0">Cy_DSADC_SetInterruptMask</a>(PACSS_DCHAN0, (uint32_t)CY_DSADC_DCHAN_INTR_OVERLOAD);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Enable interrupt for interrupt controller. */</span></div><div class="line">    NVIC_EnableIRQ(DCHAN0IntrConfig.intrSrc);</div><div class="line"></div><div class="line">    <span class="comment">/* Set overload interrupt. */</span></div><div class="line">    <a class="code" href="group__group__dsadc__interrupt__functions.html#gab30cb11deb2a3e788dcf45ba96137772">Cy_DSADC_SetInterrupt</a>(PACSS_DCHAN0, (uint32_t)(CY_DSADC_DCHAN_INTR_OVERLOAD));</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga1aa41b63cf815ccb3f8224da4f1fa80c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1aa41b63cf815ccb3f8224da4f1fa80c">&#9670;&nbsp;</a></span>Cy_DSADC_GetInterruptStatusMasked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_DSADC_GetInterruptStatusMasked </td>
          <td>(</td>
          <td class="paramtype">const PACSS_DCHAN_Type *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the masked (enabled) interrupt status for the specified DCHAN. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base address for the Digital Channel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bitwise AND of the interrupt request and mask registers.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"><span class="comment">/* Interrupt handler. */</span></div><div class="line"><span class="keywordtype">void</span> DCHAN0_Isr(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    uint32_t intr_status, masked_status;</div><div class="line">    intr_status = <a class="code" href="group__group__dsadc__interrupt__functions.html#ga86ddc0c7094590530a554752ad793a94">Cy_DSADC_GetInterruptStatus</a>(PACSS_DCHAN0);</div><div class="line">    masked_status = <a class="code" href="group__group__dsadc__interrupt__functions.html#ga1aa41b63cf815ccb3f8224da4f1fa80c">Cy_DSADC_GetInterruptStatusMasked</a>(PACSS_DCHAN0);</div><div class="line">    <span class="comment">/* Check if interrupt occurs due to overload. */</span></div><div class="line">    <span class="keywordflow">if</span>(0 != (CY_DSADC_DCHAN_INTR_OVERLOAD &amp; intr_status &amp; masked_status))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Check what cause overload. */</span></div><div class="line">        <span class="keywordflow">if</span>(0UL == <a class="code" href="group__group__dsadc__interrupt__functions.html#ga7c1f6be74d72f44626ab43f853d19945">Cy_DSADC_GetOverloadCause</a>(PACSS_DCHAN0))</div><div class="line">        {</div><div class="line">            <span class="comment">/* Overload is due to modulator output is all 0s. */</span></div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">            <span class="comment">/* Overload is due to modulator output is all 1s. */</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <span class="comment">/* Process unexpected behavior. */</span></div><div class="line">    }</div><div class="line">    <span class="comment">/* Clear all possible interrupt sources using combined interrupt mask. */</span></div><div class="line">    <a class="code" href="group__group__dsadc__interrupt__functions.html#gab73f0c19534e0fafd107e9cb8ccb71e2">Cy_DSADC_ClearInterrupt</a>(PACSS_DCHAN0, (uint32_t)(<a class="code" href="group__group__dsadc__macros__interrupt.html#ga55baf069a1d486555d2750e429a742f2">CY_DSADC_INTR_MASK</a>));</div><div class="line">}</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga26d1c0094ea3f352a320ee221fe153ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga26d1c0094ea3f352a320ee221fe153ad">&#9670;&nbsp;</a></span>Cy_DSADC_GetInterruptCause()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_DSADC_GetInterruptCause </td>
          <td>(</td>
          <td class="paramtype">const PACSS_MMIO_Type *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the interrupt pending for each DCHAN or System interrupt pending. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the MMIO instance of the PACSS.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bit field determines which DCHAN or System interrupt pending cause an interrupt. See <a class="el" href="group__group__dsadc__cause__macros__interrupt.html">Interrupt Cause Masks</a></dd></dl>
<table class="doxtable">
<tr>
<th>Name </th><th>Value  </th></tr>
<tr>
<td>CY_DSADC_MMIO_INTR_CAUSE_DCH0 </td><td>0x00000001UL (bit0) </td></tr>
<tr>
<td>CY_DSADC_MMIO_INTR_CAUSE_DCH1 </td><td>0x00000002UL (bit1) </td></tr>
<tr>
<td>CY_DSADC_MMIO_INTR_CAUSE_DCH2 </td><td>0x00000004UL (bit2) </td></tr>
<tr>
<td>CY_DSADC_MMIO_INTR_CAUSE_DCH3 </td><td>0x00000008UL (bit3) </td></tr>
<tr>
<td>CY_DSADC_MMIO_INTR_CAUSE_PACSS</td><td>0x00000010UL (bit4) </td></tr>
</table>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: After an MMIO interrupt occurs check the cause of the interrupt in an ISR handler. */</span></div><div class="line">    uint32_t status;</div><div class="line">    status = <a class="code" href="group__group__dsadc__interrupt__functions.html#ga26d1c0094ea3f352a320ee221fe153ad">Cy_DSADC_GetInterruptCause</a>(PACSS_MMIO);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span>(<a class="code" href="group__group__dsadc__cause__macros__interrupt.html#gad9fb68befc8112ea1cb3579a16f82d9b">CY_DSADC_MMIO_INTR_CAUSE_DCH0</a> == (status &amp; <a class="code" href="group__group__dsadc__cause__macros__interrupt.html#gad9fb68befc8112ea1cb3579a16f82d9b">CY_DSADC_MMIO_INTR_CAUSE_DCH0</a>))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Process interrupt. */</span></div><div class="line">    }</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga7c1f6be74d72f44626ab43f853d19945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c1f6be74d72f44626ab43f853d19945">&#9670;&nbsp;</a></span>Cy_DSADC_GetOverloadCause()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_DSADC_GetOverloadCause </td>
          <td>(</td>
          <td class="paramtype">const PACSS_DCHAN_Type *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the overload cause to check if the modulator output is all 0 or all 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base address for the Digital Channel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Get the overload cause value.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>To be read after overload interrupt issues. If read returns 0, overload is due to all 0s. If read returns 1, overload is due to all 1s.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"><span class="comment">/* Interrupt handler. */</span></div><div class="line"><span class="keywordtype">void</span> DCHAN0_Isr(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    uint32_t intr_status, masked_status;</div><div class="line">    intr_status = <a class="code" href="group__group__dsadc__interrupt__functions.html#ga86ddc0c7094590530a554752ad793a94">Cy_DSADC_GetInterruptStatus</a>(PACSS_DCHAN0);</div><div class="line">    masked_status = <a class="code" href="group__group__dsadc__interrupt__functions.html#ga1aa41b63cf815ccb3f8224da4f1fa80c">Cy_DSADC_GetInterruptStatusMasked</a>(PACSS_DCHAN0);</div><div class="line">    <span class="comment">/* Check if interrupt occurs due to overload. */</span></div><div class="line">    <span class="keywordflow">if</span>(0 != (CY_DSADC_DCHAN_INTR_OVERLOAD &amp; intr_status &amp; masked_status))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Check what cause overload. */</span></div><div class="line">        <span class="keywordflow">if</span>(0UL == <a class="code" href="group__group__dsadc__interrupt__functions.html#ga7c1f6be74d72f44626ab43f853d19945">Cy_DSADC_GetOverloadCause</a>(PACSS_DCHAN0))</div><div class="line">        {</div><div class="line">            <span class="comment">/* Overload is due to modulator output is all 0s. */</span></div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">            <span class="comment">/* Overload is due to modulator output is all 1s. */</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <span class="comment">/* Process unexpected behavior. */</span></div><div class="line">    }</div><div class="line">    <span class="comment">/* Clear all possible interrupt sources using combined interrupt mask. */</span></div><div class="line">    <a class="code" href="group__group__dsadc__interrupt__functions.html#gab73f0c19534e0fafd107e9cb8ccb71e2">Cy_DSADC_ClearInterrupt</a>(PACSS_DCHAN0, (uint32_t)(<a class="code" href="group__group__dsadc__macros__interrupt.html#ga55baf069a1d486555d2750e429a742f2">CY_DSADC_INTR_MASK</a>));</div><div class="line">}</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga3dd8f9a42a23df2020669234d8dc79b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3dd8f9a42a23df2020669234d8dc79b9">&#9670;&nbsp;</a></span>Cy_DSADC_AgcClearInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_DSADC_AgcClearInterrupt </td>
          <td>(</td>
          <td class="paramtype">PACSS_MMIO_Type *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the specified AGC MMIO interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the MMIO instance of the PACSS.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"><span class="comment">/* Interrupt handler. */</span></div><div class="line"><span class="keywordtype">void</span> AGC_Isr(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="keywordtype">bool</span> intr_status, masked_status;</div><div class="line">    intr_status = <a class="code" href="group__group__dsadc__interrupt__functions.html#ga15408dadc49537067af4f0477b28e500">Cy_DSADC_AgcGetInterruptStatus</a>(PACSS_MMIO);</div><div class="line">    masked_status = <a class="code" href="group__group__dsadc__interrupt__functions.html#gadb575816b59de5a69c6c955f84fc3a60">Cy_DSADC_AgcGetInterruptStatusMasked</a>(PACSS_MMIO);</div><div class="line">    <span class="comment">/* Check if interrupt occurs due to AGC. */</span></div><div class="line">    <span class="keywordflow">if</span>(<span class="keyword">false</span> != (intr_status &amp;&amp; masked_status))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Process interrupt. */</span></div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <span class="comment">/* Process unexpected behavior. */</span></div><div class="line">    }</div><div class="line">    <span class="comment">/* Clear AGC interrupt. */</span></div><div class="line">    <a class="code" href="group__group__dsadc__interrupt__functions.html#ga3dd8f9a42a23df2020669234d8dc79b9">Cy_DSADC_AgcClearInterrupt</a>(PACSS_MMIO);</div><div class="line">}</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga15408dadc49537067af4f0477b28e500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15408dadc49537067af4f0477b28e500">&#9670;&nbsp;</a></span>Cy_DSADC_AgcGetInterruptStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool Cy_DSADC_AgcGetInterruptStatus </td>
          <td>(</td>
          <td class="paramtype">PACSS_MMIO_Type *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the AGC MMIO interrupt status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the MMIO instance of the PACSS.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Interrupt status.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"><span class="comment">/* Interrupt handler. */</span></div><div class="line"><span class="keywordtype">void</span> AGC_Isr(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="keywordtype">bool</span> intr_status, masked_status;</div><div class="line">    intr_status = <a class="code" href="group__group__dsadc__interrupt__functions.html#ga15408dadc49537067af4f0477b28e500">Cy_DSADC_AgcGetInterruptStatus</a>(PACSS_MMIO);</div><div class="line">    masked_status = <a class="code" href="group__group__dsadc__interrupt__functions.html#gadb575816b59de5a69c6c955f84fc3a60">Cy_DSADC_AgcGetInterruptStatusMasked</a>(PACSS_MMIO);</div><div class="line">    <span class="comment">/* Check if interrupt occurs due to AGC. */</span></div><div class="line">    <span class="keywordflow">if</span>(<span class="keyword">false</span> != (intr_status &amp;&amp; masked_status))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Process interrupt. */</span></div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <span class="comment">/* Process unexpected behavior. */</span></div><div class="line">    }</div><div class="line">    <span class="comment">/* Clear AGC interrupt. */</span></div><div class="line">    <a class="code" href="group__group__dsadc__interrupt__functions.html#ga3dd8f9a42a23df2020669234d8dc79b9">Cy_DSADC_AgcClearInterrupt</a>(PACSS_MMIO);</div><div class="line">}</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="gae008d49e3cd7cf151a1c20e09ce03660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae008d49e3cd7cf151a1c20e09ce03660">&#9670;&nbsp;</a></span>Cy_DSADC_AgcSetInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_DSADC_AgcSetInterrupt </td>
          <td>(</td>
          <td class="paramtype">PACSS_MMIO_Type *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write with '1' to set corresponding bit in interrupt request register. </p>
<p>Can be used to set interrupts for firmware testing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the MMIO instance of the PACSS.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: Set interrupt for agc. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Hook interrupt service routine. */</span></div><div class="line">    (void) <a class="code" href="group__group__sysint__functions.html#gab2ff6820a898e9af3f780000054eea5d">Cy_SysInt_Init</a>(&amp;AgcIntrConfig, &amp;AGC_Isr);</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> intrMask;</div><div class="line">    intrMask = <a class="code" href="group__group__dsadc__interrupt__functions.html#gaa7c4c6b2b30f9ee1a0d12ac44b1afe16">Cy_DSADC_AgcGetInterruptMask</a>(PACSS_MMIO);</div><div class="line">    <span class="comment">/* Check whether agc interrupt source is enabled. */</span></div><div class="line">    <span class="keywordflow">if</span> (<span class="keyword">true</span> != intrMask)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Enable AGC interrupt. */</span></div><div class="line">        <a class="code" href="group__group__dsadc__interrupt__functions.html#ga7c5dd320d240ddb6a0d7ab5d50f7500f">Cy_DSADC_AgcSetInterruptMask</a>(PACSS_MMIO);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Enable interrupt for interrupt controller. */</span></div><div class="line">    NVIC_EnableIRQ(AgcIntrConfig.intrSrc);</div><div class="line"></div><div class="line">    <span class="comment">/* Set AGC interrupt. */</span></div><div class="line">    <a class="code" href="group__group__dsadc__interrupt__functions.html#gae008d49e3cd7cf151a1c20e09ce03660">Cy_DSADC_AgcSetInterrupt</a>(PACSS_MMIO);</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="gaa7c4c6b2b30f9ee1a0d12ac44b1afe16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7c4c6b2b30f9ee1a0d12ac44b1afe16">&#9670;&nbsp;</a></span>Cy_DSADC_AgcGetInterruptMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool Cy_DSADC_AgcGetInterruptMask </td>
          <td>(</td>
          <td class="paramtype">PACSS_MMIO_Type *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the AGC MMIO interrupt mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the MMIO instance of the PACSS.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The mask interrupt status.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: Set interrupt for agc. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Hook interrupt service routine. */</span></div><div class="line">    (void) <a class="code" href="group__group__sysint__functions.html#gab2ff6820a898e9af3f780000054eea5d">Cy_SysInt_Init</a>(&amp;AgcIntrConfig, &amp;AGC_Isr);</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> intrMask;</div><div class="line">    intrMask = <a class="code" href="group__group__dsadc__interrupt__functions.html#gaa7c4c6b2b30f9ee1a0d12ac44b1afe16">Cy_DSADC_AgcGetInterruptMask</a>(PACSS_MMIO);</div><div class="line">    <span class="comment">/* Check whether agc interrupt source is enabled. */</span></div><div class="line">    <span class="keywordflow">if</span> (<span class="keyword">true</span> != intrMask)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Enable AGC interrupt. */</span></div><div class="line">        <a class="code" href="group__group__dsadc__interrupt__functions.html#ga7c5dd320d240ddb6a0d7ab5d50f7500f">Cy_DSADC_AgcSetInterruptMask</a>(PACSS_MMIO);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Enable interrupt for interrupt controller. */</span></div><div class="line">    NVIC_EnableIRQ(AgcIntrConfig.intrSrc);</div><div class="line"></div><div class="line">    <span class="comment">/* Set AGC interrupt. */</span></div><div class="line">    <a class="code" href="group__group__dsadc__interrupt__functions.html#gae008d49e3cd7cf151a1c20e09ce03660">Cy_DSADC_AgcSetInterrupt</a>(PACSS_MMIO);</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga7c5dd320d240ddb6a0d7ab5d50f7500f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c5dd320d240ddb6a0d7ab5d50f7500f">&#9670;&nbsp;</a></span>Cy_DSADC_AgcSetInterruptMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_DSADC_AgcSetInterruptMask </td>
          <td>(</td>
          <td class="paramtype">PACSS_MMIO_Type *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the masked (enabled) MMIO interrupt status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the MMIO instance of the PACSS.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: Set interrupt for agc. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Hook interrupt service routine. */</span></div><div class="line">    (void) <a class="code" href="group__group__sysint__functions.html#gab2ff6820a898e9af3f780000054eea5d">Cy_SysInt_Init</a>(&amp;AgcIntrConfig, &amp;AGC_Isr);</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> intrMask;</div><div class="line">    intrMask = <a class="code" href="group__group__dsadc__interrupt__functions.html#gaa7c4c6b2b30f9ee1a0d12ac44b1afe16">Cy_DSADC_AgcGetInterruptMask</a>(PACSS_MMIO);</div><div class="line">    <span class="comment">/* Check whether agc interrupt source is enabled. */</span></div><div class="line">    <span class="keywordflow">if</span> (<span class="keyword">true</span> != intrMask)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Enable AGC interrupt. */</span></div><div class="line">        <a class="code" href="group__group__dsadc__interrupt__functions.html#ga7c5dd320d240ddb6a0d7ab5d50f7500f">Cy_DSADC_AgcSetInterruptMask</a>(PACSS_MMIO);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Enable interrupt for interrupt controller. */</span></div><div class="line">    NVIC_EnableIRQ(AgcIntrConfig.intrSrc);</div><div class="line"></div><div class="line">    <span class="comment">/* Set AGC interrupt. */</span></div><div class="line">    <a class="code" href="group__group__dsadc__interrupt__functions.html#gae008d49e3cd7cf151a1c20e09ce03660">Cy_DSADC_AgcSetInterrupt</a>(PACSS_MMIO);</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="gadb575816b59de5a69c6c955f84fc3a60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb575816b59de5a69c6c955f84fc3a60">&#9670;&nbsp;</a></span>Cy_DSADC_AgcGetInterruptStatusMasked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool Cy_DSADC_AgcGetInterruptStatusMasked </td>
          <td>(</td>
          <td class="paramtype">PACSS_MMIO_Type *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the result of the bitwise AND operation between the corresponding interrupt request and mask bits. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the MMIO instance of the PACSS.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The masked interrupt status. true : Masked interrupt occurs. false : No Masked interrupt occurs.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"><span class="comment">/* Interrupt handler. */</span></div><div class="line"><span class="keywordtype">void</span> AGC_Isr(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="keywordtype">bool</span> intr_status, masked_status;</div><div class="line">    intr_status = <a class="code" href="group__group__dsadc__interrupt__functions.html#ga15408dadc49537067af4f0477b28e500">Cy_DSADC_AgcGetInterruptStatus</a>(PACSS_MMIO);</div><div class="line">    masked_status = <a class="code" href="group__group__dsadc__interrupt__functions.html#gadb575816b59de5a69c6c955f84fc3a60">Cy_DSADC_AgcGetInterruptStatusMasked</a>(PACSS_MMIO);</div><div class="line">    <span class="comment">/* Check if interrupt occurs due to AGC. */</span></div><div class="line">    <span class="keywordflow">if</span>(<span class="keyword">false</span> != (intr_status &amp;&amp; masked_status))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Process interrupt. */</span></div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <span class="comment">/* Process unexpected behavior. */</span></div><div class="line">    }</div><div class="line">    <span class="comment">/* Clear AGC interrupt. */</span></div><div class="line">    <a class="code" href="group__group__dsadc__interrupt__functions.html#ga3dd8f9a42a23df2020669234d8dc79b9">Cy_DSADC_AgcClearInterrupt</a>(PACSS_MMIO);</div><div class="line">}</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga31a98bc5c94db0fc18a76648e41e1c9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31a98bc5c94db0fc18a76648e41e1c9f">&#9670;&nbsp;</a></span>Cy_DSADC_OcdClearInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_DSADC_OcdClearInterrupt </td>
          <td>(</td>
          <td class="paramtype">PACSS_MMIO_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the specified OCD MMIO interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the MMIO instance of the PACSS.</td></tr>
    <tr><td class="paramname">intrMask</td><td>The bitmask of statuses to clear. Select one or more values from <a class="el" href="group__group__dsadc__ocd__macros__interrupt.html">Interrupt OCD Masks</a> and "OR" them together.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"><span class="comment">/* Interrupt handler. */</span></div><div class="line"><span class="keywordtype">void</span> OCD_Isr(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    uint32_t intr_status = <a class="code" href="group__group__dsadc__interrupt__functions.html#gaead06ad69e008773c0495fe4766c60dd">Cy_DSADC_OcdGetInterruptStatus</a>(PACSS_MMIO);</div><div class="line">    uint32_t masked_status = <a class="code" href="group__group__dsadc__interrupt__functions.html#gafa8b5af0680bb0d27aa1a664b6388fe0">Cy_DSADC_OcdGetInterruptStatusMasked</a>(PACSS_MMIO);</div><div class="line"></div><div class="line">    <span class="comment">/* Check if interrupt occurs due to overcurrent. */</span></div><div class="line">    <span class="keywordflow">if</span>(0UL != (<a class="code" href="group__group__dsadc__ocd__macros__interrupt.html#gabb19f6df2af53c6276a844d69e7b68ad">CY_DSADC_OCD0_INTR_TRIGGER</a> &amp; intr_status &amp; masked_status))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Process interrupt. */</span></div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <span class="comment">/* Process unexpected behavior. */</span></div><div class="line">    }</div><div class="line">    <span class="comment">/* Clear all possible interrupt sources using combined interrupt mask. */</span></div><div class="line">    <a class="code" href="group__group__dsadc__interrupt__functions.html#ga31a98bc5c94db0fc18a76648e41e1c9f">Cy_DSADC_OcdClearInterrupt</a>(PACSS_MMIO, <a class="code" href="group__group__dsadc__ocd__macros__interrupt.html#gaf1efbcee52cae30b35264b1e68f55846">CY_DSADC_OCD_INTR_MASK</a>);</div><div class="line">}</div></div><!-- fragment --> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Not applicable for PSOC4 HVPA. </dd></dl>

</div>
</div>
<a id="gaead06ad69e008773c0495fe4766c60dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaead06ad69e008773c0495fe4766c60dd">&#9670;&nbsp;</a></span>Cy_DSADC_OcdGetInterruptStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_DSADC_OcdGetInterruptStatus </td>
          <td>(</td>
          <td class="paramtype">PACSS_MMIO_Type *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the specified OCD MMIO interrupt status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the MMIO instance of the PACSS.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bit field determines which ocd interrupt is set. To find out occured interrupt, use <a class="el" href="group__group__dsadc__ocd__macros__interrupt.html">Interrupt OCD Masks</a>.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"><span class="comment">/* Interrupt handler. */</span></div><div class="line"><span class="keywordtype">void</span> OCD_Isr(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    uint32_t intr_status = <a class="code" href="group__group__dsadc__interrupt__functions.html#gaead06ad69e008773c0495fe4766c60dd">Cy_DSADC_OcdGetInterruptStatus</a>(PACSS_MMIO);</div><div class="line">    uint32_t masked_status = <a class="code" href="group__group__dsadc__interrupt__functions.html#gafa8b5af0680bb0d27aa1a664b6388fe0">Cy_DSADC_OcdGetInterruptStatusMasked</a>(PACSS_MMIO);</div><div class="line"></div><div class="line">    <span class="comment">/* Check if interrupt occurs due to overcurrent. */</span></div><div class="line">    <span class="keywordflow">if</span>(0UL != (<a class="code" href="group__group__dsadc__ocd__macros__interrupt.html#gabb19f6df2af53c6276a844d69e7b68ad">CY_DSADC_OCD0_INTR_TRIGGER</a> &amp; intr_status &amp; masked_status))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Process interrupt. */</span></div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <span class="comment">/* Process unexpected behavior. */</span></div><div class="line">    }</div><div class="line">    <span class="comment">/* Clear all possible interrupt sources using combined interrupt mask. */</span></div><div class="line">    <a class="code" href="group__group__dsadc__interrupt__functions.html#ga31a98bc5c94db0fc18a76648e41e1c9f">Cy_DSADC_OcdClearInterrupt</a>(PACSS_MMIO, <a class="code" href="group__group__dsadc__ocd__macros__interrupt.html#gaf1efbcee52cae30b35264b1e68f55846">CY_DSADC_OCD_INTR_MASK</a>);</div><div class="line">}</div></div><!-- fragment --> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Not applicable for PSOC4 HVPA. </dd></dl>

</div>
</div>
<a id="ga0dd9259be2661661c4b13ecfe8cc65eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0dd9259be2661661c4b13ecfe8cc65eb">&#9670;&nbsp;</a></span>Cy_DSADC_OcdSetInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_DSADC_OcdSetInterrupt </td>
          <td>(</td>
          <td class="paramtype">PACSS_MMIO_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write with '1' to set corresponding bit in interrupt request register. </p>
<p>Can be used to set interrupts for firmware testing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the MMIO instance of the PACSS.</td></tr>
    <tr><td class="paramname">intrMask</td><td>The bit field determines which interrupt will be triggered. Select one or more values from <a class="el" href="group__group__dsadc__ocd__macros__interrupt.html">Interrupt OCD Masks</a> and "OR" them together.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: Set interrupt to simulate overcurrent. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Hook interrupt service routine. */</span></div><div class="line">    (void) <a class="code" href="group__group__sysint__functions.html#gab2ff6820a898e9af3f780000054eea5d">Cy_SysInt_Init</a>(&amp;OCDIntrConfig, &amp;OCD_Isr);</div><div class="line"></div><div class="line">    uint32_t intrMask = <a class="code" href="group__group__dsadc__interrupt__functions.html#gad98cf6de393fab821f560edb77752113">Cy_DSADC_OcdGetInterruptMask</a>(PACSS_MMIO);</div><div class="line">    <span class="comment">/* Check whether trigger interrupt source is enabled. */</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__dsadc__ocd__macros__interrupt.html#gabb19f6df2af53c6276a844d69e7b68ad">CY_DSADC_OCD0_INTR_TRIGGER</a> != (intrMask &amp; <a class="code" href="group__group__dsadc__ocd__macros__interrupt.html#gabb19f6df2af53c6276a844d69e7b68ad">CY_DSADC_OCD0_INTR_TRIGGER</a>))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Enable trigger interrupt. */</span></div><div class="line">        <a class="code" href="group__group__dsadc__interrupt__functions.html#ga3ee445e728b4cac35eb7b8d42fd19a0c">Cy_DSADC_OcdSetInterruptMask</a>(PACSS_MMIO, CY_DSADC_OCD0_INTR_TRIGGER);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Enable interrupt for interrupt controller. */</span></div><div class="line">    NVIC_EnableIRQ(OCDIntrConfig.intrSrc);</div><div class="line"></div><div class="line">    <span class="comment">/* Set trigger interrupt. */</span></div><div class="line">    <a class="code" href="group__group__dsadc__interrupt__functions.html#ga0dd9259be2661661c4b13ecfe8cc65eb">Cy_DSADC_OcdSetInterrupt</a>(PACSS_MMIO, CY_DSADC_OCD0_INTR_TRIGGER);</div></div><!-- fragment --> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Not applicable for PSOC4 HVPA. </dd></dl>

</div>
</div>
<a id="gad98cf6de393fab821f560edb77752113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad98cf6de393fab821f560edb77752113">&#9670;&nbsp;</a></span>Cy_DSADC_OcdGetInterruptMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_DSADC_OcdGetInterruptMask </td>
          <td>(</td>
          <td class="paramtype">PACSS_MMIO_Type *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the specified OCD MMIO interrupt mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the MMIO instance of the PACSS.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bit field determines which status changes can cause an interrupt. To find out wich interrupts are enabled, use <a class="el" href="group__group__dsadc__ocd__macros__interrupt.html">Interrupt OCD Masks</a>.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: Set interrupt to simulate overcurrent. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Hook interrupt service routine. */</span></div><div class="line">    (void) <a class="code" href="group__group__sysint__functions.html#gab2ff6820a898e9af3f780000054eea5d">Cy_SysInt_Init</a>(&amp;OCDIntrConfig, &amp;OCD_Isr);</div><div class="line"></div><div class="line">    uint32_t intrMask = <a class="code" href="group__group__dsadc__interrupt__functions.html#gad98cf6de393fab821f560edb77752113">Cy_DSADC_OcdGetInterruptMask</a>(PACSS_MMIO);</div><div class="line">    <span class="comment">/* Check whether trigger interrupt source is enabled. */</span></div><div class="line">    <span class="keywordflow">if</span> (CY_DSADC_OCD0_INTR_TRIGGER != (intrMask &amp; CY_DSADC_OCD0_INTR_TRIGGER))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Enable trigger interrupt. */</span></div><div class="line">        <a class="code" href="group__group__dsadc__interrupt__functions.html#ga3ee445e728b4cac35eb7b8d42fd19a0c">Cy_DSADC_OcdSetInterruptMask</a>(PACSS_MMIO, CY_DSADC_OCD0_INTR_TRIGGER);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Enable interrupt for interrupt controller. */</span></div><div class="line">    NVIC_EnableIRQ(OCDIntrConfig.intrSrc);</div><div class="line"></div><div class="line">    <span class="comment">/* Set trigger interrupt. */</span></div><div class="line">    <a class="code" href="group__group__dsadc__interrupt__functions.html#ga0dd9259be2661661c4b13ecfe8cc65eb">Cy_DSADC_OcdSetInterrupt</a>(PACSS_MMIO, CY_DSADC_OCD0_INTR_TRIGGER);</div></div><!-- fragment --> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Not applicable for PSOC4 HVPA. </dd></dl>

</div>
</div>
<a id="ga3ee445e728b4cac35eb7b8d42fd19a0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ee445e728b4cac35eb7b8d42fd19a0c">&#9670;&nbsp;</a></span>Cy_DSADC_OcdSetInterruptMask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_DSADC_OcdSetInterruptMask </td>
          <td>(</td>
          <td class="paramtype">PACSS_MMIO_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>intrMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables the specified OCD MMIO interrupt mask. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the MMIO instance of the PACSS.</td></tr>
    <tr><td class="paramname">intrMask</td><td>The bit field determines which status changes can cause an interrupt. Select one or more values from <a class="el" href="group__group__dsadc__ocd__macros__interrupt.html">Interrupt OCD Masks</a> and "OR" them together.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/* Scenario: Set interrupt to simulate overcurrent. */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Hook interrupt service routine. */</span></div><div class="line">    (void) <a class="code" href="group__group__sysint__functions.html#gab2ff6820a898e9af3f780000054eea5d">Cy_SysInt_Init</a>(&amp;OCDIntrConfig, &amp;OCD_Isr);</div><div class="line"></div><div class="line">    uint32_t intrMask = <a class="code" href="group__group__dsadc__interrupt__functions.html#gad98cf6de393fab821f560edb77752113">Cy_DSADC_OcdGetInterruptMask</a>(PACSS_MMIO);</div><div class="line">    <span class="comment">/* Check whether trigger interrupt source is enabled. */</span></div><div class="line">    <span class="keywordflow">if</span> (CY_DSADC_OCD0_INTR_TRIGGER != (intrMask &amp; CY_DSADC_OCD0_INTR_TRIGGER))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Enable trigger interrupt. */</span></div><div class="line">        <a class="code" href="group__group__dsadc__interrupt__functions.html#ga3ee445e728b4cac35eb7b8d42fd19a0c">Cy_DSADC_OcdSetInterruptMask</a>(PACSS_MMIO, CY_DSADC_OCD0_INTR_TRIGGER);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* Enable interrupt for interrupt controller. */</span></div><div class="line">    NVIC_EnableIRQ(OCDIntrConfig.intrSrc);</div><div class="line"></div><div class="line">    <span class="comment">/* Set trigger interrupt. */</span></div><div class="line">    <a class="code" href="group__group__dsadc__interrupt__functions.html#ga0dd9259be2661661c4b13ecfe8cc65eb">Cy_DSADC_OcdSetInterrupt</a>(PACSS_MMIO, CY_DSADC_OCD0_INTR_TRIGGER);</div></div><!-- fragment --> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Not applicable for PSOC4 HVPA. </dd></dl>

</div>
</div>
<a id="gafa8b5af0680bb0d27aa1a664b6388fe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa8b5af0680bb0d27aa1a664b6388fe0">&#9670;&nbsp;</a></span>Cy_DSADC_OcdGetInterruptStatusMasked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_DSADC_OcdGetInterruptStatusMasked </td>
          <td>(</td>
          <td class="paramtype">PACSS_MMIO_Type *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the specified OCD MMIO interrupt masked (enabled) status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the MMIO instance of the PACSS.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Bitwise AND of the interrupt request and mask registers. To find out the state of the interrupts status masked, use <a class="el" href="group__group__dsadc__ocd__macros__interrupt.html">Interrupt OCD Masks</a>.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"><span class="comment">/* Interrupt handler. */</span></div><div class="line"><span class="keywordtype">void</span> OCD_Isr(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    uint32_t intr_status = <a class="code" href="group__group__dsadc__interrupt__functions.html#gaead06ad69e008773c0495fe4766c60dd">Cy_DSADC_OcdGetInterruptStatus</a>(PACSS_MMIO);</div><div class="line">    uint32_t masked_status = <a class="code" href="group__group__dsadc__interrupt__functions.html#gafa8b5af0680bb0d27aa1a664b6388fe0">Cy_DSADC_OcdGetInterruptStatusMasked</a>(PACSS_MMIO);</div><div class="line"></div><div class="line">    <span class="comment">/* Check if interrupt occurs due to overcurrent. */</span></div><div class="line">    <span class="keywordflow">if</span>(0UL != (CY_DSADC_OCD0_INTR_TRIGGER &amp; intr_status &amp; masked_status))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Process interrupt. */</span></div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <span class="comment">/* Process unexpected behavior. */</span></div><div class="line">    }</div><div class="line">    <span class="comment">/* Clear all possible interrupt sources using combined interrupt mask. */</span></div><div class="line">    <a class="code" href="group__group__dsadc__interrupt__functions.html#ga31a98bc5c94db0fc18a76648e41e1c9f">Cy_DSADC_OcdClearInterrupt</a>(PACSS_MMIO, <a class="code" href="group__group__dsadc__ocd__macros__interrupt.html#gaf1efbcee52cae30b35264b1e68f55846">CY_DSADC_OCD_INTR_MASK</a>);</div><div class="line">}</div></div><!-- fragment --> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Not applicable for PSOC4 HVPA. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>CAT2 Peripheral Driver Library</b> by <b>Infineon Technologies</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
