<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CAT2 Peripheral Driver Library: Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CAT2 Peripheral Driver Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__wdc__functions.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Functions<div class="ingroups"><a class="el" href="group__group__wdc.html">WDC          (Watchdog Counters)</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga815bbc01c7cfb8c9c4d916b5d544303f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__wdc__enums.html#gaecf84c6ceac81fcc3490f84db822b69b">cy_en_wdc_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdc__functions.html#ga815bbc01c7cfb8c9c4d916b5d544303f">Cy_WDC_Init</a> (WCO_Type *base, <a class="el" href="structcy__stc__wdc__config__t.html">cy_stc_wdc_config_t</a> const *config)</td></tr>
<tr class="memdesc:ga815bbc01c7cfb8c9c4d916b5d544303f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the WDC block.  <a href="#ga815bbc01c7cfb8c9c4d916b5d544303f">More...</a><br /></td></tr>
<tr class="separator:ga815bbc01c7cfb8c9c4d916b5d544303f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7dc055cb2f76d7a9909e8e8a5f16e2f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdc__functions.html#ga7dc055cb2f76d7a9909e8e8a5f16e2f0">Cy_WDC_DeInit</a> (WCO_Type *base)</td></tr>
<tr class="memdesc:ga7dc055cb2f76d7a9909e8e8a5f16e2f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">De-initializes the WDC block, returns register values to their default state.  <a href="#ga7dc055cb2f76d7a9909e8e8a5f16e2f0">More...</a><br /></td></tr>
<tr class="separator:ga7dc055cb2f76d7a9909e8e8a5f16e2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd2a4e06b7fc76f8738cc1e721d30758"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdc__functions.html#gabd2a4e06b7fc76f8738cc1e721d30758">Cy_WDC_Enable</a> (WCO_Type *base, uint32_t counters, uint16_t waitUs)</td></tr>
<tr class="memdesc:gabd2a4e06b7fc76f8738cc1e721d30758"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables all specified counters.  <a href="#gabd2a4e06b7fc76f8738cc1e721d30758">More...</a><br /></td></tr>
<tr class="separator:gabd2a4e06b7fc76f8738cc1e721d30758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga258f24ce31b9830fd103d48aaaf37317"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdc__functions.html#ga258f24ce31b9830fd103d48aaaf37317">Cy_WDC_Disable</a> (WCO_Type *base, uint32_t counters, uint16_t waitUs)</td></tr>
<tr class="memdesc:ga258f24ce31b9830fd103d48aaaf37317"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables all specified counters.  <a href="#ga258f24ce31b9830fd103d48aaaf37317">More...</a><br /></td></tr>
<tr class="separator:ga258f24ce31b9830fd103d48aaaf37317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c24429efbb2102a044f02682b6c71c7"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdc__functions.html#ga2c24429efbb2102a044f02682b6c71c7">Cy_WDC_GetEnabledStatus</a> (WCO_Type const *base, <a class="el" href="group__group__wdc__enums.html#ga0a71bd34b17e5b7db10e0617f19e6702">cy_en_wdc_ctr_t</a> counter)</td></tr>
<tr class="memdesc:ga2c24429efbb2102a044f02682b6c71c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the enabled status of the specified counter.  <a href="#ga2c24429efbb2102a044f02682b6c71c7">More...</a><br /></td></tr>
<tr class="separator:ga2c24429efbb2102a044f02682b6c71c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae95560e4f5667f61c01d534ab1b34d88"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdc__functions.html#gae95560e4f5667f61c01d534ab1b34d88">Cy_WDC_InterruptEnable</a> (WCO_Type *base, <a class="el" href="group__group__wdc__enums.html#ga0a71bd34b17e5b7db10e0617f19e6702">cy_en_wdc_ctr_t</a> counter)</td></tr>
<tr class="memdesc:gae95560e4f5667f61c01d534ab1b34d88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables interrupt generation for the specified counter.  <a href="#gae95560e4f5667f61c01d534ab1b34d88">More...</a><br /></td></tr>
<tr class="separator:gae95560e4f5667f61c01d534ab1b34d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e629525df6c9f05d6146a61780f021d"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdc__functions.html#ga8e629525df6c9f05d6146a61780f021d">Cy_WDC_InterruptDisable</a> (WCO_Type *base, <a class="el" href="group__group__wdc__enums.html#ga0a71bd34b17e5b7db10e0617f19e6702">cy_en_wdc_ctr_t</a> counter)</td></tr>
<tr class="memdesc:ga8e629525df6c9f05d6146a61780f021d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables interrupt generation for the specified counter.  <a href="#ga8e629525df6c9f05d6146a61780f021d">More...</a><br /></td></tr>
<tr class="separator:ga8e629525df6c9f05d6146a61780f021d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5da6ae9c907aa11316075f20f358bc42"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdc__functions.html#ga5da6ae9c907aa11316075f20f358bc42">Cy_WDC_GetInterruptSetting</a> (WCO_Type const *base, <a class="el" href="group__group__wdc__enums.html#ga0a71bd34b17e5b7db10e0617f19e6702">cy_en_wdc_ctr_t</a> counter)</td></tr>
<tr class="memdesc:ga5da6ae9c907aa11316075f20f358bc42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports interrupt setting for specified counter.  <a href="#ga5da6ae9c907aa11316075f20f358bc42">More...</a><br /></td></tr>
<tr class="separator:ga5da6ae9c907aa11316075f20f358bc42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfd4cbdc385cc479e1127157b66fa553"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdc__functions.html#gadfd4cbdc385cc479e1127157b66fa553">Cy_WDC_SetClearOnMatch</a> (WCO_Type *base, <a class="el" href="group__group__wdc__enums.html#ga0a71bd34b17e5b7db10e0617f19e6702">cy_en_wdc_ctr_t</a> counter, uint32_t enable)</td></tr>
<tr class="memdesc:gadfd4cbdc385cc479e1127157b66fa553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the Clear on match option for the specified counter.  <a href="#gadfd4cbdc385cc479e1127157b66fa553">More...</a><br /></td></tr>
<tr class="separator:gadfd4cbdc385cc479e1127157b66fa553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a50538c7434abd08911325df1843f9b"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdc__functions.html#ga3a50538c7434abd08911325df1843f9b">Cy_WDC_GetClearOnMatch</a> (WCO_Type const *base, <a class="el" href="group__group__wdc__enums.html#ga0a71bd34b17e5b7db10e0617f19e6702">cy_en_wdc_ctr_t</a> counter)</td></tr>
<tr class="memdesc:ga3a50538c7434abd08911325df1843f9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the Clear on match setting for the specified counter.  <a href="#ga3a50538c7434abd08911325df1843f9b">More...</a><br /></td></tr>
<tr class="separator:ga3a50538c7434abd08911325df1843f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ddaa32ee6164fed0b7360c20452efc4"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdc__functions.html#ga7ddaa32ee6164fed0b7360c20452efc4">Cy_WDC_SetCascade</a> (WCO_Type *base, uint32_t cascade)</td></tr>
<tr class="memdesc:ga7ddaa32ee6164fed0b7360c20452efc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets all the counter cascade options.  <a href="#ga7ddaa32ee6164fed0b7360c20452efc4">More...</a><br /></td></tr>
<tr class="separator:ga7ddaa32ee6164fed0b7360c20452efc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ce386fa495266317d1806d95e04041a"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdc__functions.html#ga5ce386fa495266317d1806d95e04041a">Cy_WDC_GetCascade</a> (WCO_Type const *base)</td></tr>
<tr class="memdesc:ga5ce386fa495266317d1806d95e04041a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports all the counter cascade option settings.  <a href="#ga5ce386fa495266317d1806d95e04041a">More...</a><br /></td></tr>
<tr class="separator:ga5ce386fa495266317d1806d95e04041a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69669e3a0f7ca147bf576ad6feccb6d0"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdc__functions.html#ga69669e3a0f7ca147bf576ad6feccb6d0">Cy_WDC_SetMatch</a> (WCO_Type *base, <a class="el" href="group__group__wdc__enums.html#ga0a71bd34b17e5b7db10e0617f19e6702">cy_en_wdc_ctr_t</a> counter, uint32_t match, uint16_t waitUs)</td></tr>
<tr class="memdesc:ga69669e3a0f7ca147bf576ad6feccb6d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the match comparison value for the specified counter (0 or 1).  <a href="#ga69669e3a0f7ca147bf576ad6feccb6d0">More...</a><br /></td></tr>
<tr class="separator:ga69669e3a0f7ca147bf576ad6feccb6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30722190e83603745f90944ee105f74d"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdc__functions.html#ga30722190e83603745f90944ee105f74d">Cy_WDC_GetMatch</a> (WCO_Type const *base, <a class="el" href="group__group__wdc__enums.html#ga0a71bd34b17e5b7db10e0617f19e6702">cy_en_wdc_ctr_t</a> counter)</td></tr>
<tr class="memdesc:ga30722190e83603745f90944ee105f74d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the match comparison value for the specified counter (0 or 1).  <a href="#ga30722190e83603745f90944ee105f74d">More...</a><br /></td></tr>
<tr class="separator:ga30722190e83603745f90944ee105f74d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9beb18f46001725553997875780b308"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdc__functions.html#gaa9beb18f46001725553997875780b308">Cy_WDC_SetToggleBit</a> (WCO_Type *base, uint32_t bit)</td></tr>
<tr class="memdesc:gaa9beb18f46001725553997875780b308"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a bit in Counter 2 to monitor for a toggle.  <a href="#gaa9beb18f46001725553997875780b308">More...</a><br /></td></tr>
<tr class="separator:gaa9beb18f46001725553997875780b308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3daf631939d1708282321ba9a941c0b9"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdc__functions.html#ga3daf631939d1708282321ba9a941c0b9">Cy_WDC_GetToggleBit</a> (WCO_Type const *base)</td></tr>
<tr class="memdesc:ga3daf631939d1708282321ba9a941c0b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports which bit in Counter 2 is monitored for a toggle.  <a href="#ga3daf631939d1708282321ba9a941c0b9">More...</a><br /></td></tr>
<tr class="separator:ga3daf631939d1708282321ba9a941c0b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffee8f4e04dd90725bc9674d7711a7e8"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdc__functions.html#gaffee8f4e04dd90725bc9674d7711a7e8">Cy_WDC_GetCount</a> (WCO_Type const *base, <a class="el" href="group__group__wdc__enums.html#ga0a71bd34b17e5b7db10e0617f19e6702">cy_en_wdc_ctr_t</a> counter)</td></tr>
<tr class="memdesc:gaffee8f4e04dd90725bc9674d7711a7e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the current counter value of the specified counter.  <a href="#gaffee8f4e04dd90725bc9674d7711a7e8">More...</a><br /></td></tr>
<tr class="separator:gaffee8f4e04dd90725bc9674d7711a7e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed5a60e3e0d0a28dd11a439a2ee6a44c"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdc__functions.html#gaed5a60e3e0d0a28dd11a439a2ee6a44c">Cy_WDC_ResetCounters</a> (WCO_Type *base, uint32_t counters, uint16_t waitUs)</td></tr>
<tr class="memdesc:gaed5a60e3e0d0a28dd11a439a2ee6a44c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets all specified counters.  <a href="#gaed5a60e3e0d0a28dd11a439a2ee6a44c">More...</a><br /></td></tr>
<tr class="separator:gaed5a60e3e0d0a28dd11a439a2ee6a44c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa47ce8aec249f0f21f51ac94622b27b2"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdc__functions.html#gaa47ce8aec249f0f21f51ac94622b27b2">Cy_WDC_GetInterruptStatus</a> (WCO_Type const *base)</td></tr>
<tr class="memdesc:gaa47ce8aec249f0f21f51ac94622b27b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the state of all WDC interrupts.  <a href="#gaa47ce8aec249f0f21f51ac94622b27b2">More...</a><br /></td></tr>
<tr class="separator:gaa47ce8aec249f0f21f51ac94622b27b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae10b219e54fde3bc0d5eee1c173620e9"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdc__functions.html#gae10b219e54fde3bc0d5eee1c173620e9">Cy_WDC_ClearInterrupt</a> (WCO_Type *base, uint32_t counters)</td></tr>
<tr class="memdesc:gae10b219e54fde3bc0d5eee1c173620e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears all specified WDC interrupts.  <a href="#gae10b219e54fde3bc0d5eee1c173620e9">More...</a><br /></td></tr>
<tr class="separator:gae10b219e54fde3bc0d5eee1c173620e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga545e736d9d9911c3d01b8d1c8e2b923b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdc__functions.html#ga545e736d9d9911c3d01b8d1c8e2b923b">Cy_WDC_GetCountCascaded</a> (WCO_Type const *base)</td></tr>
<tr class="memdesc:ga545e736d9d9911c3d01b8d1c8e2b923b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports the current value of combined C1-C0 cascaded counters.  <a href="#ga545e736d9d9911c3d01b8d1c8e2b923b">More...</a><br /></td></tr>
<tr class="separator:ga545e736d9d9911c3d01b8d1c8e2b923b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6665c7166cac0a5db3ac3b1ffc0d8dcf"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group__group__wdc__enums.html#ga2f558686b71ae60686d9c3ba6f17e6ba">cy_en_wdc_clock_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdc__functions.html#ga6665c7166cac0a5db3ac3b1ffc0d8dcf">Cy_WDC_GetClockSource</a> (WCO_Type const *base)</td></tr>
<tr class="memdesc:ga6665c7166cac0a5db3ac3b1ffc0d8dcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the clock source for WDC timers.  <a href="#ga6665c7166cac0a5db3ac3b1ffc0d8dcf">More...</a><br /></td></tr>
<tr class="separator:ga6665c7166cac0a5db3ac3b1ffc0d8dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8bf6dc1302e9a8fc4d63f3fddbca6698"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__wdc__functions.html#ga8bf6dc1302e9a8fc4d63f3fddbca6698">Cy_WDC_SetClockSource</a> (WCO_Type *base, <a class="el" href="group__group__wdc__enums.html#ga2f558686b71ae60686d9c3ba6f17e6ba">cy_en_wdc_clock_t</a> source)</td></tr>
<tr class="memdesc:ga8bf6dc1302e9a8fc4d63f3fddbca6698"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the clock source for WDC timers.  <a href="#ga8bf6dc1302e9a8fc4d63f3fddbca6698">More...</a><br /></td></tr>
<tr class="separator:ga8bf6dc1302e9a8fc4d63f3fddbca6698"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga815bbc01c7cfb8c9c4d916b5d544303f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga815bbc01c7cfb8c9c4d916b5d544303f">&#9670;&nbsp;</a></span>Cy_WDC_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__wdc__enums.html#gaecf84c6ceac81fcc3490f84db822b69b">cy_en_wdc_status_t</a> Cy_WDC_Init </td>
          <td>(</td>
          <td class="paramtype">WCO_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__wdc__config__t.html">cy_stc_wdc_config_t</a> const *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the WDC block. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes the registers.</td></tr>
    <tr><td class="paramname">config</td><td>The pointer to a structure that contains component configuration data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>cy_en_wdc_status_t Returns an error if any of the structure pointers is NULL.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Do not call this function when the counters are running. First, disable counters using <a class="el" href="group__group__wdc__functions.html#ga258f24ce31b9830fd103d48aaaf37317">Cy_WDC_Disable</a>.</dd>
<dd>
This function waits four WDC clock source cycles in order to set the WDC clock source. </dd></dl>

</div>
</div>
<a id="ga7dc055cb2f76d7a9909e8e8a5f16e2f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7dc055cb2f76d7a9909e8e8a5f16e2f0">&#9670;&nbsp;</a></span>Cy_WDC_DeInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_WDC_DeInit </td>
          <td>(</td>
          <td class="paramtype">WCO_Type *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>De-initializes the WDC block, returns register values to their default state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes the registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Do not call this function when the counters are running. First, disable counters using <a class="el" href="group__group__wdc__functions.html#ga258f24ce31b9830fd103d48aaaf37317">Cy_WDC_Disable</a>.</dd>
<dd>
Call this function only after calling the <a class="el" href="group__group__wdc__functions.html#ga815bbc01c7cfb8c9c4d916b5d544303f">Cy_WDC_Init()</a> function.</dd>
<dd>
This function does not reset the WDC match value.</dd>
<dd>
This function takes 10 WDC clock source cycles in order perform de-initialization. </dd></dl>

</div>
</div>
<a id="gabd2a4e06b7fc76f8738cc1e721d30758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd2a4e06b7fc76f8738cc1e721d30758">&#9670;&nbsp;</a></span>Cy_WDC_Enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_WDC_Enable </td>
          <td>(</td>
          <td class="paramtype">WCO_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>counters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>waitUs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables all specified counters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">counters</td><td>OR of all counters to enable. See the <a class="el" href="group__group__wdc__macros.html#gaf64abef99e252788f2dd2bce56ec757e">CY_WDC_COUNTER0_Msk</a>, <a class="el" href="group__group__wdc__macros.html#ga237f83da599475cb04f7939310b1a4c2">CY_WDC_COUNTER1_Msk</a>, and <a class="el" href="group__group__wdc__macros.html#gaec8a8f1c85695cee028b62b70157e6a9">CY_WDC_COUNTER2_Msk</a> macros.</td></tr>
    <tr><td class="paramname">waitUs</td><td>The function waits for some delay in microseconds before returning, because the counter begins counting after three WDC clock-source cycles pass. The recommended waitUs parameter value is defined by <a class="el" href="group__group__wdc__macros.html#ga44e4ac9709fed40c64661c25aa870abb">CY_WDC_CLK_ILO_3CYCLES_US</a> and <a class="el" href="group__group__wdc__macros.html#ga3bfe527fe6efeeb9098af1b14a827413">CY_WDC_CLK_WCO_3CYCLES_US</a> macros. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Setting this parameter to a zero means No wait. In this case, it is the user's responsibility to check whether the selected counters were enabled immediately after the function call. This can be done by the <a class="el" href="group__group__wdc__functions.html#ga2c24429efbb2102a044f02682b6c71c7" title="Reports the enabled status of the specified counter. ">Cy_WDC_GetEnabledStatus()</a> API. </dd></dl>

</div>
</div>
<a id="ga258f24ce31b9830fd103d48aaaf37317"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga258f24ce31b9830fd103d48aaaf37317">&#9670;&nbsp;</a></span>Cy_WDC_Disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_WDC_Disable </td>
          <td>(</td>
          <td class="paramtype">WCO_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>counters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>waitUs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables all specified counters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure describing registers.</td></tr>
    <tr><td class="paramname">counters</td><td>OR of all counters to disable. See the <a class="el" href="group__group__wdc__macros.html#gaf64abef99e252788f2dd2bce56ec757e">CY_WDC_COUNTER0_Msk</a>, <a class="el" href="group__group__wdc__macros.html#ga237f83da599475cb04f7939310b1a4c2">CY_WDC_COUNTER1_Msk</a>, and <a class="el" href="group__group__wdc__macros.html#gaec8a8f1c85695cee028b62b70157e6a9">CY_WDC_COUNTER2_Msk</a> macros.</td></tr>
    <tr><td class="paramname">waitUs</td><td>The function waits for some delay in microseconds before returning, because the counter stops counting after three WDC clock source cycles pass. The recommended waitUs parameter value is defined by <a class="el" href="group__group__wdc__macros.html#ga44e4ac9709fed40c64661c25aa870abb">CY_WDC_CLK_ILO_3CYCLES_US</a> and <a class="el" href="group__group__wdc__macros.html#ga3bfe527fe6efeeb9098af1b14a827413">CY_WDC_CLK_WCO_3CYCLES_US</a> macros. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Setting this parameter to a zero means No wait. In this case, it is the user's responsibility to check whether the selected counters were disabled immediately after the function call. This can be done by the <a class="el" href="group__group__wdc__functions.html#ga2c24429efbb2102a044f02682b6c71c7" title="Reports the enabled status of the specified counter. ">Cy_WDC_GetEnabledStatus()</a> API. </dd></dl>

</div>
</div>
<a id="ga2c24429efbb2102a044f02682b6c71c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c24429efbb2102a044f02682b6c71c7">&#9670;&nbsp;</a></span>Cy_WDC_GetEnabledStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_WDC_GetEnabledStatus </td>
          <td>(</td>
          <td class="paramtype">WCO_Type const *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__wdc__enums.html#ga0a71bd34b17e5b7db10e0617f19e6702">cy_en_wdc_ctr_t</a>&#160;</td>
          <td class="paramname"><em>counter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the enabled status of the specified counter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">counter</td><td>The number of the WDT counter. See <a class="el" href="group__group__wdc__enums.html#ga0a71bd34b17e5b7db10e0617f19e6702">cy_en_wdc_ctr_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status of the WDC counter: 0 = disabled, 1 = enabled. </dd></dl>

</div>
</div>
<a id="gae95560e4f5667f61c01d534ab1b34d88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae95560e4f5667f61c01d534ab1b34d88">&#9670;&nbsp;</a></span>Cy_WDC_InterruptEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_WDC_InterruptEnable </td>
          <td>(</td>
          <td class="paramtype">WCO_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__wdc__enums.html#ga0a71bd34b17e5b7db10e0617f19e6702">cy_en_wdc_ctr_t</a>&#160;</td>
          <td class="paramname"><em>counter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables interrupt generation for the specified counter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">counter</td><td>The number of the WDT counter. See <a class="el" href="group__group__wdc__enums.html#ga0a71bd34b17e5b7db10e0617f19e6702">cy_en_wdc_ctr_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Do not call this function while the counters are running. Disable the counter prior to calling this function using <a class="el" href="group__group__wdc__functions.html#ga258f24ce31b9830fd103d48aaaf37317">Cy_WDC_Disable</a>. </dd></dl>

</div>
</div>
<a id="ga8e629525df6c9f05d6146a61780f021d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e629525df6c9f05d6146a61780f021d">&#9670;&nbsp;</a></span>Cy_WDC_InterruptDisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_WDC_InterruptDisable </td>
          <td>(</td>
          <td class="paramtype">WCO_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__wdc__enums.html#ga0a71bd34b17e5b7db10e0617f19e6702">cy_en_wdc_ctr_t</a>&#160;</td>
          <td class="paramname"><em>counter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables interrupt generation for the specified counter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">counter</td><td>The number of the WDT counter. See <a class="el" href="group__group__wdc__enums.html#ga0a71bd34b17e5b7db10e0617f19e6702">cy_en_wdc_ctr_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Do not call tis function while the counters are running. Disable the counter prior to calling this function using <a class="el" href="group__group__wdc__functions.html#ga258f24ce31b9830fd103d48aaaf37317">Cy_WDC_Disable</a>. </dd></dl>

</div>
</div>
<a id="ga5da6ae9c907aa11316075f20f358bc42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5da6ae9c907aa11316075f20f358bc42">&#9670;&nbsp;</a></span>Cy_WDC_GetInterruptSetting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE bool Cy_WDC_GetInterruptSetting </td>
          <td>(</td>
          <td class="paramtype">WCO_Type const *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__wdc__enums.html#ga0a71bd34b17e5b7db10e0617f19e6702">cy_en_wdc_ctr_t</a>&#160;</td>
          <td class="paramname"><em>counter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports interrupt setting for specified counter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">counter</td><td>The number of the WDT counter. See <a class="el" href="group__group__wdc__enums.html#ga0a71bd34b17e5b7db10e0617f19e6702">cy_en_wdc_ctr_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current setting of the counter. true - interrupt enabled false - interrupt disabled. </dd></dl>

</div>
</div>
<a id="gadfd4cbdc385cc479e1127157b66fa553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfd4cbdc385cc479e1127157b66fa553">&#9670;&nbsp;</a></span>Cy_WDC_SetClearOnMatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_WDC_SetClearOnMatch </td>
          <td>(</td>
          <td class="paramtype">WCO_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__wdc__enums.html#ga0a71bd34b17e5b7db10e0617f19e6702">cy_en_wdc_ctr_t</a>&#160;</td>
          <td class="paramname"><em>counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>enable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the Clear on match option for the specified counter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">counter</td><td>The number of the WDT counter. See <a class="el" href="group__group__wdc__enums.html#ga0a71bd34b17e5b7db10e0617f19e6702">cy_en_wdc_ctr_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The match values are not supported by Counter 2.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>Set 0 to disable; 1 to enable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Do not call this function while the counters are running. Disable the counter prior to calling this function using <a class="el" href="group__group__wdc__functions.html#ga258f24ce31b9830fd103d48aaaf37317">Cy_WDC_Disable</a>. </dd></dl>

</div>
</div>
<a id="ga3a50538c7434abd08911325df1843f9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a50538c7434abd08911325df1843f9b">&#9670;&nbsp;</a></span>Cy_WDC_GetClearOnMatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_WDC_GetClearOnMatch </td>
          <td>(</td>
          <td class="paramtype">WCO_Type const *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__wdc__enums.html#ga0a71bd34b17e5b7db10e0617f19e6702">cy_en_wdc_ctr_t</a>&#160;</td>
          <td class="paramname"><em>counter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the Clear on match setting for the specified counter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">counter</td><td>The number of the WDT counter. See <a class="el" href="group__group__wdc__enums.html#ga0a71bd34b17e5b7db10e0617f19e6702">cy_en_wdc_ctr_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The Clear on match status: 1 = enabled, 0 = disabled.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The match value is not supported by Counter 2. </dd></dl>

</div>
</div>
<a id="ga7ddaa32ee6164fed0b7360c20452efc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ddaa32ee6164fed0b7360c20452efc4">&#9670;&nbsp;</a></span>Cy_WDC_SetCascade()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_WDC_SetCascade </td>
          <td>(</td>
          <td class="paramtype">WCO_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>cascade</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets all the counter cascade options. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">cascade</td><td>Sets or clears each of the cascade options <a class="el" href="group__group__wdc__macros__cascading__masks.html">Cascading Masks</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Do not call this function when the counters are running. Disable counters to be cascaded prior to calling this function using <a class="el" href="group__group__wdc__functions.html#ga258f24ce31b9830fd103d48aaaf37317">Cy_WDC_Disable</a>.</dd>
<dd>
When cascading all three counters, enable the Clear on match option for counter 1. </dd></dl>

</div>
</div>
<a id="ga5ce386fa495266317d1806d95e04041a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ce386fa495266317d1806d95e04041a">&#9670;&nbsp;</a></span>Cy_WDC_GetCascade()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_WDC_GetCascade </td>
          <td>(</td>
          <td class="paramtype">WCO_Type const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports all the counter cascade option settings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current cascade option values <a class="el" href="group__group__wdc__macros__cascading__masks.html">Cascading Masks</a>. </dd></dl>

</div>
</div>
<a id="ga69669e3a0f7ca147bf576ad6feccb6d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69669e3a0f7ca147bf576ad6feccb6d0">&#9670;&nbsp;</a></span>Cy_WDC_SetMatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_WDC_SetMatch </td>
          <td>(</td>
          <td class="paramtype">WCO_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__wdc__enums.html#ga0a71bd34b17e5b7db10e0617f19e6702">cy_en_wdc_ctr_t</a>&#160;</td>
          <td class="paramname"><em>counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>waitUs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the match comparison value for the specified counter (0 or 1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">counter</td><td>The number of the WDT counter. See <a class="el" href="group__group__wdc__enums.html#ga0a71bd34b17e5b7db10e0617f19e6702">cy_en_wdc_ctr_t</a></td></tr>
    <tr><td class="paramname">match</td><td>The value to match against the counter. The valid range is [0-65535] for c0ClearOnMatch (or c1ClearOnMatch) = 0 and [1-65535] for c0ClearOnMatch (or c1ClearOnMatch) = 1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The match value is not supported by Counter 2.</dd>
<dd>
The match is done on the next increment after the counter value equals the match value.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">waitUs</td><td>The function waits for some delay in microseconds before returning, because the match affects after three WDC clock source cycles pass. The recommended waitUs parameter value is defined by <a class="el" href="group__group__wdc__macros.html#ga44e4ac9709fed40c64661c25aa870abb">CY_WDC_CLK_ILO_3CYCLES_US</a> and <a class="el" href="group__group__wdc__macros.html#ga3bfe527fe6efeeb9098af1b14a827413">CY_WDC_CLK_WCO_3CYCLES_US</a> macros. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Setting this parameter to a zero means No wait. Take this into account when changing the match values on the running counters. </dd></dl>

</div>
</div>
<a id="ga30722190e83603745f90944ee105f74d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30722190e83603745f90944ee105f74d">&#9670;&nbsp;</a></span>Cy_WDC_GetMatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_WDC_GetMatch </td>
          <td>(</td>
          <td class="paramtype">WCO_Type const *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__wdc__enums.html#ga0a71bd34b17e5b7db10e0617f19e6702">cy_en_wdc_ctr_t</a>&#160;</td>
          <td class="paramname"><em>counter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the match comparison value for the specified counter (0 or 1). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">counter</td><td>The number of the WDT counter. See <a class="el" href="group__group__wdc__enums.html#ga0a71bd34b17e5b7db10e0617f19e6702">cy_en_wdc_ctr_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The match values are not supported by Counter 2.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A 16-bit match value. </dd></dl>

</div>
</div>
<a id="gaa9beb18f46001725553997875780b308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa9beb18f46001725553997875780b308">&#9670;&nbsp;</a></span>Cy_WDC_SetToggleBit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_WDC_SetToggleBit </td>
          <td>(</td>
          <td class="paramtype">WCO_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a bit in Counter 2 to monitor for a toggle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">bit</td><td>The Counter 2 bit is set to monitor for a toggle. The valid range [0-31].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Do not call this function when the counter is running. Disable the counter prior to calling this function using <a class="el" href="group__group__wdc__functions.html#ga258f24ce31b9830fd103d48aaaf37317">Cy_WDC_Disable</a>. </dd></dl>

</div>
</div>
<a id="ga3daf631939d1708282321ba9a941c0b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3daf631939d1708282321ba9a941c0b9">&#9670;&nbsp;</a></span>Cy_WDC_GetToggleBit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_WDC_GetToggleBit </td>
          <td>(</td>
          <td class="paramtype">WCO_Type const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports which bit in Counter 2 is monitored for a toggle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bit that is monitored (range 0 to 31). </dd></dl>

</div>
</div>
<a id="gaffee8f4e04dd90725bc9674d7711a7e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffee8f4e04dd90725bc9674d7711a7e8">&#9670;&nbsp;</a></span>Cy_WDC_GetCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_WDC_GetCount </td>
          <td>(</td>
          <td class="paramtype">WCO_Type const *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__wdc__enums.html#ga0a71bd34b17e5b7db10e0617f19e6702">cy_en_wdc_ctr_t</a>&#160;</td>
          <td class="paramname"><em>counter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the current counter value of the specified counter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">counter</td><td>The number of the WDT counter. See <a class="el" href="group__group__wdc__enums.html#ga0a71bd34b17e5b7db10e0617f19e6702">cy_en_wdc_ctr_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A live counter value. Counters 0 and 1 are 16-bit counters and Counter 2 is a 32-bit counter. </dd></dl>

</div>
</div>
<a id="gaed5a60e3e0d0a28dd11a439a2ee6a44c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaed5a60e3e0d0a28dd11a439a2ee6a44c">&#9670;&nbsp;</a></span>Cy_WDC_ResetCounters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_WDC_ResetCounters </td>
          <td>(</td>
          <td class="paramtype">WCO_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>counters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>waitUs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets all specified counters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
    <tr><td class="paramname">counters</td><td>OR of all counters to reset. See the <a class="el" href="group__group__wdc__macros.html#gaf64abef99e252788f2dd2bce56ec757e">CY_WDC_COUNTER0_Msk</a>, <a class="el" href="group__group__wdc__macros.html#ga237f83da599475cb04f7939310b1a4c2">CY_WDC_COUNTER1_Msk</a>, and <a class="el" href="group__group__wdc__macros.html#gaec8a8f1c85695cee028b62b70157e6a9">CY_WDC_COUNTER2_Msk</a> macros.</td></tr>
    <tr><td class="paramname">waitUs</td><td>The function waits for some delay in microseconds before returning, because a reset occurs after three WDC clock source cycle passes. The recommended waitUs parameter value is defined by <a class="el" href="group__group__wdc__macros.html#ga44e4ac9709fed40c64661c25aa870abb">CY_WDC_CLK_ILO_3CYCLES_US</a> and <a class="el" href="group__group__wdc__macros.html#ga3bfe527fe6efeeb9098af1b14a827413">CY_WDC_CLK_WCO_3CYCLES_US</a> macros. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Setting this parameter to a zero means No wait. In this case, it is the user's responsibility to check whether the selected counters were reset immediately after the function call. This can be done by the <a class="el" href="group__group__wdc__functions.html#gaffee8f4e04dd90725bc9674d7711a7e8" title="Reports the current counter value of the specified counter. ">Cy_WDC_GetCount()</a> API. </dd></dl>

</div>
</div>
<a id="gaa47ce8aec249f0f21f51ac94622b27b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa47ce8aec249f0f21f51ac94622b27b2">&#9670;&nbsp;</a></span>Cy_WDC_GetInterruptStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_WDC_GetInterruptStatus </td>
          <td>(</td>
          <td class="paramtype">WCO_Type const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the state of all WDC interrupts. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The OR'd state of the interrupts. See the <a class="el" href="group__group__wdc__macros.html#gaf64abef99e252788f2dd2bce56ec757e">CY_WDC_COUNTER0_Msk</a>, <a class="el" href="group__group__wdc__macros.html#ga237f83da599475cb04f7939310b1a4c2">CY_WDC_COUNTER1_Msk</a>, and <a class="el" href="group__group__wdc__macros.html#gaec8a8f1c85695cee028b62b70157e6a9">CY_WDC_COUNTER2_Msk</a> macros. </dd></dl>

</div>
</div>
<a id="gae10b219e54fde3bc0d5eee1c173620e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae10b219e54fde3bc0d5eee1c173620e9">&#9670;&nbsp;</a></span>Cy_WDC_ClearInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_WDC_ClearInterrupt </td>
          <td>(</td>
          <td class="paramtype">WCO_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>counters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears all specified WDC interrupts. </p>
<p>All the WDT interrupts must be cleared by the firmware; otherwise interrupts are generated continuously.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure describes registers.</td></tr>
    <tr><td class="paramname">counters</td><td>OR of all interrupt sources to clear. See the <a class="el" href="group__group__wdc__macros.html#gaf64abef99e252788f2dd2bce56ec757e">CY_WDC_COUNTER0_Msk</a>, <a class="el" href="group__group__wdc__macros.html#ga237f83da599475cb04f7939310b1a4c2">CY_WDC_COUNTER1_Msk</a>, and CY_WDC_COUNTER2_Msk macros. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga545e736d9d9911c3d01b8d1c8e2b923b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga545e736d9d9911c3d01b8d1c8e2b923b">&#9670;&nbsp;</a></span>Cy_WDC_GetCountCascaded()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Cy_WDC_GetCountCascaded </td>
          <td>(</td>
          <td class="paramtype">WCO_Type const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reports the current value of combined C1-C0 cascaded counters. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure that describes the registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Enable both counters, and cascade C0 to C1 before calling this function. C2 is not reported. Instead, to get a 64-bit C2-C1-C0 cascaded value, call this function followed by Cy_WDC_GetCount(base, CY_WDC_COUNTER2), and then combine the results. </dd>
<dd>
This function does not return the correct result when it is called after the <a class="el" href="group__group__wdc__functions.html#gabd2a4e06b7fc76f8738cc1e721d30758" title="Enables all specified counters. ">Cy_WDC_Enable()</a> or <a class="el" href="group__group__wdc__functions.html#gaed5a60e3e0d0a28dd11a439a2ee6a44c" title="Resets all specified counters. ">Cy_WDC_ResetCounters()</a> function with a delay less than three WDC clock source cycles. The recommended waitUs parameter value is defined by <a class="el" href="group__group__wdc__macros.html#ga44e4ac9709fed40c64661c25aa870abb">CY_WDC_CLK_ILO_3CYCLES_US</a> and <a class="el" href="group__group__wdc__macros.html#ga3bfe527fe6efeeb9098af1b14a827413">CY_WDC_CLK_WCO_3CYCLES_US</a> macros.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The value of combined C1-C0 cascaded counters. </dd></dl>

</div>
</div>
<a id="ga6665c7166cac0a5db3ac3b1ffc0d8dcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6665c7166cac0a5db3ac3b1ffc0d8dcf">&#9670;&nbsp;</a></span>Cy_WDC_GetClockSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group__group__wdc__enums.html#ga2f558686b71ae60686d9c3ba6f17e6ba">cy_en_wdc_clock_t</a> Cy_WDC_GetClockSource </td>
          <td>(</td>
          <td class="paramtype">WCO_Type const *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the clock source for WDC timers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure describes registers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The WDC timers clock source. See <a class="el" href="group__group__wdc__enums.html#ga2f558686b71ae60686d9c3ba6f17e6ba">cy_en_wdc_clock_t</a> </dd></dl>

</div>
</div>
<a id="ga8bf6dc1302e9a8fc4d63f3fddbca6698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8bf6dc1302e9a8fc4d63f3fddbca6698">&#9670;&nbsp;</a></span>Cy_WDC_SetClockSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_WDC_SetClockSource </td>
          <td>(</td>
          <td class="paramtype">WCO_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__wdc__enums.html#ga2f558686b71ae60686d9c3ba6f17e6ba">cy_en_wdc_clock_t</a>&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the clock source for WDC timers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The base pointer to a structure describes registers.</td></tr>
    <tr><td class="paramname">source</td><td>WDC timers clock source. See <a class="el" href="group__group__wdc__enums.html#ga2f558686b71ae60686d9c3ba6f17e6ba">cy_en_wdc_clock_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>WDC reset is required if counters source was switched while any of the counters were running. Call the <a class="el" href="group__group__wdc__functions.html#gaed5a60e3e0d0a28dd11a439a2ee6a44c" title="Resets all specified counters. ">Cy_WDC_ResetCounters()</a> function after WDC source switching. It is highly recommended to disable WDC before clock source switching. Changing the WDC clock source may change the functionality that uses WDC as the clock source. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>CAT2 Peripheral Driver Library</b> by <b>Infineon Technologies</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
