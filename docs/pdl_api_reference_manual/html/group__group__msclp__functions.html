<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CAT2 Peripheral Driver Library: Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen_style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a href="http://www.cypress.com/"><img alt="Logo" src="logo.png"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CAT2 Peripheral Driver Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__group__msclp__functions.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Functions<div class="ingroups"><a class="el" href="group__group__msclp.html">MSCLP        (Multi-Sense Converter Low-Power)</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">General Description</h2>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gab88f9fb6678c6dcbce2e0e10b52c591b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__msclp__enums.html#ga6c70f9f61712d865a792069871ebc2c6">cy_en_msclp_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__msclp__functions.html#gab88f9fb6678c6dcbce2e0e10b52c591b">Cy_MSCLP_Init</a> (MSCLP_Type *base, <a class="el" href="structcy__stc__msclp__base__config__t.html">cy_stc_msclp_base_config_t</a> const *config, <a class="el" href="group__group__msclp__enums.html#ga4f743c2a5c581346b50ed3edffabd110">cy_en_msclp_key_t</a> key, <a class="el" href="structcy__stc__msclp__context__t.html">cy_stc_msclp_context_t</a> *context)</td></tr>
<tr class="memdesc:gab88f9fb6678c6dcbce2e0e10b52c591b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires, locks, and configures the MSCLP HW block.  <a href="#gab88f9fb6678c6dcbce2e0e10b52c591b">More...</a><br /></td></tr>
<tr class="separator:gab88f9fb6678c6dcbce2e0e10b52c591b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84f5cac24a46e7dd70c045f28ebcc83f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__msclp__enums.html#ga6c70f9f61712d865a792069871ebc2c6">cy_en_msclp_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__msclp__functions.html#ga84f5cac24a46e7dd70c045f28ebcc83f">Cy_MSCLP_DeInit</a> (MSCLP_Type *base, <a class="el" href="group__group__msclp__enums.html#ga4f743c2a5c581346b50ed3edffabd110">cy_en_msclp_key_t</a> key, <a class="el" href="structcy__stc__msclp__context__t.html">cy_stc_msclp_context_t</a> *context)</td></tr>
<tr class="memdesc:ga84f5cac24a46e7dd70c045f28ebcc83f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases the MSCLP HW block previously captured and locked by the caller.  <a href="#ga84f5cac24a46e7dd70c045f28ebcc83f">More...</a><br /></td></tr>
<tr class="separator:ga84f5cac24a46e7dd70c045f28ebcc83f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4da10a0d955a9d392fd69f867015ecc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__msclp__enums.html#ga6c70f9f61712d865a792069871ebc2c6">cy_en_msclp_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__msclp__functions.html#gac4da10a0d955a9d392fd69f867015ecc">Cy_MSCLP_Capture</a> (MSCLP_Type *base, <a class="el" href="group__group__msclp__enums.html#ga4f743c2a5c581346b50ed3edffabd110">cy_en_msclp_key_t</a> key, <a class="el" href="structcy__stc__msclp__context__t.html">cy_stc_msclp_context_t</a> *context)</td></tr>
<tr class="memdesc:gac4da10a0d955a9d392fd69f867015ecc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Acquires and locks the MSCLP HW block without changing its configuration.  <a href="#gac4da10a0d955a9d392fd69f867015ecc">More...</a><br /></td></tr>
<tr class="separator:gac4da10a0d955a9d392fd69f867015ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad2313869c5ba6da379a38541ede0702c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__msclp__enums.html#ga6c70f9f61712d865a792069871ebc2c6">cy_en_msclp_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__msclp__functions.html#gad2313869c5ba6da379a38541ede0702c">Cy_MSCLP_Configure</a> (MSCLP_Type *base, const <a class="el" href="structcy__stc__msclp__base__config__t.html">cy_stc_msclp_base_config_t</a> *config, <a class="el" href="group__group__msclp__enums.html#ga4f743c2a5c581346b50ed3edffabd110">cy_en_msclp_key_t</a> key, const <a class="el" href="structcy__stc__msclp__context__t.html">cy_stc_msclp_context_t</a> *context)</td></tr>
<tr class="memdesc:gad2313869c5ba6da379a38541ede0702c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets configuration of all MSCLP HW block registers at once.  <a href="#gad2313869c5ba6da379a38541ede0702c">More...</a><br /></td></tr>
<tr class="separator:gad2313869c5ba6da379a38541ede0702c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga584c38e61b0b62eb706e0dccdeafb29b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__msclp__enums.html#ga6c70f9f61712d865a792069871ebc2c6">cy_en_msclp_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__msclp__functions.html#ga584c38e61b0b62eb706e0dccdeafb29b">Cy_MSCLP_MrssStart</a> (MSCLP_Type *base, <a class="el" href="structcy__stc__msclp__mrss__config__t.html">cy_stc_msclp_mrss_config_t</a> const *mrssCfg, <a class="el" href="group__group__msclp__enums.html#ga4f743c2a5c581346b50ed3edffabd110">cy_en_msclp_key_t</a> key, <a class="el" href="structcy__stc__msclp__context__t.html">cy_stc_msclp_context_t</a> const *context)</td></tr>
<tr class="memdesc:ga584c38e61b0b62eb706e0dccdeafb29b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns on the MRSS resources.  <a href="#ga584c38e61b0b62eb706e0dccdeafb29b">More...</a><br /></td></tr>
<tr class="separator:ga584c38e61b0b62eb706e0dccdeafb29b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaec5cf0ee02f031beefe3c6f9df0d589c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__msclp__enums.html#ga6c70f9f61712d865a792069871ebc2c6">cy_en_msclp_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__msclp__functions.html#gaec5cf0ee02f031beefe3c6f9df0d589c">Cy_MSCLP_MrssStop</a> (MSCLP_Type *base, <a class="el" href="group__group__msclp__enums.html#ga4f743c2a5c581346b50ed3edffabd110">cy_en_msclp_key_t</a> key, <a class="el" href="structcy__stc__msclp__context__t.html">cy_stc_msclp_context_t</a> const *context)</td></tr>
<tr class="memdesc:gaec5cf0ee02f031beefe3c6f9df0d589c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns off the MRSS resources.  <a href="#gaec5cf0ee02f031beefe3c6f9df0d589c">More...</a><br /></td></tr>
<tr class="separator:gaec5cf0ee02f031beefe3c6f9df0d589c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6480a3509749f6272421f8a72b52fa95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__msclp__enums.html#ga6c70f9f61712d865a792069871ebc2c6">cy_en_msclp_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__msclp__functions.html#ga6480a3509749f6272421f8a72b52fa95">Cy_MSCLP_MrssStatus</a> (MSCLP_Type *base, <a class="el" href="group__group__msclp__enums.html#ga4f743c2a5c581346b50ed3edffabd110">cy_en_msclp_key_t</a> key, <a class="el" href="structcy__stc__msclp__context__t.html">cy_stc_msclp_context_t</a> const *context)</td></tr>
<tr class="memdesc:ga6480a3509749f6272421f8a72b52fa95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the MRSS status (enabled/disabled).  <a href="#ga6480a3509749f6272421f8a72b52fa95">More...</a><br /></td></tr>
<tr class="separator:ga6480a3509749f6272421f8a72b52fa95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga710830f1768cc249d9c63fd688609157"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__msclp__functions.html#ga710830f1768cc249d9c63fd688609157">Cy_MSCLP_ConfigureScan</a> (MSCLP_Type *base, uint32_t numRegs, const uint32_t *scanConfig)</td></tr>
<tr class="memdesc:ga710830f1768cc249d9c63fd688609157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets configuration of sensor frame registers of the MSCLP HW block and starts the scan.  <a href="#ga710830f1768cc249d9c63fd688609157">More...</a><br /></td></tr>
<tr class="separator:ga710830f1768cc249d9c63fd688609157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacbb10faa7cadd1a5c423841aa34b96ba"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group__group__msclp__enums.html#ga4f743c2a5c581346b50ed3edffabd110">cy_en_msclp_key_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__msclp__functions.html#gacbb10faa7cadd1a5c423841aa34b96ba">Cy_MSCLP_GetLockStatus</a> (const MSCLP_Type *base, const <a class="el" href="structcy__stc__msclp__context__t.html">cy_stc_msclp_context_t</a> *context)</td></tr>
<tr class="memdesc:gacbb10faa7cadd1a5c423841aa34b96ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies whether the specified MSCLP HW block is acquired and locked by a higher-level firmware.  <a href="#gacbb10faa7cadd1a5c423841aa34b96ba">More...</a><br /></td></tr>
<tr class="separator:gacbb10faa7cadd1a5c423841aa34b96ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c201f62dfb14998f68998372bc2fd66"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE <a class="el" href="group__group__msclp__enums.html#ga6c70f9f61712d865a792069871ebc2c6">cy_en_msclp_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__msclp__functions.html#ga8c201f62dfb14998f68998372bc2fd66">Cy_MSCLP_GetConversionStatus</a> (const MSCLP_Type *base, const <a class="el" href="structcy__stc__msclp__context__t.html">cy_stc_msclp_context_t</a> *context)</td></tr>
<tr class="memdesc:ga8c201f62dfb14998f68998372bc2fd66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verifies whether the specified MSCLP HW block is busy (performing scan or conversion).  <a href="#ga8c201f62dfb14998f68998372bc2fd66">More...</a><br /></td></tr>
<tr class="separator:ga8c201f62dfb14998f68998372bc2fd66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4afecc1a0e8b5a03c3a8a48e17fa97b"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__msclp__functions.html#gad4afecc1a0e8b5a03c3a8a48e17fa97b">Cy_MSCLP_ReadReg</a> (const MSCLP_Type *base, uint32_t offset)</td></tr>
<tr class="memdesc:gad4afecc1a0e8b5a03c3a8a48e17fa97b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads value from the specified the MSCLP HW block register.  <a href="#gad4afecc1a0e8b5a03c3a8a48e17fa97b">More...</a><br /></td></tr>
<tr class="separator:gad4afecc1a0e8b5a03c3a8a48e17fa97b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae95636218ca61f5995e5c9e2f4a5e681"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__msclp__functions.html#gae95636218ca61f5995e5c9e2f4a5e681">Cy_MSCLP_WriteReg</a> (MSCLP_Type *base, uint32_t offset, uint32_t value)</td></tr>
<tr class="memdesc:gae95636218ca61f5995e5c9e2f4a5e681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a value to the specified MSCLP HW block register.  <a href="#gae95636218ca61f5995e5c9e2f4a5e681">More...</a><br /></td></tr>
<tr class="separator:gae95636218ca61f5995e5c9e2f4a5e681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d3bda261a970e35febe56b8f24f5b5e"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__msclp__functions.html#ga0d3bda261a970e35febe56b8f24f5b5e">Cy_MSCLP_SetBits</a> (MSCLP_Type *base, uint32_t offset, uint32_t mask)</td></tr>
<tr class="memdesc:ga0d3bda261a970e35febe56b8f24f5b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets bits, specified by the Mask parameter in the MSCLP HW block register, specified by the Offset parameter.  <a href="#ga0d3bda261a970e35febe56b8f24f5b5e">More...</a><br /></td></tr>
<tr class="separator:ga0d3bda261a970e35febe56b8f24f5b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59e30fcf670020dac1ff55e973b4aa11"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__msclp__functions.html#ga59e30fcf670020dac1ff55e973b4aa11">Cy_MSCLP_ClrBits</a> (MSCLP_Type *base, uint32_t offset, uint32_t mask)</td></tr>
<tr class="memdesc:ga59e30fcf670020dac1ff55e973b4aa11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears bits, specified by the Mask parameter in the MSCLP HW block register, specified by the Offset parameter.  <a href="#ga59e30fcf670020dac1ff55e973b4aa11">More...</a><br /></td></tr>
<tr class="separator:ga59e30fcf670020dac1ff55e973b4aa11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7ac16bc23b02372a365ab077df9ccdc"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__msclp__functions.html#gaa7ac16bc23b02372a365ab077df9ccdc">Cy_MSCLP_WriteBits</a> (MSCLP_Type *base, uint32_t offset, uint32_t mask, uint32_t value)</td></tr>
<tr class="memdesc:gaa7ac16bc23b02372a365ab077df9ccdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes field, specified by the Mask parameter with the value, specified by the Value parameter.  <a href="#gaa7ac16bc23b02372a365ab077df9ccdc">More...</a><br /></td></tr>
<tr class="separator:gaa7ac16bc23b02372a365ab077df9ccdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2dc66f47124f88bacc39d3216d1753f4"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__msclp__functions.html#ga2dc66f47124f88bacc39d3216d1753f4">Cy_MSCLP_SwStartFrame</a> (MSCLP_Type *base)</td></tr>
<tr class="memdesc:ga2dc66f47124f88bacc39d3216d1753f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function initiates the non-blocking scan of an entire configured frame by launch the MSCLP HW block state machine.  <a href="#ga2dc66f47124f88bacc39d3216d1753f4">More...</a><br /></td></tr>
<tr class="separator:ga2dc66f47124f88bacc39d3216d1753f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4474b04c151ac7d009df1c79ca4a4427"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__msclp__functions.html#ga4474b04c151ac7d009df1c79ca4a4427">Cy_MSCLP_SwStartAosFrame</a> (MSCLP_Type *base)</td></tr>
<tr class="memdesc:ga4474b04c151ac7d009df1c79ca4a4427"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function initiates the non-blocking scan of an entire configured frame by launch the MSCLP HW block state machine.  <a href="#ga4474b04c151ac7d009df1c79ca4a4427">More...</a><br /></td></tr>
<tr class="separator:ga4474b04c151ac7d009df1c79ca4a4427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f34c6fdcb08b1eaca1c0ea71f03d6fd"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__msclp__functions.html#ga7f34c6fdcb08b1eaca1c0ea71f03d6fd">Cy_MSCLP_ReadSensorDataWord</a> (MSCLP_Type const *base, uint32_t addr)</td></tr>
<tr class="memdesc:ga7f34c6fdcb08b1eaca1c0ea71f03d6fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads one 32-bit data word from the SNS.SENSOR_DATA memory.  <a href="#ga7f34c6fdcb08b1eaca1c0ea71f03d6fd">More...</a><br /></td></tr>
<tr class="separator:ga7f34c6fdcb08b1eaca1c0ea71f03d6fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga018be5fbfee42c9dbe9c44141d4981a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__msclp__functions.html#ga018be5fbfee42c9dbe9c44141d4981a6">Cy_MSCLP_ReadSensorDataArray</a> (MSCLP_Type const *base, uint32_t startAddr, uint32_t *ptrData, uint32_t dataSize)</td></tr>
<tr class="memdesc:ga018be5fbfee42c9dbe9c44141d4981a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an array of 32-bit data words from the SNS.SENSOR_DATA memory.  <a href="#ga018be5fbfee42c9dbe9c44141d4981a6">More...</a><br /></td></tr>
<tr class="separator:ga018be5fbfee42c9dbe9c44141d4981a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7db677f341541e3bf2209e4ea3eb3cb3"><td class="memItemLeft" align="right" valign="top">__STATIC_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__msclp__functions.html#ga7db677f341541e3bf2209e4ea3eb3cb3">Cy_MSCLP_WriteSensorDataWord</a> (MSCLP_Type *base, uint32_t addr, uint32_t data)</td></tr>
<tr class="memdesc:ga7db677f341541e3bf2209e4ea3eb3cb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes one 32-bit data word into the SNS.SENSOR_DATA memory.  <a href="#ga7db677f341541e3bf2209e4ea3eb3cb3">More...</a><br /></td></tr>
<tr class="separator:ga7db677f341541e3bf2209e4ea3eb3cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b1725797fa255e2d344a68b9e5d603d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__group__msclp__enums.html#ga6c70f9f61712d865a792069871ebc2c6">cy_en_msclp_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__group__msclp__functions.html#ga8b1725797fa255e2d344a68b9e5d603d">Cy_MSCLP_WriteSensorDataArray</a> (MSCLP_Type *base, uint32_t startAddr, uint32_t const *ptrData, uint32_t dataSize)</td></tr>
<tr class="memdesc:ga8b1725797fa255e2d344a68b9e5d603d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an array of 32-bit data words into the SNS.SENSOR_DATA memory.  <a href="#ga8b1725797fa255e2d344a68b9e5d603d">More...</a><br /></td></tr>
<tr class="separator:ga8b1725797fa255e2d344a68b9e5d603d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab88f9fb6678c6dcbce2e0e10b52c591b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab88f9fb6678c6dcbce2e0e10b52c591b">&#9670;&nbsp;</a></span>Cy_MSCLP_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__msclp__enums.html#ga6c70f9f61712d865a792069871ebc2c6">cy_en_msclp_status_t</a> Cy_MSCLP_Init </td>
          <td>(</td>
          <td class="paramtype">MSCLP_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__msclp__base__config__t.html">cy_stc_msclp_base_config_t</a> const *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__msclp__enums.html#ga4f743c2a5c581346b50ed3edffabd110">cy_en_msclp_key_t</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__msclp__context__t.html">cy_stc_msclp_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquires, locks, and configures the MSCLP HW block. </p>
<p>If the MSCLP HW block is already in use by other middleware or by the application program, the function returns the CY_MSCLP_LOCKED status and does not configure the MSCLP HW block.</p>
<p>If the acquisition is successful, this function writes configuration data into all MSCLP HW block registers (except read-only registers and SEQ_START register) at once. Because the SEQ_START register is excluded from write, use the <a class="el" href="group__group__msclp__functions.html#gae95636218ca61f5995e5c9e2f4a5e681" title="Writes a value to the specified MSCLP HW block register. ">Cy_MSCLP_WriteReg()</a> function to trigger the state machine for scan or conversion.</p>
<p>To capture the MSCLP block without its reconfiguration use the <a class="el" href="group__group__msclp__functions.html#gac4da10a0d955a9d392fd69f867015ecc" title="Acquires and locks the MSCLP HW block without changing its configuration. ">Cy_MSCLP_Capture()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to a MSCLP HW block base address.</td></tr>
    <tr><td class="paramname">config</td><td>The pointer to a configuration structure that contains the initial configuration.</td></tr>
    <tr><td class="paramname">key</td><td>The ID of middleware or a user-level function to work with the specified MSCLP HW block.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the context structure allocated by the user or middleware.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the operation result status (MSCLP status code). See <a class="el" href="group__group__msclp__enums.html#ga6c70f9f61712d865a792069871ebc2c6">cy_en_msclp_status_t</a>.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">    * Scenario: Capture MSCLP HW block to perform a conversion.</span></div><div class="line"><span class="comment">    * This scenario does not cover Pins, Clock, Interrupt, configuration.</span></div><div class="line"><span class="comment">    */</span></div><div class="line"></div><div class="line">    <span class="comment">/*...*/</span></div><div class="line">    <a class="code" href="group__group__msclp__enums.html#ga4f743c2a5c581346b50ed3edffabd110">cy_en_msclp_key_t</a> key;</div><div class="line">    <a class="code" href="group__group__msclp__enums.html#ga6c70f9f61712d865a792069871ebc2c6">cy_en_msclp_status_t</a> status;</div><div class="line"></div><div class="line">    <span class="comment">/* Allocates MSCLP configuration structure and initialize it with user&#39;s configuration */</span></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structcy__stc__msclp__base__config__t.html">cy_stc_msclp_base_config_t</a> customConfig = CUSTOM_CONFIG;</div><div class="line"></div><div class="line">    <span class="comment">/* Checks if the MSCLP block if free */</span></div><div class="line">    key = <a class="code" href="group__group__msclp__functions.html#gacbb10faa7cadd1a5c423841aa34b96ba">Cy_MSCLP_GetLockStatus</a>(MSCLP0, &amp;msclpContext);</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__msclp__enums.html#gga4f743c2a5c581346b50ed3edffabd110a10fac4e96644a843bc7e802419529339">CY_MSCLP_NONE_KEY</a> == key)</div><div class="line">    {</div><div class="line">        <span class="comment">/* Captures the MSCLP block and initialize it with user&#39;s configuration */</span></div><div class="line">        status = <a class="code" href="group__group__msclp__functions.html#gab88f9fb6678c6dcbce2e0e10b52c591b">Cy_MSCLP_Init</a>(MSCLP0, &amp;customConfig, <a class="code" href="group__group__msclp__enums.html#gga4f743c2a5c581346b50ed3edffabd110a7e2e65977016de0e807623b718dd5f2e">CY_MSCLP_USER_DEFINED_KEY</a>, &amp;msclpContext);</div><div class="line">        <span class="comment">/* Checks if the MSCLP block was captured successfully */</span></div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="group__group__msclp__enums.html#gga6c70f9f61712d865a792069871ebc2c6ac5845dddb5cce0780bf47a69b0fb5b4d">CY_MSCLP_SUCCESS</a> == status)</div><div class="line">        {</div><div class="line">            <span class="comment">/* Block is captured successfully. User&#39;s application code can be placed and executed here. */</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">    <span class="comment">/*...*/</span></div><div class="line"></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga84f5cac24a46e7dd70c045f28ebcc83f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84f5cac24a46e7dd70c045f28ebcc83f">&#9670;&nbsp;</a></span>Cy_MSCLP_DeInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__msclp__enums.html#ga6c70f9f61712d865a792069871ebc2c6">cy_en_msclp_status_t</a> Cy_MSCLP_DeInit </td>
          <td>(</td>
          <td class="paramtype">MSCLP_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__msclp__enums.html#ga4f743c2a5c581346b50ed3edffabd110">cy_en_msclp_key_t</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__msclp__context__t.html">cy_stc_msclp_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases the MSCLP HW block previously captured and locked by the caller. </p>
<p>If the MSCLP HW block is acquired by another caller or the block is in the busy state (performing scan or conversion), the de-initialization request is ignored and the corresponding status is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to a MSCLP HW block base address.</td></tr>
    <tr><td class="paramname">key</td><td>The ID of middleware or a user-level function to work with the specified MSCLP HW block.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the context structure allocated by the user or middleware.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the operation result status (MSCLP status code). See <a class="el" href="group__group__msclp__enums.html#ga6c70f9f61712d865a792069871ebc2c6">cy_en_msclp_status_t</a>. </dd></dl>

</div>
</div>
<a id="gac4da10a0d955a9d392fd69f867015ecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac4da10a0d955a9d392fd69f867015ecc">&#9670;&nbsp;</a></span>Cy_MSCLP_Capture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__msclp__enums.html#ga6c70f9f61712d865a792069871ebc2c6">cy_en_msclp_status_t</a> Cy_MSCLP_Capture </td>
          <td>(</td>
          <td class="paramtype">MSCLP_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__msclp__enums.html#ga4f743c2a5c581346b50ed3edffabd110">cy_en_msclp_key_t</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__msclp__context__t.html">cy_stc_msclp_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Acquires and locks the MSCLP HW block without changing its configuration. </p>
<p>If the MSCLP HW block is already in use by other middleware or by the application program, then the function returns the CY_MSCLP_LOCKED status.</p>
<dl class="section note"><dt>Note</dt><dd>This is a low-level function. Use the <a class="el" href="group__group__msclp__functions.html#gab88f9fb6678c6dcbce2e0e10b52c591b" title="Acquires, locks, and configures the MSCLP HW block. ">Cy_MSCLP_Init()</a> function instead. The <a class="el" href="group__group__msclp__functions.html#gac4da10a0d955a9d392fd69f867015ecc" title="Acquires and locks the MSCLP HW block without changing its configuration. ">Cy_MSCLP_Capture()</a> function is used by upper-level middleware to improve efficiency. It also can be used to implement specific use cases. If this function is used, configure the MSCLP block using the <a class="el" href="group__group__msclp__functions.html#gad2313869c5ba6da379a38541ede0702c" title="Sets configuration of all MSCLP HW block registers at once. ">Cy_MSCLP_Configure()</a> function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to a MSCLP HW block base address.</td></tr>
    <tr><td class="paramname">key</td><td>The ID of middleware or a user-level function to work with the specified MSCLP HW block.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the context structure allocated by the user or middleware.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the operation result status (MSCLP status code). See <a class="el" href="group__group__msclp__enums.html#ga6c70f9f61712d865a792069871ebc2c6">cy_en_msclp_status_t</a>.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">    * Scenario: Capture the already configured MSCLP HW block.</span></div><div class="line"><span class="comment">    * This scenario does not cover Pins, Clock, Interrupt, configuration.</span></div><div class="line"><span class="comment">    */</span></div><div class="line"></div><div class="line">    <span class="comment">/* Checks if the MSCLP block if free */</span></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__msclp__enums.html#gga4f743c2a5c581346b50ed3edffabd110a10fac4e96644a843bc7e802419529339">CY_MSCLP_NONE_KEY</a> == <a class="code" href="group__group__msclp__functions.html#gacbb10faa7cadd1a5c423841aa34b96ba">Cy_MSCLP_GetLockStatus</a>(MSCLP0, &amp;msclpContext))</div><div class="line">    {</div><div class="line">        <span class="comment">/* Captures the MSCLP block */</span></div><div class="line">        <span class="keywordflow">if</span> (<a class="code" href="group__group__msclp__enums.html#gga6c70f9f61712d865a792069871ebc2c6ac5845dddb5cce0780bf47a69b0fb5b4d">CY_MSCLP_SUCCESS</a> == <a class="code" href="group__group__msclp__functions.html#gac4da10a0d955a9d392fd69f867015ecc">Cy_MSCLP_Capture</a>(MSCLP0, <a class="code" href="group__group__msclp__enums.html#gga4f743c2a5c581346b50ed3edffabd110a7e2e65977016de0e807623b718dd5f2e">CY_MSCLP_USER_DEFINED_KEY</a>, &amp;msclpContext))</div><div class="line">        {</div><div class="line">            <span class="comment">/* Block is captured successfully. The user&#39;s application code can be placed and executed here. */</span></div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">        {</div><div class="line">            <span class="comment">/* The block capture has failed. Probably, it was already captured by another process. */</span></div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="gad2313869c5ba6da379a38541ede0702c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad2313869c5ba6da379a38541ede0702c">&#9670;&nbsp;</a></span>Cy_MSCLP_Configure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__msclp__enums.html#ga6c70f9f61712d865a792069871ebc2c6">cy_en_msclp_status_t</a> Cy_MSCLP_Configure </td>
          <td>(</td>
          <td class="paramtype">MSCLP_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__stc__msclp__base__config__t.html">cy_stc_msclp_base_config_t</a> *&#160;</td>
          <td class="paramname"><em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__msclp__enums.html#ga4f743c2a5c581346b50ed3edffabd110">cy_en_msclp_key_t</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__stc__msclp__context__t.html">cy_stc_msclp_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets configuration of all MSCLP HW block registers at once. </p>
<p>This function writes configuration data into all MSCLP block registers (except read-only registers and the SEQ_START register) at once. Because the SEQ_START register is excluded from write, use the <a class="el" href="group__group__msclp__functions.html#gae95636218ca61f5995e5c9e2f4a5e681" title="Writes a value to the specified MSCLP HW block register. ">Cy_MSCLP_WriteReg()</a> function to perform triggering state machine for scan or conversion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to a MSCLP HW block base address.</td></tr>
    <tr><td class="paramname">config</td><td>The pointer to a configuration structure that contains initial configuration.</td></tr>
    <tr><td class="paramname">key</td><td>The ID of middleware or a user-level function to work with the specified MSCLP HW block.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the context structure allocated by the user or middleware.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the operation result status (MSCLP status code). See <a class="el" href="group__group__msclp__enums.html#ga6c70f9f61712d865a792069871ebc2c6">cy_en_msclp_status_t</a>. </dd></dl>

</div>
</div>
<a id="ga584c38e61b0b62eb706e0dccdeafb29b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga584c38e61b0b62eb706e0dccdeafb29b">&#9670;&nbsp;</a></span>Cy_MSCLP_MrssStart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__msclp__enums.html#ga6c70f9f61712d865a792069871ebc2c6">cy_en_msclp_status_t</a> Cy_MSCLP_MrssStart </td>
          <td>(</td>
          <td class="paramtype">MSCLP_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__msclp__mrss__config__t.html">cy_stc_msclp_mrss_config_t</a> const *&#160;</td>
          <td class="paramname"><em>mrssCfg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__msclp__enums.html#ga4f743c2a5c581346b50ed3edffabd110">cy_en_msclp_key_t</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__msclp__context__t.html">cy_stc_msclp_context_t</a> const *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turns on the MRSS resources. </p>
<p>Checks the system defined VDDA value and turns on PUMP if VDDA is less then the threshold defined by the CY_MSCLP_VDDA_PUMP_TRESHOLD macro, else turns on only REF and IMO.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to a MSCLP HW block base address.</td></tr>
    <tr><td class="paramname">mrssCfg</td><td>The pointer to the MRSS configuration structure <a class="el" href="structcy__stc__msclp__mrss__config__t.html">cy_stc_msclp_mrss_config_t</a>.</td></tr>
    <tr><td class="paramname">key</td><td>The ID of middleware or a user-level function to work with the specified MSCLP HW block <a class="el" href="group__group__msclp__enums.html#ga4f743c2a5c581346b50ed3edffabd110">cy_en_msclp_key_t</a>.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the context structure allocated by the user or middleware.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the operation:<ul>
<li>CY_MSCLP_SUCCESS - The MRSS have been started successfully</li>
<li>CY_MSCLP_BAD_PARAM - One or more invalid input parameters</li>
<li>CY_MSCLP_LOCKED - The MSCLP HW block is captured by another middleware</li>
<li>CY_MSCLP_TIMEOUT - It is a timeout reached while the MRSS start. The timeout value is defined as a multiplication of the CY_MSCLP_CLK_LF_PERIOD_MAX and CY_MSCLP_MRSS_TIMEOUT_FULL or CY_MSCLP_MRSS_TIMEOUT macros </li>
</ul>
</dd></dl>

</div>
</div>
<a id="gaec5cf0ee02f031beefe3c6f9df0d589c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaec5cf0ee02f031beefe3c6f9df0d589c">&#9670;&nbsp;</a></span>Cy_MSCLP_MrssStop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__msclp__enums.html#ga6c70f9f61712d865a792069871ebc2c6">cy_en_msclp_status_t</a> Cy_MSCLP_MrssStop </td>
          <td>(</td>
          <td class="paramtype">MSCLP_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__msclp__enums.html#ga4f743c2a5c581346b50ed3edffabd110">cy_en_msclp_key_t</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__msclp__context__t.html">cy_stc_msclp_context_t</a> const *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turns off the MRSS resources. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to a MSCLP HW block base address.</td></tr>
    <tr><td class="paramname">key</td><td>The ID of middleware or a user-level function to work with the specified MSCLP HW block.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the context structure allocated by the user or middleware.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the operation:<ul>
<li>CY_MSCLP_SUCCESS - The MRSS have been stopped successfully.</li>
<li>CY_MSCLP_BAD_PARAM - One or more invalid input parameters</li>
<li>CY_MSCLP_LOCKED - The MSCLP HW block is captured by another middleware</li>
<li>CY_MSCLP_TIMEOUT - The timeout is reached while the MRSS stop. The timeout value is defined by the CY_MSCLP_CLK_LF_PERIOD_MAX macro </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga6480a3509749f6272421f8a72b52fa95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6480a3509749f6272421f8a72b52fa95">&#9670;&nbsp;</a></span>Cy_MSCLP_MrssStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__msclp__enums.html#ga6c70f9f61712d865a792069871ebc2c6">cy_en_msclp_status_t</a> Cy_MSCLP_MrssStatus </td>
          <td>(</td>
          <td class="paramtype">MSCLP_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__group__msclp__enums.html#ga4f743c2a5c581346b50ed3edffabd110">cy_en_msclp_key_t</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcy__stc__msclp__context__t.html">cy_stc_msclp_context_t</a> const *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the MRSS status (enabled/disabled). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to a MSCLP HW block base address.</td></tr>
    <tr><td class="paramname">key</td><td>The ID of middleware or a user-level function to work with the specified MSCLP HW block.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the context structure allocated by the user or middleware.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the operation:<ul>
<li>CY_MSCLP_SUCCESS - The MRSS is enabled</li>
<li>CY_MSCLP_MRSS_DISABLED - The MRSS is disabled</li>
<li>CY_MSCLP_BAD_PARAM - One or more invalid input parameters</li>
<li>CY_MSCLP_LOCKED - The MSCLP HW block is captured by another middleware </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga710830f1768cc249d9c63fd688609157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga710830f1768cc249d9c63fd688609157">&#9670;&nbsp;</a></span>Cy_MSCLP_ConfigureScan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_MSCLP_ConfigureScan </td>
          <td>(</td>
          <td class="paramtype">MSCLP_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>numRegs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t *&#160;</td>
          <td class="paramname"><em>scanConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets configuration of sensor frame registers of the MSCLP HW block and starts the scan. </p>
<dl class="section note"><dt>Note</dt><dd>Accessing the SNS group registers under disabled MRSS might lead to the device hard fault. Therefore, access the SNS group registers of the MSCLP HW block only under enabled MRSS. To enable, disable or check the MRSS power status, use the <a class="el" href="group__group__msclp__functions.html#ga584c38e61b0b62eb706e0dccdeafb29b" title="Turns on the MRSS resources. ">Cy_MSCLP_MrssStart()</a>, <a class="el" href="group__group__msclp__functions.html#gaec5cf0ee02f031beefe3c6f9df0d589c" title="Turns off the MRSS resources. ">Cy_MSCLP_MrssStop()</a> or <a class="el" href="group__group__msclp__functions.html#ga6480a3509749f6272421f8a72b52fa95" title="Returns the MRSS status (enabled/disabled). ">Cy_MSCLP_MrssStatus()</a> functions respectively.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Pointer to a MSCLP HW block base address.</td></tr>
    <tr><td class="paramname">numRegs</td><td>Number of registers in scan configuration written into MSCLP HW block. Possible values are <a class="el" href="group__group__msclp__macros.html#gad02e3b50c0879b12a53fca235d8c738a">CY_MSCLP_6_SNS_REGS</a> and <a class="el" href="group__group__msclp__macros.html#ga8b9e9bf2b7ba193d11f492eebb3050e3">CY_MSCLP_11_SNS_REGS</a>. CY_MSCLP_5_SNS_REGS is also supported.</td></tr>
    <tr><td class="paramname">scanConfig</td><td>The pointer to a scan configuration structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gacbb10faa7cadd1a5c423841aa34b96ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacbb10faa7cadd1a5c423841aa34b96ba">&#9670;&nbsp;</a></span>Cy_MSCLP_GetLockStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group__group__msclp__enums.html#ga4f743c2a5c581346b50ed3edffabd110">cy_en_msclp_key_t</a> Cy_MSCLP_GetLockStatus </td>
          <td>(</td>
          <td class="paramtype">const MSCLP_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__stc__msclp__context__t.html">cy_stc_msclp_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies whether the specified MSCLP HW block is acquired and locked by a higher-level firmware. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Pointer to a MSCLP HW block base address.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the context structure allocated by a user or middleware.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a key code. See <a class="el" href="group__group__msclp__enums.html#ga4f743c2a5c581346b50ed3edffabd110">cy_en_msclp_key_t</a>.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd></dd></dl>
<div class="fragment"><div class="line"></div><div class="line">    <a class="code" href="group__group__msclp__enums.html#ga4f743c2a5c581346b50ed3edffabd110">cy_en_msclp_key_t</a> key;</div><div class="line"></div><div class="line">    key = <a class="code" href="group__group__msclp__functions.html#gacbb10faa7cadd1a5c423841aa34b96ba">Cy_MSCLP_GetLockStatus</a>(MSCLP0, &amp;msclpContext);</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__msclp__enums.html#gga4f743c2a5c581346b50ed3edffabd110a10fac4e96644a843bc7e802419529339">CY_MSCLP_NONE_KEY</a> == key)</div><div class="line">    {</div><div class="line">        <span class="comment">/* The MSCLP block is not captured */</span></div><div class="line">    }</div><div class="line"></div></div><!-- fragment -->
</div>
</div>
<a id="ga8c201f62dfb14998f68998372bc2fd66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c201f62dfb14998f68998372bc2fd66">&#9670;&nbsp;</a></span>Cy_MSCLP_GetConversionStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE <a class="el" href="group__group__msclp__enums.html#ga6c70f9f61712d865a792069871ebc2c6">cy_en_msclp_status_t</a> Cy_MSCLP_GetConversionStatus </td>
          <td>(</td>
          <td class="paramtype">const MSCLP_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structcy__stc__msclp__context__t.html">cy_stc_msclp_context_t</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Verifies whether the specified MSCLP HW block is busy (performing scan or conversion). </p>
<dl class="section note"><dt>Note</dt><dd>Accessing the SNS group registers under disabled MRSS might lead to the device hard fault. Therefore, access the SNS group registers of the MSCLP HW block only under enabled MRSS. To enable, disable or check the MRSS power status, use the <a class="el" href="group__group__msclp__functions.html#ga584c38e61b0b62eb706e0dccdeafb29b" title="Turns on the MRSS resources. ">Cy_MSCLP_MrssStart()</a>, <a class="el" href="group__group__msclp__functions.html#gaec5cf0ee02f031beefe3c6f9df0d589c" title="Turns off the MRSS resources. ">Cy_MSCLP_MrssStop()</a> or <a class="el" href="group__group__msclp__functions.html#ga6480a3509749f6272421f8a72b52fa95" title="Returns the MRSS status (enabled/disabled). ">Cy_MSCLP_MrssStatus()</a> functions respectively.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Pointer to a MSCLP HW block base address.</td></tr>
    <tr><td class="paramname">context</td><td>The pointer to the context structure allocated by a user or middleware.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns status code. See <a class="el" href="group__group__msclp__enums.html#ga6c70f9f61712d865a792069871ebc2c6">cy_en_msclp_status_t</a>.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd></dd></dl>
<div class="fragment"><div class="line"></div><div class="line">    <a class="code" href="group__group__msclp__enums.html#ga6c70f9f61712d865a792069871ebc2c6">cy_en_msclp_status_t</a> status;</div><div class="line"></div><div class="line">    status = <a class="code" href="group__group__msclp__functions.html#ga8c201f62dfb14998f68998372bc2fd66">Cy_MSCLP_GetConversionStatus</a>(MSCLP0, &amp;msclpContext);</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="group__group__msclp__enums.html#gga6c70f9f61712d865a792069871ebc2c6a23bb677918565c692afa02b915c4eb72">CY_MSCLP_BUSY</a> == status)</div><div class="line">    {</div><div class="line">        <span class="comment">/* The MSCLP block is performing a conversion */</span></div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span></div><div class="line">    {</div><div class="line">        <span class="comment">/* The MSCLP block is not busy and a new conversion can be started */</span></div><div class="line">    }</div><div class="line"></div></div><!-- fragment -->
</div>
</div>
<a id="gad4afecc1a0e8b5a03c3a8a48e17fa97b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4afecc1a0e8b5a03c3a8a48e17fa97b">&#9670;&nbsp;</a></span>Cy_MSCLP_ReadReg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_MSCLP_ReadReg </td>
          <td>(</td>
          <td class="paramtype">const MSCLP_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads value from the specified the MSCLP HW block register. </p>
<dl class="section note"><dt>Note</dt><dd>Accessing the SNS group registers under disabled MRSS might lead to the device hard fault. Therefore, access the SNS group registers of the MSCLP HW block only under enabled MRSS. To enable, disable or check the MRSS power status, use the <a class="el" href="group__group__msclp__functions.html#ga584c38e61b0b62eb706e0dccdeafb29b" title="Turns on the MRSS resources. ">Cy_MSCLP_MrssStart()</a>, <a class="el" href="group__group__msclp__functions.html#gaec5cf0ee02f031beefe3c6f9df0d589c" title="Turns off the MRSS resources. ">Cy_MSCLP_MrssStop()</a> or <a class="el" href="group__group__msclp__functions.html#ga6480a3509749f6272421f8a72b52fa95" title="Returns the MRSS status (enabled/disabled). ">Cy_MSCLP_MrssStatus()</a> functions respectively.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Pointer to a MSCLP HW block base address.</td></tr>
    <tr><td class="paramname">offset</td><td>Register offset relative to base address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a value of the MSCLP HW block register, specified by the offset parameter.</dd></dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    <span class="keywordtype">void</span> snippet_Cy_MSCLP_IntHandler(<span class="keywordtype">void</span>)</div><div class="line">    {</div><div class="line">        uint32_t intrStatus;</div><div class="line"></div><div class="line">        <span class="comment">/* Reads interrupt status register */</span></div><div class="line">        intrStatus = <a class="code" href="group__group__msclp__functions.html#gad4afecc1a0e8b5a03c3a8a48e17fa97b">Cy_MSCLP_ReadReg</a>(MSCLP0, <a class="code" href="group__group__msclp__reg__const.html#ga44306b58f19961a02bdce02c5c818daa">CY_MSCLP_REG_OFFSET_INTR</a>);</div><div class="line"></div><div class="line">        <span class="comment">/* Checks the &#39;single scan is complete&#39; event that triggered the interrupt */</span></div><div class="line">        <span class="keywordflow">if</span> ((intrStatus &amp; MSCLP_INTR_SCAN_Msk) == MSCLP_INTR_SCAN_Msk)</div><div class="line">        {</div><div class="line">            <span class="comment">/* End of scan occurred, get the result and do something with it here */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* Clears the pending interrupts */</span></div><div class="line">        <a class="code" href="group__group__msclp__functions.html#gae95636218ca61f5995e5c9e2f4a5e681">Cy_MSCLP_WriteReg</a>(MSCLP0, <a class="code" href="group__group__msclp__reg__const.html#ga44306b58f19961a02bdce02c5c818daa">CY_MSCLP_REG_OFFSET_INTR</a>, intrStatus);</div><div class="line">        (void)<a class="code" href="group__group__msclp__functions.html#gad4afecc1a0e8b5a03c3a8a48e17fa97b">Cy_MSCLP_ReadReg</a>(MSCLP0, <a class="code" href="group__group__msclp__reg__const.html#ga44306b58f19961a02bdce02c5c818daa">CY_MSCLP_REG_OFFSET_INTR</a>);</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="gae95636218ca61f5995e5c9e2f4a5e681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae95636218ca61f5995e5c9e2f4a5e681">&#9670;&nbsp;</a></span>Cy_MSCLP_WriteReg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_MSCLP_WriteReg </td>
          <td>(</td>
          <td class="paramtype">MSCLP_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a value to the specified MSCLP HW block register. </p>
<dl class="section note"><dt>Note</dt><dd>Accessing the SNS group registers under disabled MRSS might lead to the device hard fault. Therefore, access the SNS group registers of the MSCLP HW block only under enabled MRSS. To enable, disable or check the MRSS power status, use the <a class="el" href="group__group__msclp__functions.html#ga584c38e61b0b62eb706e0dccdeafb29b" title="Turns on the MRSS resources. ">Cy_MSCLP_MrssStart()</a>, <a class="el" href="group__group__msclp__functions.html#gaec5cf0ee02f031beefe3c6f9df0d589c" title="Turns off the MRSS resources. ">Cy_MSCLP_MrssStop()</a> or <a class="el" href="group__group__msclp__functions.html#ga6480a3509749f6272421f8a72b52fa95" title="Returns the MRSS status (enabled/disabled). ">Cy_MSCLP_MrssStatus()</a> functions respectively.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Pointer to a MSCLP HW block base address.</td></tr>
    <tr><td class="paramname">offset</td><td>Register offset relative to base address.</td></tr>
    <tr><td class="paramname">value</td><td>Value to be written to the register.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Function Usage</dt><dd><div class="fragment"><div class="line"></div><div class="line">    <span class="keywordtype">void</span> snippet_Cy_MSCLP_IntHandler(<span class="keywordtype">void</span>)</div><div class="line">    {</div><div class="line">        uint32_t intrStatus;</div><div class="line"></div><div class="line">        <span class="comment">/* Reads interrupt status register */</span></div><div class="line">        intrStatus = <a class="code" href="group__group__msclp__functions.html#gad4afecc1a0e8b5a03c3a8a48e17fa97b">Cy_MSCLP_ReadReg</a>(MSCLP0, <a class="code" href="group__group__msclp__reg__const.html#ga44306b58f19961a02bdce02c5c818daa">CY_MSCLP_REG_OFFSET_INTR</a>);</div><div class="line"></div><div class="line">        <span class="comment">/* Checks the &#39;single scan is complete&#39; event that triggered the interrupt */</span></div><div class="line">        <span class="keywordflow">if</span> ((intrStatus &amp; MSCLP_INTR_SCAN_Msk) == MSCLP_INTR_SCAN_Msk)</div><div class="line">        {</div><div class="line">            <span class="comment">/* End of scan occurred, get the result and do something with it here */</span></div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* Clears the pending interrupts */</span></div><div class="line">        <a class="code" href="group__group__msclp__functions.html#gae95636218ca61f5995e5c9e2f4a5e681">Cy_MSCLP_WriteReg</a>(MSCLP0, <a class="code" href="group__group__msclp__reg__const.html#ga44306b58f19961a02bdce02c5c818daa">CY_MSCLP_REG_OFFSET_INTR</a>, intrStatus);</div><div class="line">        (void)<a class="code" href="group__group__msclp__functions.html#gad4afecc1a0e8b5a03c3a8a48e17fa97b">Cy_MSCLP_ReadReg</a>(MSCLP0, <a class="code" href="group__group__msclp__reg__const.html#ga44306b58f19961a02bdce02c5c818daa">CY_MSCLP_REG_OFFSET_INTR</a>);</div><div class="line">    }</div><div class="line"></div></div><!-- fragment --></dd></dl>

</div>
</div>
<a id="ga0d3bda261a970e35febe56b8f24f5b5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d3bda261a970e35febe56b8f24f5b5e">&#9670;&nbsp;</a></span>Cy_MSCLP_SetBits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_MSCLP_SetBits </td>
          <td>(</td>
          <td class="paramtype">MSCLP_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets bits, specified by the Mask parameter in the MSCLP HW block register, specified by the Offset parameter. </p>
<dl class="section note"><dt>Note</dt><dd>Accessing the SNS group registers under disabled MRSS might lead to the device hard fault. Therefore, access the SNS group registers of the MSCLP HW block only under enabled MRSS. To enable, disable or check the MRSS power status, use the <a class="el" href="group__group__msclp__functions.html#ga584c38e61b0b62eb706e0dccdeafb29b" title="Turns on the MRSS resources. ">Cy_MSCLP_MrssStart()</a>, <a class="el" href="group__group__msclp__functions.html#gaec5cf0ee02f031beefe3c6f9df0d589c" title="Turns off the MRSS resources. ">Cy_MSCLP_MrssStop()</a> or <a class="el" href="group__group__msclp__functions.html#ga6480a3509749f6272421f8a72b52fa95" title="Returns the MRSS status (enabled/disabled). ">Cy_MSCLP_MrssStatus()</a> functions respectively.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Pointer to a MSCLP HW block base address.</td></tr>
    <tr><td class="paramname">offset</td><td>Register offset relative to base address.</td></tr>
    <tr><td class="paramname">mask</td><td>Mask value for register bits to be set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga59e30fcf670020dac1ff55e973b4aa11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59e30fcf670020dac1ff55e973b4aa11">&#9670;&nbsp;</a></span>Cy_MSCLP_ClrBits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_MSCLP_ClrBits </td>
          <td>(</td>
          <td class="paramtype">MSCLP_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears bits, specified by the Mask parameter in the MSCLP HW block register, specified by the Offset parameter. </p>
<dl class="section note"><dt>Note</dt><dd>Accessing the SNS group registers under disabled MRSS might lead to the device hard fault. Therefore, access the SNS group registers of the MSCLP HW block only under enabled MRSS. To enable, disable or check the MRSS power status, use the <a class="el" href="group__group__msclp__functions.html#ga584c38e61b0b62eb706e0dccdeafb29b" title="Turns on the MRSS resources. ">Cy_MSCLP_MrssStart()</a>, <a class="el" href="group__group__msclp__functions.html#gaec5cf0ee02f031beefe3c6f9df0d589c" title="Turns off the MRSS resources. ">Cy_MSCLP_MrssStop()</a> or <a class="el" href="group__group__msclp__functions.html#ga6480a3509749f6272421f8a72b52fa95" title="Returns the MRSS status (enabled/disabled). ">Cy_MSCLP_MrssStatus()</a> functions respectively.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Pointer to a MSCLP HW block base address.</td></tr>
    <tr><td class="paramname">offset</td><td>Register offset relative to base address.</td></tr>
    <tr><td class="paramname">mask</td><td>Mask value for register bits to be cleared. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa7ac16bc23b02372a365ab077df9ccdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7ac16bc23b02372a365ab077df9ccdc">&#9670;&nbsp;</a></span>Cy_MSCLP_WriteBits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_MSCLP_WriteBits </td>
          <td>(</td>
          <td class="paramtype">MSCLP_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes field, specified by the Mask parameter with the value, specified by the Value parameter. </p>
<dl class="section note"><dt>Note</dt><dd>Accessing the SNS group registers under disabled MRSS might lead to the device hard fault. Therefore, access the SNS group registers of the MSCLP HW block only under enabled MRSS. To enable, disable or check the MRSS power status, use the <a class="el" href="group__group__msclp__functions.html#ga584c38e61b0b62eb706e0dccdeafb29b" title="Turns on the MRSS resources. ">Cy_MSCLP_MrssStart()</a>, <a class="el" href="group__group__msclp__functions.html#gaec5cf0ee02f031beefe3c6f9df0d589c" title="Turns off the MRSS resources. ">Cy_MSCLP_MrssStop()</a> or <a class="el" href="group__group__msclp__functions.html#ga6480a3509749f6272421f8a72b52fa95" title="Returns the MRSS status (enabled/disabled). ">Cy_MSCLP_MrssStatus()</a> functions respectively.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Pointer to a MSCLP HW block base address.</td></tr>
    <tr><td class="paramname">offset</td><td>Register offset relative to base address.</td></tr>
    <tr><td class="paramname">mask</td><td>Specifies bits to be modified.</td></tr>
    <tr><td class="paramname">value</td><td>Specifies a value to be written to the register. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2dc66f47124f88bacc39d3216d1753f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2dc66f47124f88bacc39d3216d1753f4">&#9670;&nbsp;</a></span>Cy_MSCLP_SwStartFrame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_MSCLP_SwStartFrame </td>
          <td>(</td>
          <td class="paramtype">MSCLP_Type *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function initiates the non-blocking scan of an entire configured frame by launch the MSCLP HW block state machine. </p>
<p>The function requires the following things to be done ahead the function call:</p><ul>
<li>the MRSS is enabled</li>
<li>MSCLP is configured to AS-MS mode and clearly defines a frame location inside MSCLP Sensor Data RAM</li>
<li>Sensor Data RAM is updated with the sensors frame configuration.</li>
</ul>
<p>The MSCLP HW block takes the first sensor configuration from Sensor Data RAM and executes the scan. After scan is complete, the next sensor configuration is taken (without MCU involvement) and the scan is executes. It happens till the scan of the last sensor of a frame is complete. Then MSCLP state machine goes to the idle state.</p>
<dl class="section note"><dt>Note</dt><dd>Accessing the SNS group registers under disabled MRSS might lead to the device hard fault. Therefore, access the SNS group registers of the MSCLP HW block only under enabled MRSS. To enable, disable or check the MRSS power status, use the <a class="el" href="group__group__msclp__functions.html#ga584c38e61b0b62eb706e0dccdeafb29b" title="Turns on the MRSS resources. ">Cy_MSCLP_MrssStart()</a>, <a class="el" href="group__group__msclp__functions.html#gaec5cf0ee02f031beefe3c6f9df0d589c" title="Turns off the MRSS resources. ">Cy_MSCLP_MrssStop()</a> or <a class="el" href="group__group__msclp__functions.html#ga6480a3509749f6272421f8a72b52fa95" title="Returns the MRSS status (enabled/disabled). ">Cy_MSCLP_MrssStatus()</a> functions respectively.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the MSCLP HW block base address. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4474b04c151ac7d009df1c79ca4a4427"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4474b04c151ac7d009df1c79ca4a4427">&#9670;&nbsp;</a></span>Cy_MSCLP_SwStartAosFrame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_MSCLP_SwStartAosFrame </td>
          <td>(</td>
          <td class="paramtype">MSCLP_Type *&#160;</td>
          <td class="paramname"><em>base</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The function initiates the non-blocking scan of an entire configured frame by launch the MSCLP HW block state machine. </p>
<p>The function requires the following things to be done ahead the function call:</p><ul>
<li>MSCLP is configured to LP-AOS mode and clearly defines a frame location inside MSCLP Sensor Data RAM</li>
<li>Sensor Data RAM is updated with the sensors frame configuration.</li>
</ul>
<p>The MSCLP HW block launches internal timer. After timeout the block takes the first sensor configuration from Sensor Data RAM and executes the scan. After scan is complete, the next sensor configuration is taken (without MCU involvement) and the scan is executes. It happens till the scan of the last sensor in a frame is complete. Then the MSCLP state machine goes to the idle state if number of frame scans is configured to one. Otherwise frame is scanned the configured number of times with configured timeout.</p>
<dl class="section note"><dt>Note</dt><dd>Accessing the SNS group registers under disabled MRSS might lead to the device hard fault. Therefore, access the SNS group registers of the MSCLP HW block only under enabled MRSS. To enable, disable or check the MRSS power status, use the <a class="el" href="group__group__msclp__functions.html#ga584c38e61b0b62eb706e0dccdeafb29b" title="Turns on the MRSS resources. ">Cy_MSCLP_MrssStart()</a>, <a class="el" href="group__group__msclp__functions.html#gaec5cf0ee02f031beefe3c6f9df0d589c" title="Turns off the MRSS resources. ">Cy_MSCLP_MrssStop()</a> or <a class="el" href="group__group__msclp__functions.html#ga6480a3509749f6272421f8a72b52fa95" title="Returns the MRSS status (enabled/disabled). ">Cy_MSCLP_MrssStatus()</a> functions respectively.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>The pointer to the MSCLP HW block base address. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7f34c6fdcb08b1eaca1c0ea71f03d6fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f34c6fdcb08b1eaca1c0ea71f03d6fd">&#9670;&nbsp;</a></span>Cy_MSCLP_ReadSensorDataWord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE uint32_t Cy_MSCLP_ReadSensorDataWord </td>
          <td>(</td>
          <td class="paramtype">MSCLP_Type const *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads one 32-bit data word from the SNS.SENSOR_DATA memory. </p>
<dl class="section note"><dt>Note</dt><dd>Accessing the SNS group registers under disabled MRSS might lead to the device hard fault. Therefore, access the SNS group registers of the MSCLP HW block only under enabled MRSS. To enable, disable or check the MRSS power status, use the <a class="el" href="group__group__msclp__functions.html#ga584c38e61b0b62eb706e0dccdeafb29b" title="Turns on the MRSS resources. ">Cy_MSCLP_MrssStart()</a>, <a class="el" href="group__group__msclp__functions.html#gaec5cf0ee02f031beefe3c6f9df0d589c" title="Turns off the MRSS resources. ">Cy_MSCLP_MrssStop()</a> or <a class="el" href="group__group__msclp__functions.html#ga6480a3509749f6272421f8a72b52fa95" title="Returns the MRSS status (enabled/disabled). ">Cy_MSCLP_MrssStatus()</a> functions respectively.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Pointer to a MSCLP HW block base address.</td></tr>
    <tr><td class="paramname">addr</td><td>The address (index of the 32-bit word) in the SNS.SENSOR_DATA.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 32-bit data word value. </dd></dl>

</div>
</div>
<a id="ga018be5fbfee42c9dbe9c44141d4981a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga018be5fbfee42c9dbe9c44141d4981a6">&#9670;&nbsp;</a></span>Cy_MSCLP_ReadSensorDataArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cy_MSCLP_ReadSensorDataArray </td>
          <td>(</td>
          <td class="paramtype">MSCLP_Type const *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>startAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>ptrData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dataSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an array of 32-bit data words from the SNS.SENSOR_DATA memory. </p>
<dl class="section note"><dt>Note</dt><dd>Accessing the SNS group registers under disabled MRSS might lead to the device hard fault. Therefore, access the SNS group registers of the MSCLP HW block only under enabled MRSS. To enable, disable or check the MRSS power status, use the <a class="el" href="group__group__msclp__functions.html#ga584c38e61b0b62eb706e0dccdeafb29b" title="Turns on the MRSS resources. ">Cy_MSCLP_MrssStart()</a>, <a class="el" href="group__group__msclp__functions.html#gaec5cf0ee02f031beefe3c6f9df0d589c" title="Turns off the MRSS resources. ">Cy_MSCLP_MrssStop()</a> or <a class="el" href="group__group__msclp__functions.html#ga6480a3509749f6272421f8a72b52fa95" title="Returns the MRSS status (enabled/disabled). ">Cy_MSCLP_MrssStatus()</a> functions respectively.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Pointer to a MSCLP HW block base address.</td></tr>
    <tr><td class="paramname">startAddr</td><td>The starting address (index of the 32-bit word) in the SNS.SENSOR_DATA.</td></tr>
    <tr><td class="paramname">ptrData</td><td>Pointer to the 32-bit data array to be copied from the SNS.SENSOR_DATA.</td></tr>
    <tr><td class="paramname">dataSize</td><td>The size of the data array (in 32-bit words).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In case of the startAddr + dataSize exceeds the SNS.SENSOR_DATA size then no one data word will be copied. </dd></dl>

</div>
</div>
<a id="ga7db677f341541e3bf2209e4ea3eb3cb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7db677f341541e3bf2209e4ea3eb3cb3">&#9670;&nbsp;</a></span>Cy_MSCLP_WriteSensorDataWord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">__STATIC_INLINE void Cy_MSCLP_WriteSensorDataWord </td>
          <td>(</td>
          <td class="paramtype">MSCLP_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes one 32-bit data word into the SNS.SENSOR_DATA memory. </p>
<dl class="section note"><dt>Note</dt><dd>Accessing the SNS group registers under disabled MRSS might lead to the device hard fault. Therefore, access the SNS group registers of the MSCLP HW block only under enabled MRSS. To enable, disable or check the MRSS power status, use the <a class="el" href="group__group__msclp__functions.html#ga584c38e61b0b62eb706e0dccdeafb29b" title="Turns on the MRSS resources. ">Cy_MSCLP_MrssStart()</a>, <a class="el" href="group__group__msclp__functions.html#gaec5cf0ee02f031beefe3c6f9df0d589c" title="Turns off the MRSS resources. ">Cy_MSCLP_MrssStop()</a> or <a class="el" href="group__group__msclp__functions.html#ga6480a3509749f6272421f8a72b52fa95" title="Returns the MRSS status (enabled/disabled). ">Cy_MSCLP_MrssStatus()</a> functions respectively.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Pointer to a MSCLP HW block base address.</td></tr>
    <tr><td class="paramname">addr</td><td>The address (index of the 32-bit word) in the SNS.SENSOR_DATA.</td></tr>
    <tr><td class="paramname">data</td><td>The 32-bit data word value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8b1725797fa255e2d344a68b9e5d603d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b1725797fa255e2d344a68b9e5d603d">&#9670;&nbsp;</a></span>Cy_MSCLP_WriteSensorDataArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__group__msclp__enums.html#ga6c70f9f61712d865a792069871ebc2c6">cy_en_msclp_status_t</a> Cy_MSCLP_WriteSensorDataArray </td>
          <td>(</td>
          <td class="paramtype">MSCLP_Type *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>startAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t const *&#160;</td>
          <td class="paramname"><em>ptrData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>dataSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes an array of 32-bit data words into the SNS.SENSOR_DATA memory. </p>
<dl class="section note"><dt>Note</dt><dd>Accessing the SNS group registers under disabled MRSS might lead to the device hard fault. Therefore, access the SNS group registers of the MSCLP HW block only under enabled MRSS. To enable, disable or check the MRSS power status, use the <a class="el" href="group__group__msclp__functions.html#ga584c38e61b0b62eb706e0dccdeafb29b" title="Turns on the MRSS resources. ">Cy_MSCLP_MrssStart()</a>, <a class="el" href="group__group__msclp__functions.html#gaec5cf0ee02f031beefe3c6f9df0d589c" title="Turns off the MRSS resources. ">Cy_MSCLP_MrssStop()</a> or <a class="el" href="group__group__msclp__functions.html#ga6480a3509749f6272421f8a72b52fa95" title="Returns the MRSS status (enabled/disabled). ">Cy_MSCLP_MrssStatus()</a> functions respectively.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">base</td><td>Pointer to a MSCLP HW block base address.</td></tr>
    <tr><td class="paramname">startAddr</td><td>The starting address (index of the 32-bit word) in the SNS.SENSOR_DATA.</td></tr>
    <tr><td class="paramname">ptrData</td><td>Pointer to the 32-bit data array to be copied into the SNS.SENSOR_DATA.</td></tr>
    <tr><td class="paramname">dataSize</td><td>The size of the data array (in 32-bit words).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the status of the operation <a class="el" href="group__group__msclp__enums.html#ga6c70f9f61712d865a792069871ebc2c6">cy_en_msclp_status_t</a><ul>
<li><a class="el" href="group__group__msclp__enums.html#gga6c70f9f61712d865a792069871ebc2c6ac5845dddb5cce0780bf47a69b0fb5b4d">CY_MSCLP_SUCCESS</a> - The data is written successfully</li>
<li><a class="el" href="group__group__msclp__enums.html#gga6c70f9f61712d865a792069871ebc2c6aa3994f87de6c0f8b3988482811ef452b">CY_MSCLP_BAD_PARAM</a> - The startAddr + dataSize exceeds the SNS.SENSOR_DATA, no one data word is written. </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">
            Generated for <b>CAT2 Peripheral Driver Library</b> by <b>Infineon Technologies</b>.
            All rights reserved.
        </li>
    </ul>
</div>
-->
</body>
</html>
