<?xml version="1.0" encoding="utf-8"?>
<device schemaVersion="1.3" xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" xs:noNamespaceSchemaLocation="CMSIS-SVD.xsd">
  <vendor>Infineon Technologies</vendor>
  <vendorID>Infineon</vendorID>
  <name>pag2s</name>
  <series>PAG2S</series>
  <version>1.0</version>
  <description>PAG2S</description>
  <licenseText>(c) (2016-2024), Cypress Semiconductor Corporation (an Infineon company)\n
    or an affiliate of Cypress Semiconductor Corporation.\n
\n
    SPDX-License-Identifier: Apache-2.0\n
\n
    Licensed under the Apache License, Version 2.0 (the "License");\n
    you may not use this file except in compliance with the License.\n
    You may obtain a copy of the License at\n
\n
      http://www.apache.org/licenses/LICENSE-2.0\n
\n
    Unless required by applicable law or agreed to in writing, software\n
    distributed under the License is distributed on an "AS IS" BASIS,\n
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n
    See the License for the specific language governing permissions and\n
    limitations under the License.</licenseText>
  <cpu>
    <name>CM0PLUS</name>
    <revision>r0p1</revision>
    <endian>little</endian>
    <mpuPresent>true</mpuPresent>
    <fpuPresent>false</fpuPresent>
    <vtorPresent>true</vtorPresent>
    <nvicPrioBits>2</nvicPrioBits>
    <vendorSystickConfig>false</vendorSystickConfig>
  </cpu>
  <addressUnitBits>8</addressUnitBits>
  <width>32</width>
  <resetValue>0x00000000</resetValue>
  <resetMask>0xFFFFFFFF</resetMask>
  <peripherals>
    <peripheral>
      <name>PERI</name>
      <description>Peripheral Interconnect</description>
      <baseAddress>0x40010000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>DIV_CMD</name>
          <description>Divider command register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFF</resetValue>
          <resetMask>0xC000FFFF</resetMask>
          <fields>
            <field>
              <name>SEL_DIV</name>
              <description>(SEL_TYPE, SEL_DIV) specifies the divider on which the command (DISABLE/ENABLE) is performed.
 
If SEL_DIV is '63' and 'SEL_TYPE' is '3' (default/reset value), no divider is specified and no clock signal(s) are generated.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEL_TYPE</name>
              <description>Specifies the divider type of the divider on which the command is performed:
0: 8.0 (integer) clock dividers.
1: 16.0 (integer) clock dividers.
2: 16.5 (fractional) clock dividers.
3: 24.5 (fractional) clock dividers.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PA_SEL_DIV</name>
              <description>(PA_SEL_TYPE, PA_SEL_DIV) specifies the divider to which phase alignment is performed for the clock enable command. Any enabled divider can be used as reference. This allows all dividers to be aligned with each other, even when they are enabled at different times.
 
If PA_SEL_DIV is '63' and 'PA_SEL_TYPE' is '3', 'clk_hf' is used as reference.</description>
              <bitRange>[13:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PA_SEL_TYPE</name>
              <description>Specifies the divider type of the divider to which phase alignment is performed for the clock enable command:
0: 8.0 (integer) clock dividers.
1: 16.0 (integer) clock dividers.
2: 16.5 (fractional) clock dividers.
3: 24.5 (fractional) clock dividers.</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE</name>
              <description>Clock divider disable command (mutually exclusive with ENABLE). SW sets this field to '1' and HW sets this field to '0'.
 
The SEL_DIV and SEL_TYPE fields specify which divider is to be disabled.
 
The HW sets the DISABLE field to '0' immediately and the HW sets the DIV_XXX_CTL.EN field of the divider to '0' immediately.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Clock divider enable command (mutually exclusive with DISABLE). Typically, SW sets this field to '1' to enable a divider and HW sets this field to '0' to indicate that divider enabling has completed. When a divider is enabled, its integer and fractional (if present) counters are initialized to '0'. If a divider is to be re-enabled using different integer and fractional divider values, the SW should follow these steps:
0: Disable the divider using the DIV_CMD.DISABLE field.
1: Configure the divider's DIV_XXX_CTL register.
2: Enable the divider using the DIV_CMD_ENABLE field.
 
The SEL_DIV and SEL_TYPE fields specify which divider is to be enabled. The enabled divider may be phase aligned to either 'clk_hf' (typical usage) or to ANY enabled divider.
 
The PA_SEL_DIV and P_SEL_TYPE fields specify the reference divider.
 
The HW sets the ENABLE field to '0' when the enabling is performed and the HW sets the DIV_XXX_CTL.EN field of the divider to '1' when the enabling is performed. Note that enabling with phase alignment to a low frequency divider takes time. E.g. To align to a divider that generates a clock of 'clk_hf'/n (with n being the integer divider value INT_DIV+1), up to n cycles may be required to perform alignment. Phase alignment to 'clk_hf' takes affect immediately. SW can set this field to '0' during phase alignment to abort the enabling process.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>64</dim>
          <dimIncrement>4</dimIncrement>
          <name>PCLK_CTL[%s]</name>
          <description>Programmable clock control register</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFF</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>SEL_DIV</name>
              <description>Specifies one of the dividers of the divider type specified by SEL_TYPE.
 
If SEL_DIV is '63' and 'SEL_TYPE' is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
 
When transitioning a clock between two out of phase dividers, spurious clock control signals may be generated for one 'clk_hf' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (SEL_DIV is '63' and 'SEL_TYPE' is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEL_TYPE</name>
              <description>Specifies divider type:
0: 8.0 (integer) clock dividers.
1: 16.0 (integer) clock dividers.
2: 16.5 (fractional) clock dividers.
3: 24.5 (fractional) clock dividers.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>64</dim>
          <dimIncrement>4</dimIncrement>
          <name>DIV_8_CTL[%s]</name>
          <description>Divider control register (for 8.0 divider)</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF01</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
 
Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INT8_DIV</name>
              <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
 
For the generation of a divided clock, the integer division range is restricted to [2, 256].
 
For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>64</dim>
          <dimIncrement>4</dimIncrement>
          <name>DIV_16_CTL[%s]</name>
          <description>Divider control register (for 16.0 divider)</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF01</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
 
Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INT16_DIV</name>
              <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
 
For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
 
For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[23:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>64</dim>
          <dimIncrement>4</dimIncrement>
          <name>DIV_16_5_CTL[%s]</name>
          <description>Divider control register (for 16.5 divider)</description>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFF9</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
 
Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FRAC5_DIV</name>
              <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_hf' cycle longer than other clock periods.
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[7:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT16_DIV</name>
              <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
 
For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
 
For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[23:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>63</dim>
          <dimIncrement>4</dimIncrement>
          <name>DIV_24_5_CTL[%s]</name>
          <description>Divider control register (for 24.5 divider)</description>
          <addressOffset>0x500</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFF9</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
 
Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FRAC5_DIV</name>
              <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_hf' cycle longer than other clock periods.
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[7:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT24_DIV</name>
              <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
 
For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
 
For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[31:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_CTL</name>
          <description>Trigger control register</description>
          <addressOffset>0x600</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC0FF0F7F</resetMask>
          <fields>
            <field>
              <name>TR_SEL</name>
              <description>Specifies the activated trigger when TR_ACT is '1'. TR_OUT specifies whether the activated trigger is an input trigger or output trigger to the trigger multiplexer. During activation (TR_ACT is '1'), SW should not modify this register field. If the specified trigger is not present, the trigger activation has no effect.</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_GROUP</name>
              <description>Specifies the trigger group.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_COUNT</name>
              <description>Amount of cycles a specific trigger is activated. During activation (TR_ACT is '1'), HW decrements this field to '0' using a cycle counter. During activation, SW should not modify this register field. A value of 255 is a special case: HW does NOT decrement this field to '0' and trigger activation is under direct control of TR_ACT: when TR_ACT is '1' the trigger is activated and when TR_ACT is '0' the trigger is deactivated.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_OUT</name>
              <description>Specifies whether trigger activation is for a specific input or output trigger of the trigger multiplexer. Activation of a specific input trigger, will result in activation of all output triggers that have the specific input trigger selected through their TR_OUT_CTL.SEL  field. Activation of a specific output trigger, will result in activation of the specified TR_SEL output trigger only.
'0': TR_SEL selection and trigger activation is for an input trigger to the trigger multiplexer.
'1': TR_SEL selection and trigger activation is for an output trigger from the trigger multiplexer.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_ACT</name>
              <description>SW sets this field to '1' to activate (set to '1') a trigger as identified by TR_SEL and TR_OUT for TR_COUNT cycles. HW sets this field to '0' when the cycle counter is decremented to '0'. Note: a TR_COUNT value of 255 is a special case and trigger activation is under direct control of the TR_ACT field (the counter is not decremented).
 Note: when TR_ACT is '1', SW should not modify the other register fields.
  SW MUST NOT set TR_ACT bit to '1' while updating the other register bits simultaneously.
  At first the SW MUST update the other register bits as needed, and then set TR_ACT to '1' with a new register write.'</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>HSIOM</name>
      <description>High Speed IO Matrix (HSIOM)</description>
      <baseAddress>0x40020000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>16384</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>2</dim>
          <dimIncrement>256</dimIncrement>
          <name>PRT[%s]</name>
          <description>HSIOM port registers</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>PORT_SEL</name>
            <description>Port selection register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IO0_SEL</name>
                <description>N/A</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>GPIO</name>
                    <description>SW controlled GPIO.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GPIO_DSI</name>
                    <description>SW controlled 'out', DSI controlled 'oe_n'.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DSI_DSI</name>
                    <description>DSI controlled 'out' and 'oe_n'.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DSI_GPIO</name>
                    <description>DSI controlled 'out', SW controlled 'oe_n'.</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CSD_SENSE</name>
                    <description>CSD sense connection (analog mode)</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CSD_SHIELD</name>
                    <description>CSD shield connection (analog mode)</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>AMUXA</name>
                    <description>AMUXBUS A connection.</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>AMUXB</name>
                    <description>AMUXBUS B connection. This mode is also used for CSD GPIO charging.  When CSD GPIO charging is enabled in CSD_CONTROL, 'oe_n' is connected to '!csd_charge' signal (and IO pad is also still connected to AMUXBUS B).</description>
                    <value>7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_0</name>
                    <description>Chip specific Active source 0 connection.</description>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_1</name>
                    <description>Chip specific Active source 1 connection.</description>
                    <value>9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_2</name>
                    <description>Chip specific Active source 2 connection.</description>
                    <value>10</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_3</name>
                    <description>Chip specific Active source 3 connection.</description>
                    <value>11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>LCD_COM</name>
                    <description>LCD common connection. This mode provides DeepSleep functionality (provided that the LCD block exists, is enabled, and is properly configured).</description>
                    <value>12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>LCD_SEG</name>
                    <description>LCD segment connection. This mode provides DeepSleep functionality  (provided that the LCD block is enabled and properly configured).</description>
                    <value>13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_2</name>
                    <description>Chip specific DeepSleep source 2 connection.</description>
                    <value>14</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_3</name>
                    <description>Chip specific DeepSleep source 3 connection.</description>
                    <value>15</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IO1_SEL</name>
                <description>N/A</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO2_SEL</name>
                <description>N/A</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO3_SEL</name>
                <description>N/A</description>
                <bitRange>[15:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO4_SEL</name>
                <description>N/A</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO5_SEL</name>
                <description>N/A</description>
                <bitRange>[23:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO6_SEL</name>
                <description>N/A</description>
                <bitRange>[27:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO7_SEL</name>
                <description>N/A</description>
                <bitRange>[31:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>PUMP_CTL</name>
          <description>Pump control</description>
          <addressOffset>0x2000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000001</resetMask>
          <fields>
            <field>
              <name>CLOCK_SEL</name>
              <description>Clock select:
'0': External clock.
'1': Internal clock (deprecated).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>Pump enabled:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>4</dimIncrement>
          <name>AMUX_SPLIT_CTL[%s]</name>
          <description>AMUX splitter cell control</description>
          <addressOffset>0x2100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x77</resetMask>
          <fields>
            <field>
              <name>SWITCH_AA_SL</name>
              <description>T-switch control for Left AMUXBUSA switch:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_AA_SR</name>
              <description>T-switch control for Right AMUXBUSA switch:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_AA_S0</name>
              <description>T-switch control for AMUXBUSA vssa/ground switch:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_BB_SL</name>
              <description>T-switch control for Left AMUXBUSB switch.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_BB_SR</name>
              <description>T-switch control for Right AMUXBUSB switch.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_BB_S0</name>
              <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SRSSHV</name>
      <description>System Resources High Voltage Subsystem</description>
      <baseAddress>0x40030000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>PWR_CONTROL</name>
          <description>Power Mode Control (Lock Protected)</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8F003F</resetMask>
          <fields>
            <field>
              <name>POWER_MODE</name>
              <description>Current power mode of the device.  Note that this field cannot be read in all power modes on actual silicon.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RESET</name>
                  <description>RESET state</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACTIVE</name>
                  <description>ACTIVE state</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLEEP</name>
                  <description>SLEEP state</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DEEP_SLEEP</name>
                  <description>DEEP_SLEEP state</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DEBUG_SESSION</name>
              <description>Indicates whether a debug session is active (CDBGPWRUPREQ signal is 1)</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_SESSION</name>
                  <description>No debug session active</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SESSION_ACTIVE</name>
                  <description>Debug session is active</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LPM_READY</name>
              <description>Indicates whether the low power mode regulator is ready to enter DeepSleep mode.  
0: If DeepSleep mode is requested, device will enter SLEEP mode.  When low power regulators are ready, device will automatically enter the originally requested mode.
1: Normal operation.  DeepSleep works as described.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVER_TEMP_EN</name>
              <description>Enables the die over temperature sensor.  Must be enabled when using the TEMP_HIGH interrupt.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVER_TEMP_THRESH</name>
              <description>Over-temperature threshold.   
0: TEMP_HIGH condition occurs between 120C and 125C.
1: TEMP_HIGH condition occurs between 60C and 75C (used for testing).</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPARE</name>
              <description>Spare AHB readback bits that are hooked to PWR_PWRSYS_TRIM1.SPARE_TRIM[1:0] through spare logic equivalent to bitwise inversion.  Engineering only, should always be set to default.</description>
              <bitRange>[19:18]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EXT_VCCD</name>
              <description>Always write 0 except as noted below. 

PSoC4-S0 and Streetfighter CapSense products may set this bit if Vccd is provided externally (on Vccd pin).  Setting this bit turns off the active regulator and will lead to system reset (BOD) unless both Vddd and Vccd pins are supplied externally.  This register field reset with hard reset (power related, XRES, WDT).</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_KEY_DELAY</name>
          <description>Power System Key&amp;Delay Register (Lock Protected)</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xF8</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>WAKEUP_HOLDOFF</name>
              <description>Delay to wait for references to settle on wakeup from DeepSleep.  BOD is ignored and system does not resume until this delay expires. Note that the same delay on POR is hard-coded.  The default assumes the output of the predivider is 48MHz + 3 percent.  Firmware may scale this setting according to the fastest actual clock frequency that can occur when waking from DeepSleep.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TST_MODE</name>
          <description>Test Mode Control Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xD0000004</resetMask>
          <fields>
            <field>
              <name>SWD_CONNECTED</name>
              <description>N/A</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BLOCK_ALT_XRES</name>
              <description>Relevant only for parts that have the alternate XRES mechanism of overloading a GPIO pin temporarily as alternate XRES during test.  When set, this bit blocks the alternate XRES function, such that the pin can be used for normal I/O or for ddft/adft observation.  This register field resets with hard reset (power related, XRES, WDT)</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TEST_KEY_DFT_EN</name>
              <description>N/A</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TEST_MODE</name>
              <description>N/A</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_CAL_CNT1</name>
          <description>Clock Calibration Counter 1</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80000000</resetValue>
          <resetMask>0x8000FFFF</resetMask>
          <fields>
            <field>
              <name>CAL_COUNTER1</name>
              <description>Down-counter clocked on DFT output #0 (see CLK_DFT_SELECT). This register always reads as zero.  Counting starts internally when this register is written with a nonzero value.  CAL_COUNTER_DONE goes immediately low to indicate that the counter has started and will be asserted when the counters are done.  Do not write this field unless CAL_COUNTER_DONE==1.  Both clocks must be running or the measurement will not complete.  A stalled counter can be recovered by selecting valid clocks, waiting until the measurement completes, and discarding the first result.  CAL_COUNTER1 should always be &gt; 1.  Due to internal clock synchronization CAL_COUNTER1 should be at least 5 times the 1/F_cnt2.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CAL_COUNTER_DONE</name>
              <description>Status bit indicating that the internal counter #1 is finished counting and CLK_CAL_CNT2.COUNTER stopped counting up</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_CAL_CNT2</name>
          <description>Clock Calibration Counter 2</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>CAL_COUNTER2</name>
              <description>Up-counter clocked on DFT output #1 (see CLK_DFT_SELECT). When CLK_CAL_CNT1.CAL_COUNTER_DONE==1, the counter is stopped and can be read by SW.  Do not read this value unless CAL_COUNTER_DONE==1.  The expected final value is related to the ratio of clock frequencies used for the two counters and the value loaded into counter 1: CLK_CAL_CNT2.CAL_COUNTER2=(F_cnt2/F_cnt1)*(CLK_CAL_CNT1.CAL_COUNTER1)</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_SELECT</name>
          <description>Clock Select Register (Lock Protected)</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x8</resetValue>
          <resetMask>0x1FF</resetMask>
          <fields>
            <field>
              <name>HFCLK_SEL</name>
              <description>Selects a source for clk_hf and dsi_in[0].  Note that not all products support all clock sources.  Selecting a clock source that is not supported or enabled will result in undefined behavior.  It takes about 3 cycles of the new selected clock to switch away from the old clock to the new clock.  Do not disable the original clock during this time.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>IMO - Internal R/C Oscillator</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXTCLK</name>
                  <description>EXTCLK - External Clock Pin</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO</name>
                  <description>ECO - External-Crystal Oscillator or PLL subsystem output</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HPOSC</name>
                  <description>HPOSC - High Precision Oscillator. Only if HPOSC_PRESENT=1</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HFCLK_DIV</name>
              <description>Selects clk_hf predivider value.  It will take 3-4 clock cycles to switch to the new predivder value</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_DIV</name>
                  <description>Transparent mode, feed through selected clock source w/o dividing.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_2</name>
                  <description>Divide selected clock source by 2</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_4</name>
                  <description>Divide selected clock source by 4</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_8</name>
                  <description>Divide selected clock source by 8</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PUMP_SEL</name>
              <description>Selects clock source for charge pump clock.  This clock is not guaranteed to be glitch free when changing any of its sources or settings.</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>GND</name>
                  <description>No clock, connect to gnd</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>Use main IMO output</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HFCLK</name>
                  <description>Use clk_hf (using selected source after predivider but before prescaler)</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SYSCLK_DIV</name>
              <description>Select clk_sys prescaler value.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_DIV</name>
                  <description>clk_sys= clk_hf/1</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_2</name>
                  <description>clk_sys= clk_hf/2</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_4</name>
                  <description>clk_sys= clk_hf/4</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_8</name>
                  <description>clk_sys= clk_hf/8</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LFCLK_SEL</name>
              <description>Low Frequency Clock Select.  Selecting a clock source that is not enabled will result in undefined behavior.  If a clock source is disabled while selected, then the clock merely stops to all sources that receive it.  In such a scenario, the disabled clock must be re-enabled, prior to switching FROM this clock source.  Writes to this field are ignored unless the WDT is unlocked using WDT_LOCK register.  It takes about 3 cycles of the new selected clock to switch away from the old clock to the new clock.  Do not disable the original clock during this time.   This register field resets with hard reset (power related, XRES, WDT).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ILO</name>
                  <description>ILO - Internal Low Frequency Oscillator</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PILO</name>
                  <description>PILO - Precision Internal Low Frequency Oscillator. Only if PILO_PRESENT=1</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_ILO_CONFIG</name>
          <description>ILO Configuration (Lock Protected)</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80000000</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>Master enable for ILO oscillator.    Clearing this bit will disable the ILO.  Do not disable this clock if the CLK_LF uses it clock the source.  Writes to this field are ignored when LFCLK_SEL is using this clock as the source and WDT is locked using WDT_LOCK register.  This register resets when there is power related reset POR/XRES/BOD/OVD/WDT</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_IMO_CONFIG</name>
          <description>IMO Configuration (Lock Protected)</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80000000</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>Master enable for IMO oscillator.  Clearing this bit will disable the IMO.  Don't do this if the system is running off it.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_DFT_SELECT</name>
          <description>Clock DFT Mode Selection Register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7F7F</resetMask>
          <fields>
            <field>
              <name>DFT_SEL0</name>
              <description>Select clock for Calibration Counter #1</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NC</name>
                  <description>Disabled - output is 0</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO</name>
                  <description>clk_ilo: ILO output</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>clk_imo: IMO primary output</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO</name>
                  <description>clk_eco: ECO output</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXTCLK</name>
                  <description>clk_ext: external clock input</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HFCLK</name>
                  <description>clk_hf: root of the high-speed clock tree</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LFCLK</name>
                  <description>clk_lf:  root of the low-speed clock tree</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SYSCLK</name>
                  <description>clk_sys:  root of the CPU/AHB clock tree (gated version of clk_hf)</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PUMPCLK</name>
                  <description>clk_pump: clock provided to charge pumps in FLASH and PA</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLPCTRLCLK</name>
                  <description>clk_slpctrl:  clock provided to Sleep Controller</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HPOSC</name>
                  <description>clk_hposc:  HPOSC output.  Applicable only if HPOSC_PRESENT=1</description>
                  <value>10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PILO</name>
                  <description>clk_pilo:  PILO output.  Applicable only if PILO_PRESENT=1</description>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO_EN</name>
                  <description>clk_ilo: enable. Use for startup time measurements.  Use only with DFT_DIV0.NO_DIV</description>
                  <value>12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IMO_EN</name>
                  <description>clk_imo: enable. Use for startup time measurements. Use only with DFT_DIV0.NO_DIV</description>
                  <value>13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HPOSC_EN</name>
                  <description>clk_hposc: enable. If HPOSC_PRESENT=1, Use for startup time measurements. Use only with DFT_DIV0.NO_DIV</description>
                  <value>14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PILO_EN</name>
                  <description>clk_pilo: enable. If PILO_PRESENT=1, Use for startup time measurements. Use only with DFT_DIV0.NO_DIV</description>
                  <value>15</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DFT_DIV0</name>
              <description>Calibration Counter #1 pre-divider</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_DIV</name>
                  <description>Direct Output</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_2</name>
                  <description>Divide by 2</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_4</name>
                  <description>Divide by 4</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_8</name>
                  <description>Divide by 8</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DFT_EDGE0</name>
              <description>Edge sensitivity for pre-divider (only relevant when DIV0&gt;0).</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>POSEDGE</name>
                  <description>Use posedge for divider</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NEGEDGE</name>
                  <description>Use negedge for divider</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DFT_SEL1</name>
              <description>Select clock for Calibration Counter #2</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NC</name>
                  <description>Disabled - output is 0</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO</name>
                  <description>clk_ilo: ILO output</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>clk_imo: IMO primary output</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO</name>
                  <description>clk_eco: ECO output</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXTCLK</name>
                  <description>clk_ext: external clock input</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HFCLK</name>
                  <description>clk_hf: root of the high-speed clock tree</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LFCLK</name>
                  <description>clk_lf:  root of the low-speed clock tree</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SYSCLK</name>
                  <description>clk_sys:  root of the CPU/AHB clock tree (gated version of clk_hf)</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PUMPCLK</name>
                  <description>clk_pump: clock provided to charge pumps in FLASH and PA</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLPCTRLCLK</name>
                  <description>clk_slpctrl:  clock provided to Sleep Controller</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HPOSC</name>
                  <description>clk_hposc:  HPOSC output.  Applicable only if HPOSC_PRESENT=1</description>
                  <value>10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PILO</name>
                  <description>clk_pilo:  PILO output.  Applicable only if PILO_PRESENT=1</description>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO_EN</name>
                  <description>clk_ilo: enable. Use for startup time measurements.  Use only with DFT_DIV0.NO_DIV</description>
                  <value>12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IMO_EN</name>
                  <description>clk_imo: enable. Use for startup time measurements. Use only with DFT_DIV0.NO_DIV</description>
                  <value>13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HPOSC_EN</name>
                  <description>clk_hposc: enable. If HPOSC_PRESENT=1, Use for startup time measurements. Use only with DFT_DIV0.NO_DIV</description>
                  <value>14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PILO_EN</name>
                  <description>clk_pilo: enable. If PILO_PRESENT=1, Use for startup time measurements. Use only with DFT_DIV0.NO_DIV</description>
                  <value>15</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DFT_DIV1</name>
              <description>Calibration Counter #2 pre-divider</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_DIV</name>
                  <description>Direct Output</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_2</name>
                  <description>Divide by 2</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_4</name>
                  <description>Divide by 4</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_8</name>
                  <description>Divide by 8</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DFT_EDGE1</name>
              <description>Edge sensitivity for pre-divider (only relevant when DIV0&gt;0).</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>POSEDGE</name>
                  <description>Use posedge for divider</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NEGEDGE</name>
                  <description>Use negedge for divider</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_MASKED</name>
          <description>SRSS Interrupt Masked Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1E</resetMask>
          <fields>
            <field>
              <name>TEMP_HIGH</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>LIFETIME_WAKEUP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CLK_CAL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CRWDT</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_INTR</name>
          <description>SRSS Interrupt Register</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1E</resetMask>
          <fields>
            <field>
              <name>TEMP_HIGH</name>
              <description>Regulator over-temp interrupt.  This interrupt can occur when a short circuit exists on the vccd pin or when extreme loads are applied on IO-cells causing the die to overheat.  Firmware is encourage to shutdown all IO cells and then go to DeepSleep mode when this interrupt occurs if protection against such conditions is desired.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LIFETIME_WAKEUP</name>
              <description>Wakeup Interrupt from LIFETIME Counter. This bit is set when LIFETIME_COUNTER ==LIFETIME_WAKEUP. This is a DeepSleep Interrupt.  The interrupt source will reset only with hard reset (power related, XRES, WDT).</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CAL</name>
              <description>Clock calibration counter is done.  This field is reset during DeepSleep mode.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CRWDT</name>
              <description>Interrupt from CRWDT. This bit is set by the CRWDT when enabled by CRWDT_CONFIG.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_INTR_SET</name>
          <description>SRSS Interrupt Set Register</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1E</resetMask>
          <fields>
            <field>
              <name>TEMP_HIGH</name>
              <description>Writing 1 to this bit internally sets the overtemp interrupt.  This can be observed by reading SRSS_INTR.TEMP_HIGH.  This bit always reads back as zero.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LIFETIME_WAKEUP</name>
              <description>Writing 1 to this bit internally sets the LIFETIME_WAKEUP interrupt.  Reads back same as SRSS_INTR.LIFETIME_WAKEUP.  The interrupt source will reset only with hard reset (power related, XRES, WDT).</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CAL</name>
              <description>Set interrupt for clock calibration counter done.  This field is reset during DeepSleep mode.  Reads back same as SRSS_INTR.CLK_CAL.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CRWDT</name>
              <description>Set interrupt for Challenge/Response Interrupt.  Reads back same as SRSS_INTR.CRWDT.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_INTR_MASK</name>
          <description>SRSS Interrupt Mask Register</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1E</resetMask>
          <fields>
            <field>
              <name>TEMP_HIGH</name>
              <description>Masks REG_OVERTEMP interrupt</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LIFETIME_WAKEUP</name>
              <description>Mask for lifetime counter</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CAL</name>
              <description>Mask for clock calibration done</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CRWDT</name>
              <description>Mask for CRWDT interrupt</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RES_CAUSE</name>
          <description>Reset Cause Observation Register</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000000</resetValue>
          <resetMask>0x415B021B</resetMask>
          <fields>
            <field>
              <name>RESET_WDT</name>
              <description>A WatchDog Timer reset has occurred since last power cycle.
This is a high-voltage cause detection, this bit blocks recording of other high-voltage cause bits, except RESET_PORVDDD and XRES.  Hardware clears this bit during POR.  This bit is not blocked by other HV cause bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_ACT_FAULT</name>
              <description>Reset caused by the Fault Infrastructure.   This is a low-voltage cause bit that hardware clears when the low-voltage supply is initialized (see comments above).</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_PROT_FAULT</name>
              <description>A protection violation occurred that requires a RESET.  This includes, but is not limited to, hitting a debug breakpoint while in Privileged Mode.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_SOFT</name>
              <description>Cortex-M0 requested a system reset through it's SYSRESETREQ.  This can be done via a debugger probe or in firmware.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_CRWDT</name>
              <description>Challenge/Response Watchdog reset.  This is a low-voltage cause bit that hardware clears when the low-voltage supply is initialized (see comments above).</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_XRES</name>
              <description>External XRES pin was asserted.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.  This bit is not blocked by other HV cause bits.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_BODVDDD</name>
              <description>External VDDD supply crossed brown-out limit.  Note that this cause will only be observable as long as the VDDD supply does not go below the POR (power on reset) detection limit.  Below this limit it is not possible to reliably retain information in the device.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD and RESET_XRES.  Hardware clears this bit during POR.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_BODVCCD</name>
              <description>Internal VCCD core supply crossed the brown-out limit.  Note that this detector will detect gross issues with the internal core supply, but may not catch all brown-out conditions.  Functional and timing supervision (CSV, WDT) is provided to create fully failsafe internal crash detection.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD and RESET_XRES.  Hardware clears this bit during POR.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_OVDVDDD</name>
              <description>Overvoltage detection on the external VDDD supply.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD and RESET_XRES.  Hardware clears this bit during POR.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_OVDVCCD</name>
              <description>Overvoltage detection on the internal core VCCD supply.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD and RESET_XRES.  Hardware clears this bit during POR.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_BODHVSS</name>
              <description>External VDDD supply crossed brown-out limit.  Note that this cause will only be observable as long as the VDDD supply does not go below the POR (power on reset) detection limit.  Below this limit it is not possible to reliably retain information in the device.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD and RESET_XRES.  Hardware clears this bit during POR.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_PORVDDD</name>
              <description>Indicator that a POR occurred.  This is a high-voltage cause bit, and hardware clears the other bits when this one is set.  It does not block further recording of other high-voltage causes.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_PROT</name>
          <description>Register Protection</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xF08169E7</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MAGIC</name>
              <description>Setting this register to the value 0xf08169e7 unlocks access to Lock Protected Registers. These registers can not be written to unless this value has been written into this register. Writing a value OTHER than the magic key will disable access to the registers. The register POR value is set to 'unlock' the register access. 
The registers locked are PWR_CONTROL, PWR_KEY_DELAY, CLK_SELECT, CLK_ILO_CONFIG, CLK_IMO_CONFIG, CRWDT_CTL, CRWDT_EARLY, PWR_SSV_CTL, CRWDT_WARN, CRWDT_LATE, LIFETIME_CTL,HPOSC_CTL(if HPOSC_PRESENT=1), PILO_CTL(if PILO_PRESENT=1), and all trim registers</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRWDT_CTL</name>
          <description>Challenge Response WatchDog Control (Lock Protected)</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC0000000</resetMask>
          <fields>
            <field>
              <name>STATUS_ENABLED</name>
              <description>Indicates actual state of CRWDT enable.  May lag ENABLED by up to one clk_lf cycles.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>When set to '1' enables Challenge/Response WatchDog Timer to Count.  Will require 2 clk_lf cycles to take effect.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRWDT_CHALLENGE</name>
          <description>Challenge Response WatchDog Challenge Value</description>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0xFF</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>CHALLENGE</name>
              <description>Challenge/Response WatchDog Challenge value. Implements the LFSR CCRC8-AutoSar using the polynomial x^8+x^5+x^3+x^2+x+1.  The next value in the LFSR sequence is used to compare against the value subsequently written to the CRWDT_RESPONSE register.  Incremented by write to CRWDT_RESPONSE to LFSR value next in the LFSR sequence after the value written to CRWDT_RESPONSE.  Also incremented each time this register before a response is written to CRWDT_RESPONSE.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRWDT_RESPONSE</name>
          <description>Challenge Response WatchDog Response Value</description>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFF</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>RESPONSE</name>
              <description>Challenge/Response WatchDog Response value.  Value is compared against the expected next value in the LFSR sequence following the value obtained from CRWDT_CHALLENGE.  If the values match, the CRWDT_UPCNT resets. If the values miscompare,  the action selected by CRWDT_CONFIG.CHALLENGE_FAIL_ACTION occurs.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRWDT_UPCNT</name>
          <description>Challenge Response  WatchDog Up Counter</description>
          <addressOffset>0x9C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFF</resetMask>
          <fields>
            <field>
              <name>UPCNT</name>
              <description>Challenge/Response WatchDog Up Counter.  The counter upcounts upon every clk_lf occurrence when enabled.  If a match occurs between CRWDT_CHALLENGE and CRWDT_RESPONSE, the counter resets.    If there is a mismatch, the action is taken selected by CRWDT_CONFIG.CHALLENGE_FAIL_ACTION.  The counter will also reset when CRWDT_UPCNT=CRWDT_LATE.
CRWDT_CTL.ENABLED=0 - Counter reset
CRWDT_CTL.ENABLED=1 - Counter Increments</description>
              <bitRange>[23:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRWDT_EARLY</name>
          <description>Challenge Response  WatchDog Early Limit (Lock Protected)</description>
          <addressOffset>0xA0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFF</resetMask>
          <fields>
            <field>
              <name>EARLY</name>
              <description>Challenge/Response Early Value will cause the action selected by CRWDT_CONFIG.EARLY_ACTION if CRWDT_UPCNT &lt; CRWDT_EARLY and there is a CRWDT_CHALLENGE/CRWDT_RESPONSE match.
Writes to this register are ignored when CRWDT_CTL.ENABLED&lt;&gt;0.</description>
              <bitRange>[23:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRWDT_WARN</name>
          <description>Challenge Response  WatchDog Warning Limit  (Lock Protected)</description>
          <addressOffset>0xA4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFF</resetMask>
          <fields>
            <field>
              <name>WARNING</name>
              <description>Challenge/Response Warning Value will cause the action selected by CRWDT_CONFIGWARN_ACTION  if CRWDT_UPCNT&gt;CRWDT_WARN and there is a CRWDT_CHALLENGE/CRWDT_RESPONSE match.  
Writes to this register are ignored when CRWDT_CTL.ENABLED&lt;&gt;0.</description>
              <bitRange>[23:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRWDT_LATE</name>
          <description>Challenge Response  WatchDog Late Limit  (Lock Protected)</description>
          <addressOffset>0xA8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFF</resetMask>
          <fields>
            <field>
              <name>LATE</name>
              <description>Challenge/Response Late Value will cause action selected by CRWDT_CONFIG.LATE_ACTION if CRWDT_UPCNT = CRWDT_LATE.   
Writes to this register are ignored when CRWDT_CTL.ENABLED&lt;&gt;0.</description>
              <bitRange>[23:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRWDT_CONFIG</name>
          <description>Challenge Response WatchDog Configuration</description>
          <addressOffset>0xAC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x810</resetValue>
          <resetMask>0x80000911</resetMask>
          <fields>
            <field>
              <name>EARLY_ACTION</name>
              <description>Action taken if this watchdog when the proper response is written to CRWDT_RESPONSE before CRWDT_UPCNT  reaches CRWDT_EARLY.  EARLY_ACTION is ignored (i.e. treated as NOTHING) when a debugger is connected.
For CRWDT_EARLY  &gt; CRWDT_UPCNT: The action is triggered on same edge as when it meets this condition.
For CRWDT_EARLY &lt;= CRWDT_UPCNT: No action is triggered. 

Writes to this register are ignored when CRWDT_CTL.ENABLED&lt;&gt;0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NOTHING</name>
                  <description>Do nothing</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FAULT_AND_INT</name>
                  <description>Trigger a Fault and interrupt</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LATE_ACTION</name>
              <description>Action taken if this watchdog is not serviced before CRWDT_LATE s reached.  The counter resets CRWDT_UPCNT when CRWDT_LATE is reached, regardless of CRWDT_CONFIG.LATE_ACTION setting.   LATE_ACTION  is ignored (i.e. treated as NOTHING) when a debugger is connected.
For CRWDT_LATE ==  CRWDT_UPCNT: The action is triggered on same edge as when it meets this condition.
For CRWDT_LATE &gt; CRWDT_UPCNT: No action is taken 

Writes to this register are ignored when CRWDT_CTL.ENABLED&lt;&gt;0.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NOTHING</name>
                  <description>Do nothing</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FAULT_RESET</name>
                  <description>Trigger a fault.  Further, trigger a system-wide reset if the CRWDT is not disabled within 6 clk_lf cycles.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WARN_ACTION</name>
              <description>Action taken if this watchdog when the proper response is written to CRWDT_RESPONSE and  CRWDT_UPCNT  reaches CRWDT_WARN and CRWDT_UPCNT&lt;CRWDT_LATE. WARN_ACTION is ignored (i.e. treated as NOTHING) when a debugger is connected.
For CRWDT_WARN == CRWDT_UPCNT &amp;&amp; CRWDT_LATE &gt; CRWDT_UPCNT: The action is triggered on same edge as when it meets this condition.
For CRWDT_WARN &lt;CRWDT_UPCNT: No action is triggered.

Writes to this register are ignored when CRWDT_CTL.ENABLED&lt;&gt;0.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NOTHING</name>
                  <description>Do nothing</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FAULT_AND_INT</name>
                  <description>Trigger a Fault and interrupt</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CHALLENGE_FAIL_ACTION</name>
              <description>Action taken when a failed response occurs, i.e. the expected LFSR value is different than the  expected value.

Writes to this register are ignored when CRWDT_CTL.ENABLED&lt;&gt;0.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NOTHING</name>
                  <description>Do nothing</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RESET</name>
                  <description>Trigger a reset</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DEBUG_RUN</name>
              <description>Pauses/runs this counter while a debugger is connected.  Other behaviors are unchanged during debugging, including service, configuration updates and enable/disable.  Note it may take up to two clk_lf cycles for the counter to pause and another two cycles to unpause, due to internal synchronization.  If the debugger is connected for at least two clk_lf cycles, the EARLY_ACTION is ignored until after the first service after the debugger is disconnected.  This prevents an unintentional trigger of the EARLY_ACTION before the firmware realigns the servicing period.  After the first service, EARLY_ACTION behaves as configured.  If the debugger is disconnected before two clk_lf cycles, the EARLY_ACTION may or may not be ignored.
0: When debugger connected, counter pauses incrementing.
1: When debugger connected, counter increments normally, but reset generation is blocked. 

Writes to this register are ignored when CRWDT_CTL.ENABLED&lt;&gt;0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LIFETIME_CTL</name>
          <description>Liftetime Counter Control (Lock Protected)</description>
          <addressOffset>0xB0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC0000007</resetMask>
          <fields>
            <field>
              <name>PRESEL</name>
              <description>Select Divide ratio for Preselector. Legal values are 0-4. Values 5, 6, and 7 yield the same result as  PERSEL_DIV32.  Do not change this setting when lifetime counter is enabled (LIFETIME_CTL.ENABLED=1).  Due to internal synchronization, it takes about 1 LFCLK cycles to update the counters after a write to this register.  This register bit only resets for XRES, POR, or a detected BOD.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PRESEL_DIV2</name>
                  <description>Divide CLK_LF by 2</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PRESEL_DIV4</name>
                  <description>Divide CLK_LF by 4</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PRESEL_DIV8</name>
                  <description>Divide CLK_LF by 8</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PRESEL_DIV16</name>
                  <description>Divide CLK_LF by 16</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PRESEL_DIV32</name>
                  <description>Divide CLK_LF by 32</description>
                  <value>4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>STATUS_ENABLED</name>
              <description>Indicates actual state of lifetime counter enable.  May lag ENABLED by up to one clk_lf cycles.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>When set to '1' enables LIFETIME_COUNTER to increment.   Due to internal synchronization, may take up to one clk_lf cycles to take effect.  The synchronization can be checked by waiting until ENABLED==STATUS_ENABLED whenever ENABLED is changed.  When ENABLE changes from 1-&gt;0, the counter can be loaded with new COUNT value.  Refer to LIFETIME_COUNTER.COUNT for details.  User can enter DeepSleep without waiting for synchronization to complete (ENABLED==STATUS_ENABLED).  This register bit only resets for XRES, POR, or a detected BOD.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LIFETIME_WAKEUP</name>
          <description>Lifetime Wakeup Value</description>
          <addressOffset>0xB4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WAKEUP</name>
              <description>Compare the WAKEUP value against LIFETIME_COUNTER. If they are equal interrupt_wakeup to set.   Due to internal synchronization, it may take up to 1 LFCLK cycles to update the counters after a write to this register.  This register bit only resets for XRES, POR, or a detected BOD.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LIFETIME_COUNTER</name>
          <description>Lifetime Counter Current Value</description>
          <addressOffset>0xB8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNT</name>
              <description>Lifetime Counter which clocks on the output of the CLK_LF PreScalar output controlled by LIFETIME_CTL.PRESEL. The counter doesn't increment unless LIFETIME_CTL.STATUS_ENABLED =1. FW is responsible for initializing this value after reset and maintaining the running value.  SW writes will be ignored when LIFETIME_CTL.ENABLED=1.  The counter needs to be disabled one LFCLK cycle (or LIFETIME_CTL.STATUS_ENABLED=0) for the internal synchronization of this field to take place.  This register bit only resets for XRES, POR, or a detected BOD.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_SSV_CTL</name>
          <description>Supply Supervisory Control Register  (Lock Protected)</description>
          <addressOffset>0xE0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x808</resetValue>
          <resetMask>0x88080808</resetMask>
          <fields>
            <field>
              <name>BODVDDD_ENABLE</name>
              <description>Enable for BOD on vddd.  This cannot be disabled during normal operation.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BODVCCD_ENABLE</name>
              <description>Enable for BOD on vccd.  This cannot be disabled during normal operation.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVDVDDD_ENABLE</name>
              <description>Enable for OVD on vddd.  FW should enable this after the OVD trims are set during boot-up and keep it enabled.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVDVCCD_ENABLE</name>
              <description>Enable for OVD on vccd.  FW should enable this after the OVD trims are set during boot-up and keep it enabled.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BODHVSS_ENABLE</name>
              <description>Enable for BOD on vddd from HVSS.  This gives BOD robustness during DeepSleep.  FW should enable during boot-up and keep it enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_SSV_STATUS</name>
          <description>Supply Supervision Status Register</description>
          <addressOffset>0xE4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x1005</resetValue>
          <resetMask>0x1505</resetMask>
          <fields>
            <field>
              <name>BODVDDD_OK</name>
              <description>BOD indicates vddd is ok.  This will always read 1, because a detected brownout will reset the chip.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BODVCCD_OK</name>
              <description>BOD indicates vccd is ok.  This will always read 1, because a detected brownout will reset the chip.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVDVDDD_OK</name>
              <description>OVD indicates vddd is ok.    After OVDVDDD is enabled it will always read 1, because a detected over-voltage condition will reset the chip.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVDVCCD_OK</name>
              <description>OVD indicates vccd is ok.    After OVDVCCD is enabled it will always read 1, because a detected over-over-voltage condition will reset the chip.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BODHVSS_OK</name>
              <description>BODHVSS indicates vddd is ok.   This will always read 1, because a detected brownout will reset the chip.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <cluster>
          <name>WDT</name>
          <description>Watchdog Timer</description>
          <headerStructName>WDT</headerStructName>
          <addressOffset>0x00000100</addressOffset>
          <register>
            <name>CTL</name>
            <description>WDT Control Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x80000001</resetValue>
            <resetMask>0x80000001</resetMask>
            <fields>
              <field>
                <name>ENABLED</name>
                <description>Indicates actual state of watchdog.  May lag ENABLE by up to three clk_lf cycles.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ENABLE</name>
                <description>Enable watchdog.  May take up to three clk_lf cycles to take effect.  When ENABLE changes from 1-&gt;0, the counter is cleared.  Do not enter DeepSleep if ENABLE&lt;&gt;ENABLED.  This can be done by waiting until ENABLE==ENABLED whenever ENABLE is changed.
0: Counter is disabled (not clocked).
1: Counter is enabled (counting up)</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LOWER_LIMIT</name>
            <description>WDT Lower Limit Register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LOWER_LIMIT</name>
                <description>Lower limit for watchdog.  See LOWER_ACTION.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UPPER_LIMIT</name>
            <description>WDT Upper Limit Register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x8000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>UPPER_LIMIT</name>
                <description>Upper limit for watchdog.  See UPPER_ACTION.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WARN_LIMIT</name>
            <description>WDT Warn Limit Register</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>WARN_LIMIT</name>
                <description>Warn limit for watchdog.  See WARN_ACTION.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CONFIG</name>
            <description>WDT Configuration Register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x10</resetValue>
            <resetMask>0xB0001111</resetMask>
            <fields>
              <field>
                <name>LOWER_ACTION</name>
                <description>Action taken if this watchdog is serviced before LOWER_LIMIT is reached.  LOWER_ACTION is ignored (i.e. treated as NOTHING) when a debugger is connected and/or when the chip is in DeepSleep modes.
For LOWER_LIMIT &gt;= 1: The action is triggered on same edge when it meets this condition.
For LOWER_LIMIT == 0: No action is triggered.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>NOTHING</name>
                    <description>Do nothing</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RESET</name>
                    <description>Trigger a reset.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UPPER_ACTION</name>
                <description>Action taken if this watchdog is not serviced before UPPER_LIMIT is reached.  The counter stops counting when UPPER_LIMIT is reached, regardless of UPPER_ACTION setting.   UPPER_ACTION is ignored (i.e. treated as NOTHING) when a debugger is connected.
For UPPER_LIMIT &gt;= 2: The action is triggered on same edge when it meets this condition.
For UPPER_LIMIT &lt; 2: The action may take up to one extra clk_lf cycle to trigger.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>NOTHING</name>
                    <description>Do nothing</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RESET</name>
                    <description>Trigger a reset.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WARN_ACTION</name>
                <description>Action taken when the count value reaches WARN_LIMIT.  The minimum setting to achieve a periodic interrupt is WARN_LIMIT==1.  A setting of zero will trigger once but not periodically.
For WARN_LIMIT &gt;= 2: The action is triggered on same edge when it meets this condition.
For WARN_LIMIT &lt; 2  : The action may take up to one extra clk_lf cycle to trigger.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>NOTHING</name>
                    <description>Do nothing</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INT</name>
                    <description>Trigger an interrupt.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AUTO_SERVICE</name>
                <description>Automatically service when the count value reaches WARN_LIMIT.  This allows creation of a periodic interrupt if this counter is not needed as a watchdog.  This field is ignored when LOWER_ACTION&lt;&gt;NOTHING or when UPPER_ACTION&lt;&gt;NOTHING.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DEBUG_TRIGGER_EN</name>
                <description>Enables the trigger input for WDT to pause the counter during debug mode.  To pause at a breakpoint while debugging, configure the trigger matrix to connect the related CPU halted signal to the trigger input for this WDT, and then set this bit.  It takes up to two clk_lf cycles for the trigger signal to be processed.  Triggers that are less than two clk_lf cycles may be missed.  Synchronization error can accumulate each time it is halted.
0: Pauses the counter whenever a debug probe is connected.
1: Pauses the counter whenever a debug probe is connected and the trigger input is high.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DPSLP_PAUSE</name>
                <description>Pauses/runs this counter when the system is in DeepSleep.  Note it may take up to two clk_lf cycles for the counter to pause, due to internal synchronization.  During DeepSleep wakeup, the pause request is removed when clk_hf starts clocking, and then it may take up to two clk_lf cycles for the counter to start.  After wakeup, the LOWER_ACTION is ignored until after the first service.  This prevents an unintentional trigger of the LOWER_ACTION before the firmware realigns the servicing period.  After the first service, LOWER_ACTION behaves as configured.
0: Counter behaves normally during DeepSleep.
1: Counter pauses during DeepSleep.</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DEBUG_RUN</name>
                <description>Pauses/runs this counter while a debugger is connected.  Other behaviors are unchanged during debugging, including service, configuration updates and enable/disable.  Note it may take up to two clk_lf cycles for the counter to pause and another two cycles to unpause, due to internal synchronization.  If the debugger is connected for at least two clk_lf cycles, the LOWER_ACTION is ignored until after the first service after the debugger is disconnected.  This prevents an unintentional trigger of the LOWER_ACTION before the firmware realigns the servicing period.  After the first service, LOWER_ACTION behaves as configured.  If the debugger is disconnected before two clk_lf cycles, the LOWER_ACTION may or may not be ignored.
0: When debugger connected, counter pauses incrementing as configured in DEBUG_TRIGGER_EN.
1: When debugger connected, counter increments normally, but reset generation is blocked.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CNT</name>
            <description>WDT Count Register</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CNT</name>
                <description>Current value of subcounter for this WDT.  This field may lag the actual count value by up to one clk_lf cycle, due to internal synchronization.  When this subcounter is disabled and unlocked, the count value can be written for verification and debugging purposes.  Software writes are always ignored when the subcounter is enabled.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LOCK</name>
            <description>WDT Lock register</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x3</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>WDT_LOCK</name>
                <description>Prohibits writing control and configuration registers related to this WDT when not equal 0 (as specified in the other register descriptions).  Requires at least two different writes to unlock.
Note that this field is 2 bits to force multiple writes only.  This register also locks the clk_lf settings.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>NO_CHG</name>
                    <description>No effect</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLR0</name>
                    <description>Clears bit 0</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLR1</name>
                    <description>Clears bit 1</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SET01</name>
                    <description>Sets both bits 0 and 1</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>SERVICE</name>
            <description>WDT Service register</description>
            <addressOffset>0x44</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>SERVICE</name>
                <description>Services the watchdog.  This resets the count value to zero.  This may take up to three clk_lf cycle to take effect.  Hardware clears this bit, after necessary synchronization.  To ensure a pending SERVICE write is reflected, firmware should wait until this bit reads low before attempting to write SERVICE=1.  If WDT is disabled, SERVICE will not trigger a LOWER_ACTION and will not clear a preloaded count value.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>WDT Interrupt Register</description>
            <addressOffset>0x50</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>WDT</name>
                <description>WDT Interrupt Request.  This bit is set as configured by WDT action and limits.  Due to internal synchronization, it takes up to 8 SYSCLK cycles to update after a W1C or reading this register and during this time AHB bus is stalled.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>WDT Interrupt Set Register</description>
            <addressOffset>0x54</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>WDT</name>
                <description>Set interrupt.
Due to internal synchronization, it takes up to 8 SYSCLK cycles to update after a W1S or reading from this register and during this time AHB bus is stalled.  Reads back same as WDT_B.INTR.WDT</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>WDT Interrupt Mask Register</description>
            <addressOffset>0x58</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>WDT</name>
                <description>Mask for watchdog timer.  Clearing this bit will not forward the interrupt to the CPU.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>WDT Interrupt Masked Register</description>
            <addressOffset>0x5C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>WDT</name>
                <description>Logical and of corresponding request and mask bits.
Due to internal synchronization, it takes up to 8 SYSCLK cycles to read from this register.  During this time AHB bus is stalled.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>HPOSC_CTL</name>
          <description>High Precision Oscillator Control  (Lock Protected)</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x80000013</resetMask>
          <fields>
            <field>
              <name>LEAKC_DIS</name>
              <description>N/A</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTAT_SEL</name>
              <description>CTAT generator selection, only valid when CTAT_SW = 1.
0 - Low noise type CTAT generator
1 - Fast start-up type CTAT generator</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTAT_SWB</name>
              <description>Selection control for internal CTAT generator. 
0 - Auto Select (Fast start followed by low noise generator)
1 - Generator selected by CTAT_SEL</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IMO_EN</name>
              <description>HPOSC enable.  Setting this bit will enable the HPOSC and clearing this bit will disable the HPOSC.  Don't disable this clock if the system is using this clock as the source.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PILO_CTL</name>
          <description>Precision Low Power Oscillator Control  (Lock Protected)</description>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xC001</resetValue>
          <resetMask>0x8000FF13</resetMask>
          <fields>
            <field>
              <name>LEAKC_DIS</name>
              <description>N/A</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTAT_SEL</name>
              <description>CTAT generator selection, only valid when CTAT_SW = 1.
0 - Low noise type CTAT generator
1 - Fast start-up type CTAT generator</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTAT_SWB</name>
              <description>Selection control for internal CTAT generator. 
0 - Auto Select (Fast start followed by low noise generator)
1 - Generator selected by CTAT_SEL</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_CAP</name>
              <description>PILO user temperature fine trim.  This register field resets with hard reset (power related, XRES, WDT)..</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ILO_EN</name>
              <description>PILO enable.  Setting this bit will enable the PILO and clearing this bit will disable it.  Do not disable this clock prior to changing  CLK_LF to use the PILO as a source.  CLK_LF must be configured to use PILO as a source while the PILO clock is enabled prior to making such a change.   Writes to this field are ignored when LFCLK_SEL is using this clock as the source and WDT is locked using WDT_LOCK register.  Consequently, if CLK_LF is sourced by the PILO and the PILO is to be disabled, clear WDT_LOCK before-hand. This register field resets with hard reset (power related, XRES, WDT).</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_BG_TRIM1</name>
          <description>Bandgap Trim Register  (Lock Protected)</description>
          <addressOffset>0xFF00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xD</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>REF_VTRIM</name>
              <description>Trims the bandgap reference voltage output.  Used to trim the VBG to the voltage where its temperature curvature is minimal.  Bit [5] is unused within the bandgap block.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_BG_TRIM2</name>
          <description>Bandgap Trim Register  (Lock Protected)</description>
          <addressOffset>0xFF04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x23</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>REF_ITRIM</name>
              <description>Trims the bandgap reference current output.  Used to trim the IBG to the voltage where its temperature curvature is minimal.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_IMO_SELECT</name>
          <description>IMO Frequency Select Register  (Lock Protected)</description>
          <addressOffset>0xFF08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>FREQ</name>
              <description>Select operating frequency</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>24_MHZ</name>
                  <description>IMO runs at 24 MHz</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>28_MHZ</name>
                  <description>IMO runs at 28 MHz</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>32_MHZ</name>
                  <description>IMO runs at 32 MHz</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>36_MHZ</name>
                  <description>IMO runs at 36 MHz</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>40_MHZ</name>
                  <description>IMO runs at 40 MHz</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>44_MHZ</name>
                  <description>IMO runs at 44 MHz</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>48_MHZ</name>
                  <description>IMO runs at 48 MHz</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_IMO_TRIM1</name>
          <description>IMO Trim Register  (Lock Protected)</description>
          <addressOffset>0xFF0C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x6C</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>OFFSET</name>
              <description>Frequency trim bits.  These bits are determined at manufacturing time for each FREQ setting (IMO_TRIM2) and stored in SFLASH.  This field is hardware updated during USB osclock mode. This field is mapped to the most significant bits of the IMO trim imo_clk_trim[10:3].  The step size of 1 LSB on this field is nominally 160 kHz.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_IMO_TRIM2</name>
          <description>IMO Trim Register  (Lock Protected)</description>
          <addressOffset>0xFF10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xA0</resetValue>
          <resetMask>0xF7</resetMask>
          <fields>
            <field>
              <name>FSOFFSET</name>
              <description>Frequency trim bits.  These bits are not trimmed during manufacturing and kept at 0 under normal operation.  This field is hardware updated during USB osclock mode. This field is mapped to the least significant bits of the IMO trim imo_clk_trim[2:0].  The step size of 1 LSB on this field is nominally 20 kHz.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TCTRIM</name>
              <description>IMO temperature compensation trim.  These bits are determined at manufacturing time to adjust for temperature dependence. This bits are dependent on frequency and need to be changed using the Cypress provided frequency change algorithm.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_IMO_TRIM3</name>
          <description>IMO Trim Register  (Lock Protected)</description>
          <addressOffset>0xFF14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xF</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>STEPSIZE</name>
              <description>IMO trim stepsize bits.  These bits are determined at manufacturing time to adjust for process variation.  They are used to tune the stepsize of the FSOFFSET and OFFSET trims.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_PWRSYS_TRIM1</name>
          <description>Power System Trim Register  (Lock Protected)</description>
          <addressOffset>0xFF18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x10</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>DPSLP_REF_TRIM</name>
              <description>Trims the DeepSleep reference that is used by the DeepSleep regulator and DeepSleep power comparator.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPARE_TRIM</name>
              <description>Active-Reference temperature compensation trim (repurposed from spare bits).
Bits [7:6] - trim the Active-Reference IREF temperature coefficient (TC).
  00: TC = 0 (unchanged)
  01: TC = +80ppm/C 
  10: TC = -80ppm/C
  11: TC = -150ppm/C

Bits [5:4] - trim the Active-Reference VREF temperature coefficient (TC).
  00: TC = 0 (unchanged)
  01: TC = -50ppm/C 
  10: TC = -80ppm/C
  11: TC = +150ppm/C</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM_BODVCCD</name>
          <description>Brown Out Detect Trim (VCCD)  (Lock Protected)</description>
          <addressOffset>0xFF1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x8</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>BOD_TRIPSEL_VCCD</name>
              <description>BOD VCCD trim (production)</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BOD_RANGE_SELECT_VCCD</name>
              <description>Range select between 1.6V Vs 1.69V nominal.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM_OVDVCCD</name>
          <description>Over Voltage Detect Trim (VCCD)  (Lock Protected)</description>
          <addressOffset>0xFF20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x7</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>OVD_TRIPSEL_VCCD</name>
              <description>OVD VCCD trim (options)</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM_HPOSC0_CTL</name>
          <description>High Precision Oscillator Trim Control 0  (Lock Protected)</description>
          <addressOffset>0xFF24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xF</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>CTATEF</name>
              <description>HPOSC frequency CTAT extra-fine trim</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PTATEF</name>
              <description>Fine trim for HPOSC PTAT current</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTATEC</name>
              <description>Coarse trim for HPOSC CTAT current</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PTATEC</name>
              <description>Coarse trim for HPOSC PTAT current</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM_HPOSC1_CTL</name>
          <description>High Precision Oscillator Trim Control 1  (Lock Protected)</description>
          <addressOffset>0xFF28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xD</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>TCF</name>
              <description>HPOSC temp-co fine trim</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM_HPOSC2_CTL</name>
          <description>High Precision Oscillator Trim Control 2  (Lock Protected)</description>
          <addressOffset>0xFF2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xA4</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>PTAT</name>
              <description>HPOSC PTAT trim</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM_HPOSC3_CTL</name>
          <description>High Precision Oscillator Trim Control 3  (Lock Protected)</description>
          <addressOffset>0xFF30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xB1</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>CTAT</name>
              <description>HPOSC CTAT trim</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM_HPOSC4_CTL</name>
          <description>High Precision Oscillator Trim Control 4  (Lock Protected)</description>
          <addressOffset>0xFF34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>TOC</name>
              <description>HPOSC temp-co coarse trim</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HPOSC_LEAK</name>
              <description>HPOSC leakage cancellation trim</description>
              <bitRange>[7:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM_PILO0_CTL</name>
          <description>Low Frequency Oscillator Trim Control 0   (Lock Protected)</description>
          <addressOffset>0xFF38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>CTATEF</name>
              <description>PILO frequency CTAT extra-fine trim</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PTATEF</name>
              <description>PILO frequency PTATextra-fine trim</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTATEC</name>
              <description>PILO temperature CTAT extra-coarse trim</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PTATEC</name>
              <description>PILO temperature PTATextra-coarse trim</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM_PILO1_CTL</name>
          <description>Low Frequency Oscillator Trim Control 1   (Lock Protected)</description>
          <addressOffset>0xFF3C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>TCF</name>
              <description>PILO temp-co fine trim (MSB, bit 4, is not used)</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM_PILO2_CTL</name>
          <description>Low Frequency Oscillator Trim Control 2  (Lock Protected)</description>
          <addressOffset>0xFF40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>PTAT</name>
              <description>PILO frequency PTAT coarse trim</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM_PILO3_CTL</name>
          <description>Low Frequency Oscillator Trim Control 3  (Lock Protected)</description>
          <addressOffset>0xFF44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>CTAT</name>
              <description>PILO frequency CTAT coarse trim</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM_PILO4_CTL</name>
          <description>Low Frequency Oscillator Trim Control 4  (Lock Protected)</description>
          <addressOffset>0xFF48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>TCC</name>
              <description>PILO temperature coarse trim</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM_PILO5_CTL</name>
          <description>Low Frequency Oscillator Trim Control 5  (Lock Protected)</description>
          <addressOffset>0xFF4C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>PILO_TR_LEAK</name>
              <description>PILO leakage cancellation trim</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM_BODVDDD</name>
          <description>Brown Out Detect Trim (VDDD)  (Lock Protected)</description>
          <addressOffset>0xFF50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x8</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>BOD_TRIPSEL_VDDD</name>
              <description>BOD VDDD trim (options)</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM_OVDVDDD</name>
          <description>Over Voltage Detect Trim  (VDDD) (Lock Protected)</description>
          <addressOffset>0xFF54</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x7</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>OVD_TRIPSEL_VDDD</name>
              <description>OVD VDDD trim (options)</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVD_RANGE_SELECT_VDDD</name>
              <description>Range select between 3.8V Vs 5.77V nominal.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPIO</name>
      <description>GPIO port control/configuration</description>
      <baseAddress>0x40040000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>16384</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>2</dim>
          <dimIncrement>256</dimIncrement>
          <name>PRT[%s]</name>
          <description>GPIO port registers</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>DR</name>
            <description>Port output data register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DATA0</name>
                <description>IO pad 0 output data.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA1</name>
                <description>IO pad 1 output data.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA2</name>
                <description>IO pad 2 output data.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA3</name>
                <description>IO pad 3 output data.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA4</name>
                <description>IO pad 4 output data.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA5</name>
                <description>IO pad 5 output data.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA6</name>
                <description>IO pad 6 output data.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA7</name>
                <description>IO pad 7 output data.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PS</name>
            <description>Port IO pad state register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>DATA0</name>
                <description>IO pad 0 state:
1: Logic high, if the pin voltage is above the input buffer threshold, logic high.
0: Logic low, if the pin voltage is below that threshold, logic low.
If the drive mode for the pin is set to high Z Analog, the pin state will read 0 independent of the voltage on the pin.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA1</name>
                <description>IO pad 1 state.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA2</name>
                <description>IO pad 2 state.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA3</name>
                <description>IO pad 3 state.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA4</name>
                <description>IO pad 4 state.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA5</name>
                <description>IO pad 5 state.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA6</name>
                <description>IO pad 6 state.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA7</name>
                <description>IO pad 7 state.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FLT_DATA</name>
                <description>Reads of this register return the logical state of the filtered pin.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PC</name>
            <description>Port configuration register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFBFFFFFF</resetMask>
            <fields>
              <field>
                <name>DM0</name>
                <description>N/A</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OFF</name>
                    <description>Mode 0 (analog mode): Output buffer off (high Z). Input buffer off.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INPUT</name>
                    <description>Mode 1: Output buffer off (high Z). Input buffer on.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>0_PU</name>
                    <description>Mode 2: Strong pull down ('0'), weak/resistive pull up (PU). Input buffer on.
For GPIOV1P2_I2C, Strong pull down only.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PD_1</name>
                    <description>Mode 3: Weak/resistive pull down (PD), strong pull up ('1'). Input buffer on.
For GPIOV1P2_I2C: Weak pull down only.</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>0_Z</name>
                    <description>Mode 4: Strong pull down ('0'), open drain (pull up off). Input buffer on.
For GPIOV1P2_I2C, Strong pull down only.</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Z_1</name>
                    <description>Mode 5: Open drain (pull down off), strong pull up ('1'). Input buffer on.
Illegal for GPIOV1P2_I2C</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>0_1</name>
                    <description>Mode 6: Strong pull down ('0'), strong pull up ('1'). Input buffer on.
For GPIOV1P2_I2C, Strong pull down only.</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PD_PU</name>
                    <description>Mode 7: Weak/resistive pull down (PD), weak/resistive pull up (PU). Input buffer on.
For GPIOV1P2_I2C: Weak pull down only.</description>
                    <value>7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DM1</name>
                <description>N/A</description>
                <bitRange>[5:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DM2</name>
                <description>N/A</description>
                <bitRange>[8:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DM3</name>
                <description>N/A</description>
                <bitRange>[11:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DM4</name>
                <description>N/A</description>
                <bitRange>[14:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DM5</name>
                <description>N/A</description>
                <bitRange>[17:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DM6</name>
                <description>N/A</description>
                <bitRange>[20:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DM7</name>
                <description>N/A</description>
                <bitRange>[23:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PORT_VTRIP_SEL</name>
                <description>N/A</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PORT_SLOW</name>
                <description>N/A</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PORT_HYST_TRIM</name>
                <description>N/A</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PORT_SLEW_CTL</name>
                <description>This field is used to vary slew rate in I2C mode. It comes into picture only when slow=1 and DM=4 ( strong pull down, open drain). Following modes are supported and the corresponding fall time specs are mentioned:</description>
                <bitRange>[29:28]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>PORT_SLEW_CTL_0</name>
                    <description>HS mode (100pf &lt; Cb &lt; 400pF, 1.71&lt;VDDD&lt;5.5, Vext&gt;3.0)
FS mode (10pf&lt;Cb&lt;400pf,1.71&lt;VDDD&lt;5.5) (20-160ns)</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PORT_SLEW_CTL_1</name>
                    <description>HS mode (Cb&lt;100pf,1.71&lt;VDDD&lt;5.5,Vext&gt;2.8,F=1.7MHz) (10-80ns)
FS+ Mode (Vext&gt;2.8,1.71&lt;VDDD&lt;5.5) (20-120ns)</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PORT_SLEW_CTL_2</name>
                    <description>HS mode (100pf&lt;Cb&lt;400pf, 1.71&lt;VDDD&lt;5.5,Vext&lt;3.3) (20-160ns)</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PORT_SLEW_CTL_3</name>
                    <description>HS mode (Cb&lt;100pf,1.71&lt;VDDD&lt;5.5,Vext&lt;=2.8,F=1.7MHz) (10-80ns)
FS+ mode (Vext&lt;=2.8,1.71&lt;VDDD&lt;5.5) (20-120ns)</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PORT_IB_MODE_SEL</name>
                <description>N/A</description>
                <bitRange>[31:30]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_CFG</name>
            <description>Port interrupt configuration register</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FFFFF</resetMask>
            <fields>
              <field>
                <name>EDGE0_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pad 0.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <description>Disabled</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RISING</name>
                    <description>Rising edge</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING</name>
                    <description>Falling edge</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH</name>
                    <description>Both rising and falling edges</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EDGE1_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pad 1.</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE2_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pad 2.</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE3_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pad 3.</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE4_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pad 4.</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE5_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pad 5.</description>
                <bitRange>[11:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE6_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pad 6.</description>
                <bitRange>[13:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE7_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pad 7.</description>
                <bitRange>[15:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FLT_EDGE_SEL</name>
                <description>Same for the glitch filtered pin (selected by FLT_SEL).</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <description>Disabled</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RISING</name>
                    <description>Rising edge</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING</name>
                    <description>Falling edge</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH</name>
                    <description>Both rising and falling edges</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FLT_SEL</name>
                <description>Selects which pin is routed through the 50ns glitch filter to provide a glitch-safe interrupt.</description>
                <bitRange>[20:18]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Port interrupt status register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF01FF</resetMask>
            <fields>
              <field>
                <name>DATA0</name>
                <description>Interrupt pending on IO pad 0. Firmware writes 1 to clear the interrupt.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA1</name>
                <description>Interrupt pending on IO pad 1. Firmware writes 1 to clear the interrupt.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA2</name>
                <description>Interrupt pending on IO pad 2. Firmware writes 1 to clear the interrupt.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA3</name>
                <description>Interrupt pending on IO pad 3. Firmware writes 1 to clear the interrupt.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA4</name>
                <description>Interrupt pending on IO pad 4. Firmware writes 1 to clear the interrupt.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA5</name>
                <description>Interrupt pending on IO pad 5. Firmware writes 1 to clear the interrupt.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA6</name>
                <description>Interrupt pending on IO pad 6. Firmware writes 1 to clear the interrupt.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA7</name>
                <description>Interrupt pending on IO pad 7. Firmware writes 1 to clear the interrupt.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FLT_DATA</name>
                <description>Deglitched interrupt pending (selected by FLT_SEL).</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PS_DATA0</name>
                <description>`</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PS_DATA1</name>
                <description>N/A</description>
                <bitRange>[17:17]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PS_DATA2</name>
                <description>N/A</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PS_DATA3</name>
                <description>N/A</description>
                <bitRange>[19:19]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PS_DATA4</name>
                <description>N/A</description>
                <bitRange>[20:20]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PS_DATA5</name>
                <description>N/A</description>
                <bitRange>[21:21]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PS_DATA6</name>
                <description>N/A</description>
                <bitRange>[22:22]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PS_DATA7</name>
                <description>N/A</description>
                <bitRange>[23:23]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PS_FLT_DATA</name>
                <description>This is a duplicate of the contents of the PS register, provided here to allow reading of both pin state and interrupt state of the port in a single read operation.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIO</name>
            <description>Port SIO configuration register</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PAIR_VREG01_EN</name>
                <description>Selects output buffer mode:
0: unregulated output buffer
1: regulated output buffer

The regulated output configuration is selected ONLY if the dm&lt;2:0&gt; bits set a strong pull up configuration (Modes 3, 5, or 6). Weak pull up modes pull to VDDIO.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_IBUF01_SEL</name>
                <description>Selects input buffer mode:
0: singled ended input buffer with a threshold controlled by PAIR_VTRIP01_SEL
1: differential input buffer, see table in PAIR_VTRIP01_SEL description for details</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VTRIP01_SEL</name>
                <description>In single ended input buffer mode (PAIR_IBUF01_SEL = '0'):
VTRIP_SEL=0: input buffer functions as a CMOS input buffer.
VTRIP_SEL=1: input buffer functions as a LVTTL input buffer.

In differential input buffer mode (PAIR_IBUF01_SEL = '1'): 
PAIR_VREF01_SEL=00: 
  a) PAIR_VTRIP01_SEL=0 -&gt; Trip point=50 percent of vddio
  b) PAIR_VTRIP01_SEL=1 -&gt; Trip point=40 percent of vddio

PAIR_VREF01_SEL=01/10/11:
  a) PAIR_VTRIP01_SEL=0 -&gt; Trip point=50 percent of Voh (see table in PAIR_VOH01_SEL for details)
  b) PAIR_VTRIP01_SEL=1 -&gt; Trip point=Vref  (see table in PAIR_VREF01_SEL for details)</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VREF01_SEL</name>
                <description>Selects reference voltage Vref for trip-point of input buffer and reference for VOH regulator:
0: Vref = 1.2V (input buffers use vddio as Vref)
1: Vref = 1.2V
2: Vref = AMUXBUS_A
3: Vref = AMUXBUS_B</description>
                <bitRange>[4:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VOH01_SEL</name>
                <description>Selects regulated Voh output level and trip point of input buffer for a specific SIO pin pair. Voh depends on the selected Vref voltage (see table in PAIR_VREF_01SEL description for details). 
0: Voh = 1*vref 
1: Voh = 1.25*vref
2: Voh = 1.49*vref
3: Voh = 1.67*vref
4: Voh = 2.08*vref
5: Voh = 2.5*vref
6: Voh = 2.78*vref
7: Voh = 4.16*vref
Note: The upper value on Voh is limited to Vddio - 400mV</description>
                <bitRange>[7:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VREG23_EN</name>
                <description>N/A</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_IBUF23_SEL</name>
                <description>N/A</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VTRIP23_SEL</name>
                <description>N/A</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VREF23_SEL</name>
                <description>N/A</description>
                <bitRange>[12:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VOH23_SEL</name>
                <description>N/A</description>
                <bitRange>[15:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VREG45_EN</name>
                <description>N/A</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_IBUF45_SEL</name>
                <description>N/A</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VTRIP45_SEL</name>
                <description>N/A</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VREF45_SEL</name>
                <description>N/A</description>
                <bitRange>[20:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VOH45_SEL</name>
                <description>N/A</description>
                <bitRange>[23:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VREG67_EN</name>
                <description>N/A</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_IBUF67_SEL</name>
                <description>N/A</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VTRIP67_SEL</name>
                <description>N/A</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VREF67_SEL</name>
                <description>N/A</description>
                <bitRange>[28:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VOH67_SEL</name>
                <description>N/A</description>
                <bitRange>[31:29]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PC2</name>
            <description>Port configuration register 2</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>INP_DIS0</name>
                <description>Disables the input buffer for IO pad 0 independent of the port control drive mode (PC.DM). This bit should be set when analog signals are present on the pin and PC.DM != 0 is required to use the output driver.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INP_DIS1</name>
                <description>Disables the input buffer for IO pad 1.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INP_DIS2</name>
                <description>Disables the input buffer for IO pad 2.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INP_DIS3</name>
                <description>Disables the input buffer for IO pad 3.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INP_DIS4</name>
                <description>Disables the input buffer for IO pad 4.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INP_DIS5</name>
                <description>Disables the input buffer for IO pad 5.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INP_DIS6</name>
                <description>Disables the input buffer for IO pad 6.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INP_DIS7</name>
                <description>Disables the input buffer for IO pad 7.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DR_SET</name>
            <description>Port output data set register</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>IO pad i:
'0': Output state DR.DATA[i] not affected.
'1': Output state DR.DATA[i] set to '1'.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DR_CLR</name>
            <description>Port output data clear register</description>
            <addressOffset>0x44</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>IO pad i:
'0': Output state DR.DATA[i] not affected.
'1': Output state DR.DATA[i] set to '0'.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DR_INV</name>
            <description>Port output data invert register</description>
            <addressOffset>0x48</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>IO pad i:
'0': Output state DR.DATA[i] not affected.
'1': Output state DR.DATA[i] inverted ('0' =&gt; '1', '1' =&gt; '0').</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DS</name>
            <description>Port drive strength register</description>
            <addressOffset>0x4C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1AAAA</resetValue>
            <resetMask>0x3FFFF</resetMask>
            <fields>
              <field>
                <name>DS0</name>
                <description>N/A</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>0</name>
                    <description>1 ma drive nominal - changes with external R/C loading and I2C speed (Standard, Fast, Fast+)</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>1</name>
                    <description>2 ma drive nominal - changes with external R/C loading and I2C speed (Standard, Fast, Fast+)</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>2</name>
                    <description>4 ma drive nominal - changes with external R/C loading and I2C speed (Standard, Fast, Fast+)</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>3</name>
                    <description>8 ma drive nominal - changes with external R/C loading and I2C speed (Standard, Fast, Fast+)</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DS1</name>
                <description>N/A</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DS2</name>
                <description>N/A</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DS3</name>
                <description>N/A</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DS4</name>
                <description>N/A</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DS5</name>
                <description>N/A</description>
                <bitRange>[11:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DS6</name>
                <description>N/A</description>
                <bitRange>[13:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DS7</name>
                <description>N/A</description>
                <bitRange>[15:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PORT_V1P2_VTRIP_SEL</name>
                <description>N/A</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PORT_V1P2_IB_MODE_SEL</name>
                <description>N/A</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FILT_CONFIG</name>
            <description>IO filter config register</description>
            <addressOffset>0x50</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFF</resetMask>
            <fields>
              <field>
                <name>TRIM0</name>
                <description>N/A</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIM1</name>
                <description>N/A</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIM2</name>
                <description>N/A</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIM3</name>
                <description>N/A</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIM4</name>
                <description>N/A</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIM5</name>
                <description>N/A</description>
                <bitRange>[11:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIM6</name>
                <description>N/A</description>
                <bitRange>[13:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIM7</name>
                <description>N/A</description>
                <bitRange>[15:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FILT0_EN</name>
                <description>N/A</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FILT1_EN</name>
                <description>N/A</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FILT2_EN</name>
                <description>N/A</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FILT3_EN</name>
                <description>N/A</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FILT4_EN</name>
                <description>N/A</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FILT5_EN</name>
                <description>N/A</description>
                <bitRange>[21:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FILT6_EN</name>
                <description>N/A</description>
                <bitRange>[22:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FILT7_EN</name>
                <description>N/A</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>VREFGEN</name>
            <description>Reference generator configuration register</description>
            <addressOffset>0x80</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x11F</resetMask>
            <fields>
              <field>
                <name>REF_SEL</name>
                <description>Reference selection. A reference Voltage vinref is created using a Voltage vddio:
'0': vinref = (0 * 13 + 184)/600 * vddio = 184/600 * vddio.
'1': vinref = (1 * 13 + 184)/600 * vddio = 197/600 * vddio.
'2': vinref = (2 * 13 + 184)/600 * vddio = 210/600 * vddio.
...
'31': vinref = (31 * 13 + 184)/600 * vddio = 587/600 * vddio.</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREFGEN_EN</name>
                <description>Reference generator enable:
'0': Disabled.
'1': Enabled.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>INTR_CAUSE</name>
          <description>Interrupt port cause register</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PORT_INT</name>
              <description>Each IO port has an associated bit field in this register. The bit field reflects the IO port's interrupt line (bit field i reflects 'interrupts_gpio[i]' for IO port i). The register is used when the system uses a shared/combined interrupt line 'interrupt_gpio'. The SW ISR reads the register to determine which IO port(s) is responsible for the shared/combined interrupt line 'interrupt_gpio'. Once, the IO port(s) is determined, the IO port's INTR register is read to determine the IO pad(s) in the IO port that caused the interrupt.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DFT_IO_TEST</name>
          <description>IO SELF TEST control register for DfT purposes only</description>
          <addressOffset>0x1010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2020200</resetValue>
          <resetMask>0x1F1F1F03</resetMask>
          <fields>
            <field>
              <name>DFT_IO_TEST_MODE</name>
              <description>DfT IO SELF TEST mode:</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>Functional mode: disables the DfT IO SELF TEST; none of the 'DFT_*' control signals from this register control the IO cells.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TEST_ADFT</name>
                  <description>select this mode during ADFT testing to control 'hld_ovr/oe_n/ analog_sel/ analog_pol/ analog_en' signals of IO cells as below:
the ADFT-0 assigned IO cell connects to: DFT_*_0;  
the ADFT-1 assigned IO cell connects to: DFT_*_1; ...</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TEST_ANA</name>
                  <description>select this mode for testing analog switches to control 'hld_ovr/oe_n/analog_en/analog_sel/analog_pol' signals of IO cells as below:
the IO_TEST_0 assigned IO cell connects to: DFT_*_0;
the IO_TEST_1 assigned IO cell connects to: DFT_*_1;...</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TEST_GEN</name>
                  <description>select this mode for generic testing to control 'hld_ovr/oe_n/analog_en/analog_sel/analog_pol' signals of IO cells as below:
All IO cells connect to: DFT_*_2;</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DFT_HLD_OVR_0</name>
              <description>'hld_ovr' DfT control for IO cells depending on DFT_IO_TEST_MODE as given below.
TEST_ADFT: Connects to 'hld_ovr' of the ADFT-0  assigned IO cell.
TEST_ANA: Connects to 'hld_ovr' of the IO_TEST_0  assigned IO cell.
TEST_GEN: not used.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_OE_N_0</name>
              <description>'oe_n' DfT control for IO cells depending on DFT_IO_TEST_MODE as given below.
TEST_ADFT: Connects to 'oe_n' of the ADFT-0  assigned IO cell.
TEST_ANA: Connects to 'oe_n' of the IO_TEST_0  assigned IO cell.
TEST_GEN: not used.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_ANALOG_EN_0</name>
              <description>'analog_en' DfT control for IO cells depending on DFT_IO_TEST_MODE as given below.
TEST_ADFT: Connects to 'analog_en' of the ADFT-0  assigned IO cell.
TEST_ANA: Connects to 'analog_en' of the IO_TEST_0  assigned IO cell.
TEST_GEN: not used.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_ANA_SEL_0</name>
              <description>'analog_sel' DfT control for IO cells depending on DFT_IO_TEST_MODE as given below.
TEST_ADFT: Connects to 'analog_sel' of the ADFT-0  assigned IO cell.
TEST_ANA: Connects to 'analog_sel' of the IO_TEST_0  assigned IO cell.
TEST_GEN: not used.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_ANA_POL_0</name>
              <description>'analog_pol' DfT control for IO cells depending on DFT_IO_TEST_MODE as given below.
TEST_ADFT: Connects to 'analog_pol' of the ADFT-0  assigned IO cell.
TEST_ANA: Connects to 'analog_pol' of the IO_TEST_0  assigned IO cell.
TEST_GEN: not used.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_HLD_OVR_1</name>
              <description>'hld_ovr' DfT control for IO cells depending on DFT_IO_TEST_MODE as given below.
TEST_ADFT: Connects to 'hld_ovr' of the ADFT-1  assigned IO cell.
TEST_ANA: Connects to 'hld_ovr' of the IO_TEST_1  assigned IO cell.
TEST_GEN: not used.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_OE_N_1</name>
              <description>'oe_n' DfT control for IO cells depending on DFT_IO_TEST_MODE as given below.
TEST_ADFT: Connects to 'oe_n' of the ADFT-1  assigned IO cell.
TEST_ANA: Connects to 'oe_n' of the IO_TEST_1  assigned IO cell.
TEST_GEN: not used.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_ANALOG_EN_1</name>
              <description>'analog_en' DfT control for IO cells depending on DFT_IO_TEST_MODE as given below.
TEST_ADFT: Connects to 'analog_en' of the ADFT-1  assigned IO cell.
TEST_ANA: Connects to 'analog_en' of the IO_TEST_1  assigned IO cell.
TEST_GEN: not used.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_ANA_SEL_1</name>
              <description>'analog_sel' DfT control for IO cells depending on DFT_IO_TEST_MODE as given below.
TEST_ADFT: Connects to 'analog_sel' of the ADFT-1  assigned IO cell.
TEST_ANA: Connects to 'analog_sel' of the IO_TEST_1  assigned IO cell.
TEST_GEN: not used.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_ANA_POL_1</name>
              <description>'analog_pol' DfT control for IO cells depending on DFT_IO_TEST_MODE as given below.
TEST_ADFT: Connects to 'analog_pol' of the ADFT-1  assigned IO cell.
TEST_ANA: Connects to 'analog_pol' of the IO_TEST_1  assigned IO cell.
TEST_GEN: not used.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_HLD_OVR_2</name>
              <description>'hld_ovr' DfT control for IO cells depending on DFT_IO_TEST_MODE as given below.
TEST_ADFT: Connects to 'hld_ovr' of all IO cells other than ADFT-0/1 .
TEST_ANA: Connects to 'hld_ovr' of all IO cells other than IO_TEST_0/1.
TEST_GEN: Connects to 'hld_ovr' of all IO cells.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_OE_N_2</name>
              <description>'oe_n' DfT control for IO cells depending on DFT_IO_TEST_MODE as given below.
TEST_ADFT: Connects to 'oe_n' of all IO cells other than ADFT-0/1.
TEST_ANA: Connects to 'oe_n' of all IO cells other than IO_TEST_0/1.
TEST_GEN: Connects to 'oe_n' of all IO cells</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_ANALOG_EN_2</name>
              <description>'analog_en' DfT control for IO cells depending on DFT_IO_TEST_MODE as given below.
TEST_ADFT: Connects to 'analog_en' of all IO cells other than ADFT-0/1.
TEST_ANA: DFT_ANALOG_EN_2 &amp;&amp; DM[0] connects to 'analog_en' of all IO cells other than IO_TEST_0/1.
TEST_GEN: Connects to 'analog_en' of all IO cells</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_ANA_SEL_2</name>
              <description>'analog_sel' DfT control for IO cells depending on DFT_IO_TEST_MODE as given below.
TEST_ADFT: Connects to 'analog_sel' of all IO cells other than ADFT-0/1.
TEST_ANA: Connects to 'analog_sel' of all IO cells other than IO_TEST_0/1.
TEST_GEN: Connects to 'analog_sel' of all IO cells.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_ANA_POL_2</name>
              <description>'analog_pol' DfT control for IO cells depending on DFT_IO_TEST_MODE as given below.
TEST_ADFT: Connects to 'analog_pol' of all IO cells other than ADFT-0/1.
TEST_ANA: Connects to 'analog_pol' of all IO cells other than IO_TEST_0/1.
TEST_GEN: Connects to 'analog_pol' of all IO cells.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIOV1P2_DET</name>
          <description>GPIOV1P2 Detect output</description>
          <addressOffset>0x1020</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>DET</name>
              <description>Indicates HI when VDDIO is in 1.8V range, and LOW when VDDIO is in 1.2V range.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>TCPWM</name>
      <description>Timer/Counter/PWM</description>
      <baseAddress>0x40090000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTRL</name>
          <description>TCPWM control register 0.</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>COUNTER_ENABLED</name>
              <description>Counter enables for counters 0 up to CNT_NR-1.
'0': counter disabled.
'1': counter enabled.
Counter static configuration information (e.g. CTRL.MODE, all TR_CTRL0, TR_CTRL1, and TR_CTRL2 register fields) should only be modified when the counter is disabled. When a counter is disabled, command and status information associated to the counter is cleared by HW, this includes:
- the associated counter triggers in the CMD register are set to '0'.
- the counter's interrupt cause fields in counter's INTR register.
- the counter's status fields in counter's STATUS register..
- the counter's trigger outputs ('tr_overflow', 'tr_underflow' and 'tr_compare_match').
- the counter's line outputs ('line_out' and 'line_compl_out').</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD</name>
          <description>TCPWM command register.</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNTER_CAPTURE</name>
              <description>Counters SW capture trigger. When written with '1', a capture trigger is generated and the HW sets the field to '0' when the SW trigger has taken effect. It should be noted that the HW operates on the counter frequency. If the counter is disabled through CTRL.COUNTER_ENABLED, the field is immediately set to '0'.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COUNTER_RELOAD</name>
              <description>Counters SW reload trigger. For HW behavior, see COUNTER_CAPTURE field.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COUNTER_STOP</name>
              <description>Counters SW stop trigger. For HW behavior, see COUNTER_CAPTURE field.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COUNTER_START</name>
              <description>Counters SW start trigger. For HW behavior, see COUNTER_CAPTURE field.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_CAUSE</name>
          <description>TCPWM Counter interrupt cause register.</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>COUNTER_INT</name>
              <description>Counters interrupt signal active. If the counter is disabled through CTRL.COUNTER_ENABLED, the associated interrupt field is immediately set to '0'.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <cluster>
          <name>CNT</name>
          <description>Timer/Counter/PWM Counter Module</description>
          <addressOffset>0x00000100</addressOffset>
          <register>
            <name>CTRL</name>
            <description>Counter control register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x737FF0F</resetMask>
            <fields>
              <field>
                <name>AUTO_RELOAD_CC</name>
                <description>Specifies switching of the CC and buffered CC values. This field has a function in TIMER, PWM, PWM_DT and PWM_PR modes.
Timer mode:
'0': never switch.
'1': switch on a compare match event.
PWM, PWM_DT, PWM_PR modes: 
'0: never switch.
'1': switch on a terminal count event with an actively pending switch event.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AUTO_RELOAD_PERIOD</name>
                <description>Specifies switching of the PERIOD and buffered PERIOD values. This field has a function in PWM, PWM_DT and PWM_PR modes.
'0': never switch.
'1': switch on a terminal count event with an actively pending switch event.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PWM_SYNC_KILL</name>
                <description>Specifies asynchronous/synchronous kill behavior:
'1': synchronous kill mode: the kill event disables the 'dt_line_out' and 'dt_line_compl_out' signals till the next terminal count event (synchronous kill). In synchronous kill mode, STOP_EDGE should  be RISING_EDGE.
'0': asynchronous kill mode: the kill event only disables the 'dt_line_out' and 'dt_line_compl_out' signals when present. In asynchronous kill mode, STOP_EDGE should be NO_EDGE_DET. 

This field has a function in PWM and PWM_DT modes only. This field is only used when PWM_STOP_ON_KILL is '0'.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PWM_STOP_ON_KILL</name>
                <description>Specifies whether the counter stops on a kill events:
'0': kill event does NOT stop counter.
'1': kill event stops counter.

This field has a function in PWM, PWM_DT and PWM_PR modes only.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>GENERIC</name>
                <description>Generic 8-bit control field. In PWM_DT mode, this field is used to determine the dead time: amount of dead time cycles in the counter clock domain. In all other modes, the lower 3 bits of this field determine pre-scaling of the selected counter clock.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>UP_DOWN_MODE</name>
                <description>Determines counter direction.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>COUNT_UP</name>
                    <description>Count up (to PERIOD). An overflow event is generated when the counter reaches PERIOD, and is changed to a different value. A terminal count event is generated when the counter reaches PERIOD, and is changed to a different value.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>COUNT_DOWN</name>
                    <description>Count down (to '0'). An underflow event is generated when the counter reaches '0', and is changed to a different value. A terminal count event is generated when the counter reaches '0', and is changed to a different value.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>COUNT_UPDN1</name>
                    <description>Count up (to PERIOD), then count down (to '0'). An overflow event is generated when the counter reaches PERIOD, and is changed to a different value. An underflow event is generated when the counter reaches '0', and is changed to a different value. A terminal count event is generated when the counter reaches '0', and is changed to a different value.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>COUNT_UPDN2</name>
                    <description>Count up (to PERIOD), then count down (to '0'). An overflow event is generated when the counter reaches PERIOD, and is changed to a different value. An underflow event is generated when the counter reaches '0', and is changed to a different value. A terminal count event is generated when the counter reaches '0', and is changed to a different value AND when the counter reaches PERIOD, and is changed to a different value. (this counter direction can be used for PWM functionality with asymmetrical updates).</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ONE_SHOT</name>
                <description>When '0', counter runs continuous. When '1', counter is turned off by hardware when a terminal count event is generated.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>QUADRATURE_MODE</name>
                <description>In QUAD mode selects quadrature encoding mode (X1/X2/X4).
In PWM, PWM_DT and PWM_PR modes, these two bits can be used to invert 'dt_line_out' and 'dt_line_compl_out'.  Inversion is the last step in generation of 'dt_line_out' and 'dt_line_compl_out'; i.e. a disabled output line 'dt_line_out' has the value QUADRATURE_MODE[0] and a disabled output line 'dt_line_compl_out' has the value QUADRATURE_MODE[1].</description>
                <bitRange>[21:20]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>X1</name>
                    <description>X1 encoding (QUAD mode)</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>X2</name>
                    <description>X2 encoding (QUAD mode)</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>X4</name>
                    <description>X4 encoding (QUAD mode)</description>
                    <value>2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE</name>
                <description>Counter mode.</description>
                <bitRange>[26:24]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>TIMER</name>
                    <description>Timer mode</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CAPTURE</name>
                    <description>Capture mode</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>QUAD</name>
                    <description>Quadrature encoding mode</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PWM</name>
                    <description>Pulse width modulation (PWM) mode</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PWM_DT</name>
                    <description>PWM with deadtime insertion mode</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PWM_PR</name>
                    <description>Pseudo random pulse width modulation</description>
                    <value>6</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>STATUS</name>
            <description>Counter status register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x8000FF01</resetMask>
            <fields>
              <field>
                <name>DOWN</name>
                <description>When '0', counter is counting up. When '1', counter is counting down. In QUAD mode, this field indicates the direction of the latest counter change: '0' when last incremented and '1' when last decremented.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>GENERIC</name>
                <description>Generic 8-bit counter field. In PWM_DT mode, this counter is used for dead time insertion. In all other modes, this counter is used for pre-scaling the selected counter clock. PWM_DT mode can NOT use prescaled clock functionality.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RUNNING</name>
                <description>When '0', the counter is NOT running. When '1', the counter is running.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>COUNTER</name>
            <description>Counter count register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>COUNTER</name>
                <description>16-bit counter value. It is advised to not write to this field when the counter is running.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CC</name>
            <description>Counter compare/capture register</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xFFFF</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>CC</name>
                <description>In CAPTURE mode, captures the counter value. In other modes, compared to counter value.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CC_BUFF</name>
            <description>Counter buffered compare/capture register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xFFFF</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>CC</name>
                <description>Additional buffer for counter CC register.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PERIOD</name>
            <description>Counter period register</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xFFFF</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>PERIOD</name>
                <description>Period value: upper value of the counter. When the counter should count for n cycles, this field should be set to n-1.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PERIOD_BUFF</name>
            <description>Counter buffered period register</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xFFFF</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>PERIOD</name>
                <description>Additional buffer for counter PERIOD register.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TR_CTRL0</name>
            <description>Counter trigger control register 0</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x10</resetValue>
            <resetMask>0xFFFFF</resetMask>
            <fields>
              <field>
                <name>CAPTURE_SEL</name>
                <description>Selects one of the 16 input triggers as a capture trigger. Input trigger 0 is always '0' and input trigger 1 is always '1'. Input trigger 2 is the first external trigger line (tcpwm.tr_in[0]).

In the PWM, PWM_DT and PWM_PR modes this trigger is used to switch the values if the compare and period registers with their buffer counterparts.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>COUNT_SEL</name>
                <description>Selects one of the 16 input triggers as a count trigger. In QUAD mode, this is the first phase (phi A). Default setting selects input trigger 1, which is always '1'.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RELOAD_SEL</name>
                <description>Selects one of the 16 input triggers as a reload trigger. In QUAD mode, this is the index or revolution pulse. In this mode, it will update the counter with the value in the TCPWM_CNTn_PERIOD register.</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>STOP_SEL</name>
                <description>Selects one of the 16 input triggers as a stop trigger. In PWM, PWM_DT and PWM_PR modes, this is the kill trigger. In these modes, the kill trigger is used to either temporarily block the PWM outputs (PWM_STOP_ON_KILL is '0') or stop the functionality (PWM_STOP_ON_KILL is '1'). For the PWM and PWM_DT modes, the blocking of the output signals can be  asynchronous (STOP_EDGE should be NO_EDGE_DET) in which case the blocking is as long as the trigger is '1' or synchronous (STOP_EDGE should be RISING_EDGE) in which case it extends till the next terminal count event.</description>
                <bitRange>[15:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>START_SEL</name>
                <description>Selects one of the 16 input triggers as a start trigger. In QUAD mode, this is the second phase (phi B).</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TR_CTRL1</name>
            <description>Counter trigger control register 1</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x3FF</resetValue>
            <resetMask>0x3FF</resetMask>
            <fields>
              <field>
                <name>CAPTURE_EDGE</name>
                <description>A capture event will copy the counter value into the CC register.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <description>Rising edge. Any rising edge generates an event.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <description>Falling edge. Any falling edge generates an event.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <description>No edge detection, use trigger as is.</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>COUNT_EDGE</name>
                <description>A counter event will increase or decrease the counter by '1'.</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <description>Rising edge. Any rising edge generates an event.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <description>Falling edge. Any falling edge generates an event.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <description>No edge detection, use trigger as is.</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RELOAD_EDGE</name>
                <description>A reload event will initialize the counter. When counting up, the counter is initialized to '0'. When counting down, the counter is initialized with PERIOD.</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <description>Rising edge. Any rising edge generates an event.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <description>Falling edge. Any falling edge generates an event.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <description>No edge detection, use trigger as is.</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>STOP_EDGE</name>
                <description>A stop event, will stop the counter; i.e. it will no longer be running. Stopping will NOT disable the counter.</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <description>Rising edge. Any rising edge generates an event.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <description>Falling edge. Any falling edge generates an event.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <description>No edge detection, use trigger as is.</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>START_EDGE</name>
                <description>A start event will start the counter; i.e. the counter will become running. Starting does NOT enable the counter. A start event will not initialize the counter whereas the reload event does.</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <description>Rising edge. Any rising edge generates an event.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <description>Falling edge. Any falling edge generates an event.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <description>No edge detection, use trigger as is.</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TR_CTRL2</name>
            <description>Counter trigger control register 2</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x3F</resetValue>
            <resetMask>0x3F</resetMask>
            <fields>
              <field>
                <name>CC_MATCH_MODE</name>
                <description>Determines the effect of a compare match event (COUNTER equals CC register) on the 'line_out' output signals.  Note that INVERT is especially useful for center aligned pulse width modulation.
To generate a duty cycle of 0 percent, the counter CC register should be set to '0'. For a 100 percent duty cycle, the counter CC register should be set to larger than the counter PERIOD register.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>SET</name>
                    <description>Set to '1'</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLEAR</name>
                    <description>Set to '0'</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INVERT</name>
                    <description>Invert</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_CHANGE</name>
                    <description>No Change</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OVERFLOW_MODE</name>
                <description>Determines the effect of a counter overflow event (COUNTER reaches PERIOD) on the 'line_out' output signals.</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>SET</name>
                    <description>Set to '1'</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLEAR</name>
                    <description>Set to '0'</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INVERT</name>
                    <description>Invert</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_CHANGE</name>
                    <description>No Change</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UNDERFLOW_MODE</name>
                <description>Determines the effect of a counter underflow event (COUNTER reaches '0') on the 'line_out' output signals.</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>SET</name>
                    <description>Set to '1'</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLEAR</name>
                    <description>Set to '0'</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INVERT</name>
                    <description>Invert</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_CHANGE</name>
                    <description>No Change</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Interrupt request register.</description>
            <addressOffset>0x30</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>TC</name>
                <description>Terminal count event. Set to '1', when event is detected. Write with '1' to clear bit.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CC_MATCH</name>
                <description>Counter matches CC register event. Set to '1', when event is detected. Write with '1' to clear bit.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt set request register.</description>
            <addressOffset>0x34</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>TC</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CC_MATCH</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt mask register.</description>
            <addressOffset>0x38</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>TC</name>
                <description>Mask bit for corresponding bit in interrupt request register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CC_MATCH</name>
                <description>Mask bit for corresponding bit in interrupt request register.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt masked request register</description>
            <addressOffset>0x3C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>TC</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CC_MATCH</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>CPUSS</name>
      <description>CPU Subsystem</description>
      <baseAddress>0x40100000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>4096</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>srss_interrupt_srss</name>
        <description>SRSS interrupts</description>
        <value>0</value>
      </interrupt>
      <interrupt>
        <name>srss_wdt_irq</name>
        <description>WDT Interrupt</description>
        <value>1</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupt_gpio</name>
        <description>GPIO consolidated interrupt</description>
        <value>2</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_0</name>
        <description>GPIO P0</description>
        <value>3</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_1</name>
        <description>GPIO P1</description>
        <value>4</value>
      </interrupt>
      <interrupt>
        <name>usbpd_0_interrupt_wakeup</name>
        <description>Ganged USBPD Interrupt</description>
        <value>5</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupt_spcif</name>
        <description>SPCIF interrupt</description>
        <value>6</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupt_fault_0</name>
        <description>Fault structure 0 interrupt</description>
        <value>7</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupt_fault_1</name>
        <description>Fault structure 1 interrupt</description>
        <value>8</value>
      </interrupt>
      <interrupt>
        <name>usbpd_0_interrupt</name>
        <description>Synchronous USBPD Interrupts</description>
        <value>9</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_interrupts_0</name>
        <description>TCPWM counter #0</description>
        <value>10</value>
      </interrupt>
      <registers>
        <register>
          <name>CONFIG</name>
          <description>Configuration register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>VECT_IN_RAM</name>
              <description>0': Vector Table is located at 0x0000:0000 in flash
'1': Vector Table is located at 0x2000:0000 in SRAM
Note that vectors for RESET and FAULT are always fetched from ROM. Value in flash/RAM is ignored for these vectors.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SYSREQ</name>
          <description>SYSCALL control register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x30000000</resetValue>
          <resetMask>0xFC00FFFF</resetMask>
          <fields>
            <field>
              <name>SYSCALL_COMMAND</name>
              <description>Opcode of the system call being requested.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EXTERNAL_SYS_REQ</name>
              <description>External HW SYS REQ. This bit is set by HW to cause a SYSCALL to BOOTROM.  This bit may only be cleared by SW. When this bit is set, the SYSCALL_COMMAND, PRIVILEDGED, HMASTER0,  and SYSCALL_ARG content are invalid.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DIS_RESET_VECT_REL</name>
              <description>Disable Reset Vector fetch relocation:
'0': CPU accesses to locations 0x0000:0000 - 0x0000:0007 are redirected to ROM.
'1': CPU accesses to locations 0x0000:0000 - 0x0000:0007 are made to flash.
Note that this field defaults to '0' on reset, ensuring actual reset vector fetches are always made to ROM. Note that this field does not affect DAP accesses. Flash DfT routines may set this bit to '1' to enable uninhibited read-back of programmed data in the first flash page.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRIVILEGED</name>
              <description>Indicates whether the system is in privileged ('1') or user mode ('0'). Only CPU SW executing from ROM can set this field to '1' when ROM_ACCESS_EN is '1' (the CPU is executing a SystemCall NMI interrupt handler). Any other write to this field sets is to '0'. This field is used as the AHB-Lite hprot[1] signal to implement Cypress proprietary user/privileged modes. These modes are used to enable/disable access to specific MMIO registers and memory regions.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ROM_ACCESS_EN</name>
              <description>Indicates that executing from Boot ROM is enabled. HW sets this field to '1', on reset or when the SystemCall NMI vector is fetched from Boot ROM. HW sets this field to '0', when the CPU is NOT executing from either Boot or System ROM. This bit is used for debug purposes only.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>HMASTER_0</name>
              <description>Indicates the source of the write access to the SYSREQ register.
'0': CPU write access.
'1': DAP write access.

For a SW write to the SYSREQ register, the HW will update this field based on the value of SYSCALL_REQ.

SYSCALL_REQ = 0 : the current source of write access is captured.
SYSCALL_REQ = 1 : the previous value (captured when SYSCALL_REQ was 0), is retained/maintained until the next SW write to this register.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSCALL_REQ</name>
              <description>CPU/DAP writes a '1' to this field to request a SystemCall. The HMASTER_0 field indicates the source of the write access. Setting this field to '1' immediate results in a NMI. The SystemCall NMI interrupt handler sets this field to '0' after servicing the request.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SYSARG</name>
          <description>SYSARG control register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SYSCALL_ARG</name>
              <description>Argument to System Call specified in SYSREQ. Semantics of argument depends on system call made. Typically a pointer to a parameter block.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_SEL</name>
          <description>Interrupt multiplexer select register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DSI</name>
              <description>Specifies interrupt source:
'0': Fixed Function.
'1': DSI.
When changing the source of a specific interrupt, it is advised to temporarily disable the interrupt using the CM0 NVIC's CLRENA and SETENA interrupt enable clear and set registers to prevent a spurious interrupt activation. In addition, the CM0 NVIC's CLRPEND interrupt pending clear register should be used clear a pending interrupt before re-enabling the interrupt.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_MODE</name>
          <description>DSI interrupt pulse mode register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DSI_INT_PULSE</name>
              <description>Specifies DSI interrupt format:
'0': level sensitive; i.e. no pulse generator.
'1': pulse generator on rising edge.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NMI_MODE</name>
          <description>DSI NMI pulse mode register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>DSI_NMI_PULSE</name>
              <description>Specifies DSI NMI format:
'0': level sensitive; i.e. no pulse generator.
'1': pulse generator on rising edge.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_CTL</name>
          <description>FLASH control register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x33011F</resetMask>
          <fields>
            <field>
              <name>FLASH_WS</name>
              <description>For Flash With ECC the number of wait states (WS):
WS = 3 for SYSCLK &lt;= FMAX
WS = 2 for SYSCLK &lt;= 3/4 * FMAX
WS = 1 for SYSCLK &lt;= 1/2 * FMAX
WS = 0 for SYSCLK &lt;= 1/4 * FMAX
4-15 : Future Use - To be used, if 3 Wait State is not sufficient.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PREF_EN</name>
              <description>N/A</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLASH_INVALIDATE</name>
              <description>N/A</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARB</name>
              <description>N/A</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLASH_ECC_INJ_EN</name>
              <description>N/A</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLASH_ERR_SILENT</name>
              <description>N/A</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ROM_CTL</name>
          <description>ROM control register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x30001</resetMask>
          <fields>
            <field>
              <name>ROM_WS</name>
              <description>Amount of ROM wait states:
'0': 0 wait states. Use this setting for newer, faster ROM design. Use this setting for older, slower ROM design and frequencies in the range [0, 24] MHz.
'1': 1 wait state. Use this setting for older, slower ROM design and frequencies in the range &lt;24, 48] MHz.

Should always be set to 0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARB</name>
              <description>N/A</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM_CTL</name>
          <description>RAM control register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x30055</resetMask>
          <fields>
            <field>
              <name>ECC_ENABLE</name>
              <description>Enable ECC operation:
'0': ECC Disabled - ECC is not generated/checked
'1': ECC Enabled - ECC is generated/checked</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_AUTO_CORRECT</name>
              <description>HW ECC autocorrect functionality:
'0': Disabled.
'1': Enabled. HW automatically writes back SRAM with corrected data when a recoverable ECC error is detected.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_INJ_EN</name>
              <description>Enable error injection.
0:  Syndrome is source from ECC Syndrome hardware.
1: ECC_TEST.SYND_DATA is used when a full 32-bit write is done to the ECC_TEST.WORD_ADDR word address of SRAM0.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_BIST_SWITCH</name>
              <description>ECC_BIST_SWITCH: Substitutes Syndrome bits for normal data path during BIST testing. Data bits 31:25 on the SRAM data path both to and from the SRAM are replaced with the SRAM Syndrome data bits 38:32 during BIST testing when this bit is set to 1.
'0': Source normal datapath to BIST bus
'1': Source Syndrome bits to BIST bus</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARB</name>
              <description>Arbitration Policy:
'0': CPU has priority
'1': DW/DMA has priority
'2': Roundrobin
'3': Roundrobin - sticky</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CTL</name>
          <description>DMA controller register</description>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x30000</resetMask>
          <fields>
            <field>
              <name>ARB</name>
              <description>Arbitration policy:
0: CPU has priority
1: DW/DMA has priority
2: Roundrobin
3: Roundrobin - sticky</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM1_CTL</name>
          <description>RAM 1 control register</description>
          <addressOffset>0xA4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x30055</resetMask>
          <fields>
            <field>
              <name>ECC_ENABLE</name>
              <description>Enable ECC operation:
'0': ECC Disabled - ECC is not generated/checked
'1': ECC Enabled - ECC is generated/checked</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_AUTO_CORRECT</name>
              <description>HW ECC autocorrect functionality:
'0': Disabled.
'1': Enabled. HW automatically writes back SRAM with corrected data when a recoverable ECC error is detected.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_INJ_EN</name>
              <description>Enable error injection.
0:  Syndrome is source from ECC Syndrome hardware.
1: ECC_TEST.SYND_DATA is used when a full 32-bit write is done to the ECC_TEST.WORD_ADDR word address of SRAM1.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_BIST_SWITCH</name>
              <description>ECC_BIST_SWITCH: Substitutes Syndrome bits for normal data path during BIST testing. Data bits 31:25 on the SRAM data path both to and from the SRAM are replaced with the SRAM Syndrome data bits 38:32 during BIST testing when this bit is set to 1.
'0': Source normal datapath to BIST bus
'1': Source Syndrome bits to BIST bus</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARB</name>
              <description>Arbitration policy:
0: CPU has priority
1: DW/DMA has priority
2: Roundrobin
3: Roundrobin - sticky</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASHC1_CTL</name>
          <description>FLASH Control1  control register</description>
          <addressOffset>0xA8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x33011F</resetMask>
          <fields>
            <field>
              <name>FLASH_WS</name>
              <description>Amount of ROM wait states:
For Flash (without ECC).
0: 0 wait states (fast flash: [0, 24] MHz system frequency, slow flash: [0, 16] MHz system frequency)
1: 1 wait state (fast flash: [24, 48] MHz system frequency, slow flash: [16, 32] MHz system frequency)
2: 2 wait states (slow flash: [32, 48] MHz system frequency)
3-15 : Future Use.

For Flash With ECC.
0: 0 wait states ([0, 12] MHz system frequency)
1: 1 wait state ([12, 24] MHz system frequency)
2: 2 wait states (24,36] MHz system frequency)
3: 3 wait states ([36,48] MHz System Frequency)
4-15 : Future Use - To be used, if 3 Wait State is not sufficient.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PREF_EN</name>
              <description>Prefetch enable:
'0': disabled. This is a desirable setting when FLASH_WS is 0 or when predictable execution behavior is required.
'1': enabled.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLASH_INVALIDATE</name>
              <description>1': Invalidates the content of the flash controller's buffers.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARB</name>
              <description>Arbitration policy:
0: CPU has priority
1: DW/DMA has priority
2: Roundrobin
3: Roundrobin - sticky</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLASH_ECC_INJ_EN</name>
              <description>Enable error injection for FLASH main interface.
When'1', the parity (ECC_CTL.PARITY[7:0]) is used for a load from the ECC_CTL.WORD_ADDR[23:0] word address.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLASH_ERR_SILENT</name>
              <description>Specifies bus transfer behavior for a non-recoverable error on the FLASH macro main interface (either a non-correctable ECC error, a FLASH macro main interface internal error, a FLASH macro main interface memory hole access, a M0S8 protection violation error):
0: Bus transfer has a bus error.
1: Bus transfer does NOT have a bus error; i.e. the error is 'silent'

In either case, a Zero value is returned. 

This field is ONLY used by CPU bus transfers. Non-CPU bus transfers always have a bus transfer with a bus error, in case of a non-recoverable error</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FAULT_CTL</name>
          <description>Fault Control Register</description>
          <addressOffset>0xAC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x30000</resetMask>
          <fields>
            <field>
              <name>ARB</name>
              <description>Arbitration policy:
0: CPU has priority
1: DW/DMA has priority
2: Roundrobin
3: Roundrobin - sticky</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MTB_CTL</name>
          <description>MTB control register</description>
          <addressOffset>0xB0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>CPU_HALT_TSTOP_EN</name>
              <description>1': Enable CPU Halt to stop MTB trace. (HALTED output of CM0+ can stop the trace when high/'1')
'0': HALTED output of CM0+ can not strop trace.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DAP_CTL</name>
          <description>SWD DP Instance ID</description>
          <addressOffset>0xC4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>INSTANCE_ID</name>
              <description>Specifies the SWD DP Instance ID
This is used with the SWD Multi-Drop feature to uniquely identify a chip.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM_STATUS</name>
          <description>RAM Controller 0 Status</description>
          <addressOffset>0xD0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>WB_EMPTY</name>
              <description>Write buffer empty. This information is used when entering DeepSleep power mode: WB_EMPTY must be '1' before a transition to system DeepSleep power mode.
'0': Write buffer NOT empty.
'1': Write buffer empty.

Note: the SRAM controller write buffer is only used when ECC checking is enabled. (RAMi_CTL.ECC_EN is '1').</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM1_STATUS</name>
          <description>RAM Controller 1 Status</description>
          <addressOffset>0xD4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>WB_EMPTY</name>
              <description>Write buffer empty. This information is used when entering DeepSleep power mode: WB_EMPTY must be '1' before a transition to system DeepSleep power mode.
'0': Write buffer NOT empty.
'1': Write buffer empty.

Note: the SRAM controller write buffer is only used when ECC checking is enabled. (RAMi_CTL.ECC_EN is '1').</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BOOT_RESULT_0</name>
          <description>Boot Result Register 0</description>
          <addressOffset>0xE0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BOOT_RESULT</name>
              <description>Record details of Boot Process.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BOOT_RESULT_1</name>
          <description>Boot Result Register 1</description>
          <addressOffset>0xE4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BOOT_RESULT</name>
              <description>Record details of Boot Process.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>24</dim>
          <dimIncrement>4</dimIncrement>
          <name>SL_CTL[%s]</name>
          <description>Slave control register</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x30000</resetMask>
          <fields>
            <field>
              <name>ARB</name>
              <description>Arbitration policy:
0: CPU priority
1: DMA priority
2: Roundrobin
3: Roundrobin - sticky</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM_ECC_STATUS0</name>
          <description>RAM ECC Status 0</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>ECC_CAPTURE_ADDR_31_2</name>
              <description>Snapshot of CPUSS Address which caused the first correctable/un-correctable error interrupt. When first correctable/un-correctable error interrupt is generated, ECC_CAPTURE_ADDR_SYNDROME_VALID is transitioned from 0 to 1 , and this registered captures the first error address. The register only captures bits 31-2 of the address.</description>
              <bitRange>[29:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ECC_CAPTURE_ADDR_SYNDROME_VALID</name>
              <description>ECC Capture address and Syndrome valid.  
0: ECC_CAPTURE_ADDR_31_2 not valid
1: ECC_CAPTURE_ADDR_31_2 valid - SW writes a 1 to clear</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM_ECC_STATUS1</name>
          <description>RAM ECC Status 1</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>ECC_CAPTURE_SYNDROME</name>
              <description>Snapshot of CPUSS Syndrome which caused the first correctable/un-correctable error interrupt. When first correctable/un-correctable error interrupt is generated, ECC_CAPTURE_ADDR_SYNDROME_VALID is transitioned from 0 to 1 , and this registered captures the first Syndrome corresponding to the Error.</description>
              <bitRange>[6:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM1_ECC_STATUS0</name>
          <description>RAM1 ECC Status 0</description>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>ECC_CAPTURE_ADDR_31_2</name>
              <description>Snapshot of CPUSS Address which caused the first correctable/un-correctable error interrupt. When first correctable/un-correctable error interrupt is generated, ECC_CAPTURE_ADDR_SYNDROME_VALID is transitioned from 0 to 1 , and this registered captures the first error address. The register only captures bits 31-2 of the address.</description>
              <bitRange>[29:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ECC_CAPTURE_ADDR_SYNDROME_VALID</name>
              <description>ECC Capture address and Syndrome valid.  
0: ECC_CAPTURE_ADDR_31_2 not valid
1: ECC_CAPTURE_ADDR_31_2 valid - SW writes a 1 to clear</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM1_ECC_STATUS1</name>
          <description>RAM1 ECC Status 1</description>
          <addressOffset>0x20C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>ECC_CAPTURE_SYNDROME</name>
              <description>Snapshot of CPUSS Syndrome which caused the first correctable/un-correctable error interrupt. When first correctable/un-correctable error interrupt is generated, ECC_CAPTURE_ADDR_SYNDROME_VALID is transitioned from 0 to 1 , and this registered captures the first Syndrome corresponding to the Error.</description>
              <bitRange>[6:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECC_TEST</name>
          <description>ECC Test</description>
          <addressOffset>0x210</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WORD_ADDR</name>
              <description>Specifies the word address where an error will be injected.
- For SRAMs, the word address WORD_ADDR[24:0] is the device address A[26:2]. On a write transfer to this SRAM address and when the corresponding RAM_CTL.ECC_INJ_EN or RAM1_CTL.ECC_INJ_EN bit is '1', the parity (SYND_DATA[6:0]) is injected into the corresponding SRAM location.</description>
              <bitRange>[24:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SYND_DATA</name>
              <description>ECC syndrome to use for error injection at address WORD_ADDR.</description>
              <bitRange>[31:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>Interrupt register</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>SRAM0_C_ERROR</name>
              <description>Correctable ECC Error For SRAM - interrupt signaled on interrupt_sram_nc_ecc</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SRAM0_NC_ERROR</name>
              <description>Uncorrectable ECC Error For SRAM - interrupt signaled on interrupt_sram_nc_ecc</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SRAM1_C_ERROR</name>
              <description>Correctable ECC Error For SRAM1 - interrupt signaled on interrupt_sram1_c_ecc</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SRAM1_NC_ERROR</name>
              <description>Uncorrectable ECC Error For SRAM1 - interrupt signaled on interrupt_sram1_nc_ecc</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>Interrupt set register</description>
          <addressOffset>0x304</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>SRAM0_C_ERROR</name>
              <description>SW writes a '1' to this field to set the corresponding field in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SRAM0_NC_ERROR</name>
              <description>SW writes a '1' to this field to set the corresponding field in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SRAM1_C_ERROR</name>
              <description>SW writes a '1' to this field to set the corresponding field in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SRAM1_NC_ERROR</name>
              <description>SW writes a '1' to this field to set the corresponding field in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>Interrupt mask register</description>
          <addressOffset>0x308</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>SRAM0_C_ERROR</name>
              <description>Mask bit for corresponding field in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SRAM0_NC_ERROR</name>
              <description>Mask bit for corresponding field in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SRAM1_C_ERROR</name>
              <description>Mask bit for corresponding field in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SRAM1_NC_ERROR</name>
              <description>Mask bit for corresponding field in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>Interrupt masked register</description>
          <addressOffset>0x30C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>SRAM0_C_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SRAM0_NC_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SRAM1_C_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SRAM1_NC_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EXT_MS_CTL</name>
          <description>External master control register</description>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x30000</resetMask>
          <fields>
            <field>
              <name>ARB</name>
              <description>Arbitration policy:
0: EXTM0/DMAC has priority
1: EXTM1 has priority
2: Roundrobin
3: Roundrobin - sticky</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASHC_BERR_STATUS</name>
          <description>Flash Bus Error Status</description>
          <addressOffset>0x500</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>INTERNAL_ERROR</name>
              <description>N/A</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLASH_UNCORRECTABLE</name>
              <description>N/A</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLASH_MEMORY_HOLE</name>
              <description>N/A</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLASH_PROT_VIO</name>
              <description>A protection violation occurred in Flash Controller.

SW clears this field to '0'. HW sets this field to '1' on a protection violation occurred in Flash Controllers. Typically, SW reads this field after a code section to detect the occurrence of an error.

Note: this field is independent of FLASH_CTL.FLASH_ERR_SILENT.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASHC1_BERR_STATUS</name>
          <description>Flash 1 Bus Error Status</description>
          <addressOffset>0x504</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>INTERNAL_ERROR</name>
              <description>See the Explanation for FLASHC_BERR_STATUS</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLASH_UNCORRECTABLE</name>
              <description>See the Explanation for FLASHC_BERR_STATUS</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLASH_MEMORY_HOLE</name>
              <description>See the Explanation for FLASHC_BERR_STATUS</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLASH_PROT_VIO</name>
              <description>See the Explanation for FLASHC_BERR_STATUS</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASHC_ECC_CTL</name>
          <description>Flash ECC Control</description>
          <addressOffset>0x508</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FLASH_WORD_ADDR</name>
              <description>Specifies the word address where an error will be injected.
- For FLASH  interface ECC, the word address WORD_ADDR[23:0] is device address A[26:3]. On a FLASH main interface read and when FLASH_CTL.MAIN_ECC_INJ_EN bit is '1', the parity (PARITY[7:0]) replaces the FLASH macro parity (FLASH main interface read path is manipulated).</description>
              <bitRange>[23:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>ECC parity to use for ECC error injection at address WORD_ADDR. 
- For FLASH  interface ECC, the 8-bit parity PARITY[7:0] is for a 64-bit word.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASHC1_ECC_CTL</name>
          <description>Flash 1 ECC Control</description>
          <addressOffset>0x50C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FLASH_WORD_ADDR</name>
              <description>See the Explanation for FLASHC_ECC_CTL</description>
              <bitRange>[23:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>See the Explanation for FLASHC_ECC_CTL</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SPCIF</name>
      <description>Flash Control Interface</description>
      <baseAddress>0x40110000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>GEOMETRY</name>
          <description>Flash/NVL geometry information</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>FLASH</name>
              <description>Regular flash capacity in 256 Byte multiples (chip dependent). If multiple flash macros are present, this field provides the flash capacity of all flash macros together:
'0': 256 Bytes.
'1': 2*256 Bytes.
...
'16383': 16384*256 Bytes.</description>
              <bitRange>[13:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SFLASH</name>
              <description>Supervisory flash capacity in 256 Byte multiples (chip dependent). If multiple flash macros are present, this field provides the supervisory flash capacity of all flash macros together:
'0': 256 Bytes.
'1': 2*256 Bytes.
...
'63': 64*256 Bytes.</description>
              <bitRange>[19:14]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NUM_FLASH</name>
              <description>Number of flash macros (chip dependent):
'0': 1 flash macro
'1': 2 flash macros
'2': 3 flash macros
'3': 4 flash macros</description>
              <bitRange>[21:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FLASH_ROW</name>
              <description>Page size in 64 Byte multiples (chip dependent):
'0': 64 byte
'1': 128 byte
'2': 192 byte
'3': 256 byte

The page size is used to determine the number of Bytes in a page for Flash page based operations (e.g. PGM_PAGE).

Note: the field name FLASH_ROW is misleading, as this field specifies the number of Bytes in a page, rather than the number of Bytes in a row. In a single plane flash macro architecture, a page consists of a single row. However, in a multi plane flash macro architecture, a page consists of multiple rows from different planes.</description>
              <bitRange>[23:22]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NVL</name>
              <description>NVLatch size in Byte multiples (chip dependent):
'0': 0 Bytes
'1': 1 Byte
...
'127': 127 Bytes</description>
              <bitRange>[30:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DE_CPD_LP</name>
              <description>0': SRAM busy wait loop has not been copied.
'1': Busy wait loop has been written into SRAM.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NVL_WR_DATA</name>
          <description>NVL write data register</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data to be written to NVLatch array</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_LOCK</name>
          <description>Flash Lock Register</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>KEY</name>
              <description>Write Only register that locks/unlocks access to the  FLASH MACRO_WE register by writing a key value to the register. The Key is the 32 bit value '0xF56B3A81'. When this specific bit pattern is written to the register, write access to FLASH_MACRO_WE is toggled between locked and unlocked. The bit FLASH_MACRO_WE.LOCKED toggles upon receipt of the required key value.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_MACRO_WE</name>
          <description>Flash Macro Write Enable</description>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xF</resetValue>
          <resetMask>0x8000000F</resetMask>
          <fields>
            <field>
              <name>MAC_WRITE_EN</name>
              <description>Access control to Flash Macros Write Access. This is a bit mask where each bit controls Program/Erase Access to the corresponding Macro. When the bit is set to '1' then the Macro may be programmed/erased, when the bit is set to '0', the Macro content is locked. The content of this register may only be changed when FLASH_MACRO_WE.LOCKED is '0'.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCKED</name>
              <description>When set indicates that write access to FLASH_MACRO_WE.MAC_WRITE_EN is blocked. The value of this bit toggles when the key value is written into FLASH_LOCK.KEY.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>SPCIF interrupt request register</description>
          <addressOffset>0x7F0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>TIMER</name>
              <description>Timer counter value reaches '0'. Set to '1', when event is detected. Write INTR field with '1', to clear bit. Write INTR_SET field with '1', to set bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>SPCIF interrupt set request register</description>
          <addressOffset>0x7F4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>TIMER</name>
              <description>Write INTR_SET field with '1' to set corresponding INTR field.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>SPCIF interrupt mask register</description>
          <addressOffset>0x7F8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>TIMER</name>
              <description>Mask for corresponding field in INTR register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>SPCIF interrupt masked request register</description>
          <addressOffset>0x7FC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>TIMER</name>
              <description>Logical and of corresponding request and mask fields.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>FAULT</name>
      <description>Fault structures</description>
      <baseAddress>0x40130000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>2</dim>
          <dimIncrement>256</dimIncrement>
          <name>STRUCT[%s]</name>
          <description>Fault structure</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>CTL</name>
            <description>Fault control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>TR_EN</name>
                <description>Trigger output enable:
'0': Disabled. The trigger output 'tr_fault' is '0'.
'1': Enabled. The trigger output 'tr_fault' reflects STATUS.VALID. The trigger can be used to initiate a Datawire transfer of the FAULT data (FAULT_DATA0 through FAULT_DATA1).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT_EN</name>
                <description>IO output signal enable:
'0': Disabled. The IO output signal 'fault_out' is '0'. The IO output enable signal 'fault_out_en' is '0'.
'1': Enabled. The IO output signal 'fault_out' reflects STATUS.VALID. The IO output enable signal 'fault_out_en' is '1'.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RESET_REQ_EN</name>
                <description>Reset request enable:
'0': Disabled.
'1': Enabled. The output reset request signal 'fault_reset_req' reflects STATUS.VALID. This reset causes a warm/soft/core reset. This warm/soft/core reset does not affect the fault logic STATUS, DATA0, ..., DATA1 registers (allowing for post soft reset failure analysis).

The 'fault_reset_req' signals of the individual fault report structures are combined (logically OR'd) into a single SRSS 'fault_reset_req' signal.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>STATUS</name>
            <description>Fault status</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000000</resetMask>
            <fields>
              <field>
                <name>IDX</name>
                <description>The fault source index for which fault information is captured in DATA0 through DATA1. The fault information is fault source specific and differs per product. The encoding will align with the definition in the Product Srpeadsheet.

Note: this register field (and associated fault source data in DATA0 through DATA1) should only be considered valid, when VALID is '1'.</description>
                <bitRange>[6:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VALID</name>
                <description>Valid indication:
'0': Invalid.
'1': Valid. STATUS.IDX, DATA0, ..., DATA1 specify the fault.

Note: Typically, HW sets this field to '1' (on an activated HW fault source that is 'enabled' by the MASK registers) and SW clears this field to '0' (typically by boot code SW (after a warm system reset, when the fault is handled). In this typical use case scenario, the HW source fault data is simultaneously captured into DATA0, ..., DATA1 when the VALID field is set to '1'. 

An exceptional SW use case scenario is identified as well. In this scenario, SW sets this field to '1' with a fault source index different to one of the defined HW fault sources. SW update is not restricted by the MASK registers). In both use case scenarios, the following holds:
- STATUS.IDX, DATA0, ..., DATA1 can only be written when STATUS.VALID is '0'; the fault structure is not in use yet. Writing STATUS.VALID to '1' effectively locks the fault structure (until SW clears STATUS.VALID to '0'). This restriction requires a SW update to sequentially update the DATA registers followed by an update of the STATUS register.

Note: For the exceptional SW use case, sequential updates to the DATA and STATUS registers may be 'interrupted' by a HW fault capture. In this case, the SW DATA register updates are overwritten by the HW update (and the STATUS.IDX field will reflect the HW capture)</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>2</dim>
            <dimIncrement>4</dimIncrement>
            <name>DATA[%s]</name>
            <description>Fault data</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>Captured fault source data. 

Note: the DATA registers can only be written when STATUS.VALID is '0'.

Note: the fault source index STATUS.IDX specifies the format of the DATA registers.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PENDING0</name>
            <description>Fault pending 0</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>SOURCE</name>
                <description>Bit mask of source causing the Fault. See the Product Spreadsheet Fault tab to determine the bit ordering.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MASK0</name>
            <description>Fault mask 0</description>
            <addressOffset>0x50</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SOURCE</name>
                <description>Fault source enables:
Bits 31-0: Fault sources 31 to 0.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Interrupt</description>
            <addressOffset>0xC0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>FAULT</name>
                <description>This interrupt cause field is activated (HW sets the field to '1') when an enabled (MASK0 pending fault source is captured:
- STATUS.VALID is set to '1'.
- STATUS.IDX specifies the fault source index.
- DATA0 through DATA1 captures the fault source data.

SW writes a '1' to this field to clear the interrupt cause to '0'. SW clear STATUS.VALID to '0' to enable capture of the next fault. Note that when there is an enabled pending fault source, the pending fault source is captured immediately and INTR.FAULT is immediately activated (set to '1').</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt set</description>
            <addressOffset>0xC4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>FAULT</name>
                <description>SW writes a '1' to this field to set the corresponding field in the INTR register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt mask</description>
            <addressOffset>0xC8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>FAULT</name>
                <description>Mask bit for corresponding field in the INTR register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt masked</description>
            <addressOffset>0xCC</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>FAULT</name>
                <description>Logical and of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
  </peripherals>
</device>