<?xml version="1.0" encoding="utf-8"?>
<device schemaVersion="1.3" xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" xs:noNamespaceSchemaLocation="CMSIS-SVD.xsd">
  <vendor>Infineon Technologies</vendor>
  <vendorID>Infineon</vendorID>
  <name>psoc4hvms128k</name>
  <series>PSOC4HVMS128K</series>
  <version>1.0</version>
  <description>PSOC4HVMS128K</description>
  <licenseText>(c) (2016-2024), Cypress Semiconductor Corporation (an Infineon company)\n
    or an affiliate of Cypress Semiconductor Corporation.\n
\n
    SPDX-License-Identifier: Apache-2.0\n
\n
    Licensed under the Apache License, Version 2.0 (the "License");\n
    you may not use this file except in compliance with the License.\n
    You may obtain a copy of the License at\n
\n
      http://www.apache.org/licenses/LICENSE-2.0\n
\n
    Unless required by applicable law or agreed to in writing, software\n
    distributed under the License is distributed on an "AS IS" BASIS,\n
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n
    See the License for the specific language governing permissions and\n
    limitations under the License.</licenseText>
  <cpu>
    <name>CM0PLUS</name>
    <revision>r0p1</revision>
    <endian>little</endian>
    <mpuPresent>true</mpuPresent>
    <fpuPresent>false</fpuPresent>
    <vtorPresent>true</vtorPresent>
    <nvicPrioBits>2</nvicPrioBits>
    <vendorSystickConfig>false</vendorSystickConfig>
  </cpu>
  <addressUnitBits>8</addressUnitBits>
  <width>32</width>
  <resetValue>0x00000000</resetValue>
  <resetMask>0xFFFFFFFF</resetMask>
  <peripherals>
    <peripheral>
      <name>PERI</name>
      <description>Peripheral Interconnect</description>
      <baseAddress>0x40010000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>DIV_CMD</name>
          <description>Divider command register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFF</resetValue>
          <resetMask>0xC000FFFF</resetMask>
          <fields>
            <field>
              <name>SEL_DIV</name>
              <description>(SEL_TYPE, SEL_DIV) specifies the divider on which the command (DISABLE/ENABLE) is performed.
 
If SEL_DIV is '63' and 'SEL_TYPE' is '3' (default/reset value), no divider is specified and no clock signal(s) are generated.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEL_TYPE</name>
              <description>Specifies the divider type of the divider on which the command is performed:
0: 8.0 (integer) clock dividers.
1: 16.0 (integer) clock dividers.
2: 16.5 (fractional) clock dividers.
3: 24.5 (fractional) clock dividers.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PA_SEL_DIV</name>
              <description>(PA_SEL_TYPE, PA_SEL_DIV) specifies the divider to which phase alignment is performed for the clock enable command. Any enabled divider can be used as reference. This allows all dividers to be aligned with each other, even when they are enabled at different times.
 
If PA_SEL_DIV is '63' and 'PA_SEL_TYPE' is '3', 'clk_hf' is used as reference.</description>
              <bitRange>[13:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PA_SEL_TYPE</name>
              <description>Specifies the divider type of the divider to which phase alignment is performed for the clock enable command:
0: 8.0 (integer) clock dividers.
1: 16.0 (integer) clock dividers.
2: 16.5 (fractional) clock dividers.
3: 24.5 (fractional) clock dividers.</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DISABLE</name>
              <description>Clock divider disable command (mutually exclusive with ENABLE). SW sets this field to '1' and HW sets this field to '0'.
 
The SEL_DIV and SEL_TYPE fields specify which divider is to be disabled.
 
The HW sets the DISABLE field to '0' immediately and the HW sets the DIV_XXX_CTL.EN field of the divider to '0' immediately.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLE</name>
              <description>Clock divider enable command (mutually exclusive with DISABLE). Typically, SW sets this field to '1' to enable a divider and HW sets this field to '0' to indicate that divider enabling has completed. When a divider is enabled, its integer and fractional (if present) counters are initialized to '0'. If a divider is to be re-enabled using different integer and fractional divider values, the SW should follow these steps:
0: Disable the divider using the DIV_CMD.DISABLE field.
1: Configure the divider's DIV_XXX_CTL register.
2: Enable the divider using the DIV_CMD_ENABLE field.
 
The SEL_DIV and SEL_TYPE fields specify which divider is to be enabled. The enabled divider may be phase aligned to either 'clk_hf' (typical usage) or to ANY enabled divider.
 
The PA_SEL_DIV and P_SEL_TYPE fields specify the reference divider.
 
The HW sets the ENABLE field to '0' when the enabling is performed and the HW sets the DIV_XXX_CTL.EN field of the divider to '1' when the enabling is performed. Note that enabling with phase alignment to a low frequency divider takes time. E.g. To align to a divider that generates a clock of 'clk_hf'/n (with n being the integer divider value INT_DIV+1), up to n cycles may be required to perform alignment. Phase alignment to 'clk_hf' takes affect immediately. SW can set this field to '0' during phase alignment to abort the enabling process.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>64</dim>
          <dimIncrement>4</dimIncrement>
          <name>PCLK_CTL[%s]</name>
          <description>Programmable clock control register</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFF</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>SEL_DIV</name>
              <description>Specifies one of the dividers of the divider type specified by SEL_TYPE.
 
If SEL_DIV is '63' and 'SEL_TYPE' is '3' (default/reset value), no divider is specified and no clock control signal(s) are generated.
 
When transitioning a clock between two out of phase dividers, spurious clock control signals may be generated for one 'clk_hf' cycle during this transition. These clock control signals may cause a single clock period that is smaller than any of the two divider periods. To prevent these spurious clock signals, the clock multiplexer can be disconnected (SEL_DIV is '63' and 'SEL_TYPE' is '3') for a transition time that is larger than the smaller of the two divider periods.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEL_TYPE</name>
              <description>Specifies divider type:
0: 8.0 (integer) clock dividers.
1: 16.0 (integer) clock dividers.
2: 16.5 (fractional) clock dividers.
3: 24.5 (fractional) clock dividers.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>64</dim>
          <dimIncrement>4</dimIncrement>
          <name>DIV_8_CTL[%s]</name>
          <description>Divider control register (for 8.0 divider)</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF01</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
 
Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INT8_DIV</name>
              <description>Integer division by (1+INT8_DIV). Allows for integer divisions in the range [1, 256]. Note: this type of divider does NOT allow for a fractional division.
 
For the generation of a divided clock, the integer division range is restricted to [2, 256].
 
For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 256]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>64</dim>
          <dimIncrement>4</dimIncrement>
          <name>DIV_16_CTL[%s]</name>
          <description>Divider control register (for 16.0 divider)</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF01</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
 
Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INT16_DIV</name>
              <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: this type of divider does NOT allow for a fractional division.
 
For the generation of a divided clock, the integer division range is restricted to [2, 65,536].
 
For the generation of a 50/50 percent duty cycle digital divided clock, the integer division range is restricted to even numbers in the range [2, 65,536]. The generation of a 50/50  percent duty cycle analog divided clock has no restrictions.
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[23:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>64</dim>
          <dimIncrement>4</dimIncrement>
          <name>DIV_16_5_CTL[%s]</name>
          <description>Divider control register (for 16.5 divider)</description>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFF9</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
 
Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FRAC5_DIV</name>
              <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_hf' cycle longer than other clock periods.
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[7:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT16_DIV</name>
              <description>Integer division by (1+INT16_DIV). Allows for integer divisions in the range [1, 65,536]. Note: combined with fractional division, this divider type allows for a division in the range [1, 65,536 31/32] in 1/32 increments.
 
For the generation of a divided clock, the division range is restricted to [2, 65,536 31/32].
 
For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 65,536].
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[23:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>63</dim>
          <dimIncrement>4</dimIncrement>
          <name>DIV_24_5_CTL[%s]</name>
          <description>Divider control register (for 24.5 divider)</description>
          <addressOffset>0x500</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFF9</resetMask>
          <fields>
            <field>
              <name>EN</name>
              <description>Divider enabled. HW sets this field to '1' as a result of an ENABLE command. HW sets this field to '0' as a result on a DISABLE command.
 
Note that this field is retained. As a result, the divider does NOT have to be re-enabled after transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FRAC5_DIV</name>
              <description>Fractional division by (FRAC5_DIV/32). Allows for fractional divisions in the range [0, 31/32]. Note that fractional division results in clock jitter as some clock periods may be 1 'clk_hf' cycle longer than other clock periods.
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[7:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INT24_DIV</name>
              <description>Integer division by (1+INT24_DIV). Allows for integer divisions in the range [1, 16,777,216]. Note: combined with fractional division, this divider type allows for a division in the range [1, 16,777,216 31/32] in 1/32 increments.
 
For the generation of a divided clock, the integer division range is restricted to [2, 16,777,216 31/32].
 
For the generation of a 50/50 percent duty cycle divided clock, the  division range is restricted to [2, 16,777,216].
 
Note that this field is retained. However, the counter that is used to implement the division is not and will be initialized by HW to '0' when transitioning from DeepSleep to Active power mode.</description>
              <bitRange>[31:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TR_CTL</name>
          <description>Trigger control register</description>
          <addressOffset>0x600</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC0FF0F7F</resetMask>
          <fields>
            <field>
              <name>TR_SEL</name>
              <description>Specifies the activated trigger when TR_ACT is '1'. TR_OUT specifies whether the activated trigger is an input trigger or output trigger to the trigger multiplexer. During activation (TR_ACT is '1'), SW should not modify this register field. If the specified trigger is not present, the trigger activation has no effect.</description>
              <bitRange>[6:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_GROUP</name>
              <description>Specifies the trigger group.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_COUNT</name>
              <description>Amount of cycles a specific trigger is activated. During activation (TR_ACT is '1'), HW decrements this field to '0' using a cycle counter. During activation, SW should not modify this register field. A value of 255 is a special case: HW does NOT decrement this field to '0' and trigger activation is under direct control of TR_ACT: when TR_ACT is '1' the trigger is activated and when TR_ACT is '0' the trigger is deactivated.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_OUT</name>
              <description>Specifies whether trigger activation is for a specific input or output trigger of the trigger multiplexer. Activation of a specific input trigger, will result in activation of all output triggers that have the specific input trigger selected through their TR_OUT_CTL.SEL  field. Activation of a specific output trigger, will result in activation of the specified TR_SEL output trigger only.
'0': TR_SEL selection and trigger activation is for an input trigger to the trigger multiplexer.
'1': TR_SEL selection and trigger activation is for an output trigger from the trigger multiplexer.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_ACT</name>
              <description>SW sets this field to '1' to activate (set to '1') a trigger as identified by TR_SEL and TR_OUT for TR_COUNT cycles. HW sets this field to '0' when the cycle counter is decremented to '0'. Note: a TR_COUNT value of 255 is a special case and trigger activation is under direct control of the TR_ACT field (the counter is not decremented).
 Note: when TR_ACT is '1', SW should not modify the other register fields.
  SW MUST NOT set TR_ACT bit to '1' while updating the other register bits simultaneously.
  At first the SW MUST update the other register bits as needed, and then set TR_ACT to '1' with a new register write.'</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>6</dim>
          <dimIncrement>512</dimIncrement>
          <name>TR_GROUP[%s]</name>
          <description>Peripheral Interconnect trigger group control registers</description>
          <addressOffset>0x00002000</addressOffset>
          <register>
            <dim>128</dim>
            <dimIncrement>4</dimIncrement>
            <name>TR_OUT_CTL[%s]</name>
            <description>Trigger control register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7F</resetMask>
            <fields>
              <field>
                <name>SEL</name>
                <description>Specifies input trigger. This field is typically set during the setup of a chip use case scenario. Changing this field while activated triggers are present on the input triggers may result in unpredictable behavior. Note that input trigger 0 (default value) is typically connected to a constant signal level of '0', and as a result will not cause HW activation of the output trigger.</description>
                <bitRange>[6:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>HSIOM</name>
      <description>High Speed IO Matrix (HSIOM)</description>
      <baseAddress>0x40020000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>16384</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>8</dim>
          <dimIncrement>256</dimIncrement>
          <name>PRT[%s]</name>
          <description>HSIOM port registers</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>PORT_SEL</name>
            <description>Port selection register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>IO0_SEL</name>
                <description>N/A</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>GPIO</name>
                    <description>SW controlled GPIO.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>GPIO_DSI</name>
                    <description>SW controlled 'out', DSI controlled 'oe_n'.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DSI_DSI</name>
                    <description>DSI controlled 'out' and 'oe_n'.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DSI_GPIO</name>
                    <description>DSI controlled 'out', SW controlled 'oe_n'.</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CSD_SENSE</name>
                    <description>CSD sense connection (analog mode)</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CSD_SHIELD</name>
                    <description>CSD shield connection (analog mode)</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>AMUXA</name>
                    <description>AMUXBUS A connection.</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>AMUXB</name>
                    <description>AMUXBUS B connection. This mode is also used for CSD GPIO charging.  When CSD GPIO charging is enabled in CSD_CONTROL, 'oe_n' is connected to '!csd_charge' signal (and IO pad is also still connected to AMUXBUS B).</description>
                    <value>7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_0</name>
                    <description>Chip specific Active source 0 connection.</description>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_1</name>
                    <description>Chip specific Active source 1 connection.</description>
                    <value>9</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_2</name>
                    <description>Chip specific Active source 2 connection.</description>
                    <value>10</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ACT_3</name>
                    <description>Chip specific Active source 3 connection.</description>
                    <value>11</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>LCD_COM</name>
                    <description>LCD common connection. This mode provides DeepSleep functionality (provided that the LCD block exists, is enabled, and is properly configured).</description>
                    <value>12</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>LCD_SEG</name>
                    <description>LCD segment connection. This mode provides DeepSleep functionality  (provided that the LCD block is enabled and properly configured).</description>
                    <value>13</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_2</name>
                    <description>Chip specific DeepSleep source 2 connection.</description>
                    <value>14</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>DS_3</name>
                    <description>Chip specific DeepSleep source 3 connection.</description>
                    <value>15</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>IO1_SEL</name>
                <description>N/A</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO2_SEL</name>
                <description>N/A</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO3_SEL</name>
                <description>N/A</description>
                <bitRange>[15:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO4_SEL</name>
                <description>N/A</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO5_SEL</name>
                <description>N/A</description>
                <bitRange>[23:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO6_SEL</name>
                <description>N/A</description>
                <bitRange>[27:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IO7_SEL</name>
                <description>N/A</description>
                <bitRange>[31:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>PUMP_CTL</name>
          <description>Pump control</description>
          <addressOffset>0x2000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000001</resetMask>
          <fields>
            <field>
              <name>CLOCK_SEL</name>
              <description>Clock select:
'0': External clock.
'1': Internal clock (deprecated).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>Pump enabled:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>4</dimIncrement>
          <name>AMUX_SPLIT_CTL[%s]</name>
          <description>AMUX splitter cell control</description>
          <addressOffset>0x2100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x77</resetMask>
          <fields>
            <field>
              <name>SWITCH_AA_SL</name>
              <description>T-switch control for Left AMUXBUSA switch:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_AA_SR</name>
              <description>T-switch control for Right AMUXBUSA switch:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_AA_S0</name>
              <description>T-switch control for AMUXBUSA vssa/ground switch:
'0': switch open.
'1': switch closed.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_BB_SL</name>
              <description>T-switch control for Left AMUXBUSB switch.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_BB_SR</name>
              <description>T-switch control for Right AMUXBUSB switch.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_BB_S0</name>
              <description>T-switch control for AMUXBUSB vssa/ground switch.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SRSSHV</name>
      <description>System Resources High Voltage Subsystem</description>
      <baseAddress>0x40030000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>PWR_CONTROL</name>
          <description>Power Mode Control (Lock Protected)</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8F003F</resetMask>
          <fields>
            <field>
              <name>POWER_MODE</name>
              <description>Current power mode of the device.  Note that this field cannot be read in all power modes on actual silicon.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RESET</name>
                  <description>RESET state</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACTIVE</name>
                  <description>ACTIVE state</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLEEP</name>
                  <description>SLEEP state</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DEEP_SLEEP</name>
                  <description>DEEP_SLEEP state</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DEBUG_SESSION</name>
              <description>Indicates whether a debug session is active (CDBGPWRUPREQ signal is 1)</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_SESSION</name>
                  <description>No debug session active</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SESSION_ACTIVE</name>
                  <description>Debug session is active</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LPM_READY</name>
              <description>Indicates whether the low power mode regulator is ready to enter DeepSleep mode.  
0: If DeepSleep mode is requested, device will enter SLEEP mode.  When low power regulators are ready, device will automatically enter the originally requested mode.
1: Normal operation.  DeepSleep works as described.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVER_TEMP_EN</name>
              <description>Enables the die over temperature sensor.  Must be enabled when using the TEMP_HIGH interrupt.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVER_TEMP_THRESH</name>
              <description>Over-temperature threshold.   
0: TEMP_HIGH condition occurs between 120C and 125C.
1: TEMP_HIGH condition occurs between 60C and 75C (used for testing).</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPARE</name>
              <description>Spare AHB readback bits that are hooked to PWR_PWRSYS_TRIM1.SPARE_TRIM[1:0] through spare logic equivalent to bitwise inversion.  Engineering only, should always be set to default.</description>
              <bitRange>[19:18]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EXT_VCCD</name>
              <description>Always write 0 except as noted below. 

PSoC4-S0 and Streetfighter CapSense products may set this bit if Vccd is provided externally (on Vccd pin).  Setting this bit turns off the active regulator and will lead to system reset (BOD) unless both Vddd and Vccd pins are supplied externally.  This register field reset with hard reset (power related, XRES, WDT).</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_KEY_DELAY</name>
          <description>Power System Key&amp;Delay Register (Lock Protected)</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xF8</resetValue>
          <resetMask>0x3FF</resetMask>
          <fields>
            <field>
              <name>WAKEUP_HOLDOFF</name>
              <description>Delay to wait for references to settle on wakeup from DeepSleep.  BOD is ignored and system does not resume until this delay expires. Note that the same delay on POR is hard-coded.  The default assumes the output of the predivider is 48MHz + 3 percent.  Firmware may scale this setting according to the fastest actual clock frequency that can occur when waking from DeepSleep.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TST_MODE</name>
          <description>Test Mode Control Register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xD0000004</resetMask>
          <fields>
            <field>
              <name>SWD_CONNECTED</name>
              <description>N/A</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BLOCK_ALT_XRES</name>
              <description>Relevant only for parts that have the alternate XRES mechanism of overloading a GPIO pin temporarily as alternate XRES during test.  When set, this bit blocks the alternate XRES function, such that the pin can be used for normal I/O or for ddft/adft observation.  This register field resets with hard reset (power related, XRES, WDT)</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TEST_KEY_DFT_EN</name>
              <description>N/A</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TEST_MODE</name>
              <description>N/A</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_CAL_CNT1</name>
          <description>Clock Calibration Counter 1</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80000000</resetValue>
          <resetMask>0x8000FFFF</resetMask>
          <fields>
            <field>
              <name>CAL_COUNTER1</name>
              <description>Down-counter clocked on DFT output #0 (see CLK_DFT_SELECT). This register always reads as zero.  Counting starts internally when this register is written with a nonzero value.  CAL_COUNTER_DONE goes immediately low to indicate that the counter has started and will be asserted when the counters are done.  Do not write this field unless CAL_COUNTER_DONE==1.  Both clocks must be running or the measurement will not complete.  A stalled counter can be recovered by selecting valid clocks, waiting until the measurement completes, and discarding the first result.  CAL_COUNTER1 should always be &gt; 1.  Due to internal clock synchronization CAL_COUNTER1 should be at least 5 times the 1/F_cnt2.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CAL_COUNTER_DONE</name>
              <description>Status bit indicating that the internal counter #1 is finished counting and CLK_CAL_CNT2.COUNTER stopped counting up</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_CAL_CNT2</name>
          <description>Clock Calibration Counter 2</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>CAL_COUNTER2</name>
              <description>Up-counter clocked on DFT output #1 (see CLK_DFT_SELECT). When CLK_CAL_CNT1.CAL_COUNTER_DONE==1, the counter is stopped and can be read by SW.  Do not read this value unless CAL_COUNTER_DONE==1.  The expected final value is related to the ratio of clock frequencies used for the two counters and the value loaded into counter 1: CLK_CAL_CNT2.CAL_COUNTER2=(F_cnt2/F_cnt1)*(CLK_CAL_CNT1.CAL_COUNTER1)</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_SELECT</name>
          <description>Clock Select Register (Lock Protected)</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x8</resetValue>
          <resetMask>0x1FF</resetMask>
          <fields>
            <field>
              <name>HFCLK_SEL</name>
              <description>Selects a source for clk_hf and dsi_in[0].  Note that not all products support all clock sources.  Selecting a clock source that is not supported or enabled will result in undefined behavior.  It takes about 3 cycles of the new selected clock to switch away from the old clock to the new clock.  Do not disable the original clock during this time.</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>IMO - Internal R/C Oscillator</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXTCLK</name>
                  <description>EXTCLK - External Clock Pin</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO</name>
                  <description>ECO - External-Crystal Oscillator or PLL subsystem output</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HPOSC</name>
                  <description>HPOSC - High Precision Oscillator. Only if HPOSC_PRESENT=1</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HFCLK_DIV</name>
              <description>Selects clk_hf predivider value.  It will take 3-4 clock cycles to switch to the new predivder value</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_DIV</name>
                  <description>Transparent mode, feed through selected clock source w/o dividing.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_2</name>
                  <description>Divide selected clock source by 2</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_4</name>
                  <description>Divide selected clock source by 4</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_8</name>
                  <description>Divide selected clock source by 8</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>PUMP_SEL</name>
              <description>Selects clock source for charge pump clock.  This clock is not guaranteed to be glitch free when changing any of its sources or settings.</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>GND</name>
                  <description>No clock, connect to gnd</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>Use main IMO output</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HFCLK</name>
                  <description>Use clk_hf (using selected source after predivider but before prescaler)</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SYSCLK_DIV</name>
              <description>Select clk_sys prescaler value.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_DIV</name>
                  <description>clk_sys= clk_hf/1</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_2</name>
                  <description>clk_sys= clk_hf/2</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_4</name>
                  <description>clk_sys= clk_hf/4</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_8</name>
                  <description>clk_sys= clk_hf/8</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LFCLK_SEL</name>
              <description>Low Frequency Clock Select.  Selecting a clock source that is not enabled will result in undefined behavior.  If a clock source is disabled while selected, then the clock merely stops to all sources that receive it.  In such a scenario, the disabled clock must be re-enabled, prior to switching FROM this clock source.  Writes to this field are ignored unless the WDT is unlocked using WDT_LOCK register.  It takes about 3 cycles of the new selected clock to switch away from the old clock to the new clock.  Do not disable the original clock during this time.   This register field resets with hard reset (power related, XRES, WDT).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ILO</name>
                  <description>ILO - Internal Low Frequency Oscillator</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PILO</name>
                  <description>PILO - Precision Internal Low Frequency Oscillator. Only if PILO_PRESENT=1</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_ILO_CONFIG</name>
          <description>ILO Configuration (Lock Protected)</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80000000</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>Master enable for ILO oscillator.    Clearing this bit will disable the ILO.  Do not disable this clock if the CLK_LF uses it clock the source.  Writes to this field are ignored when LFCLK_SEL is using this clock as the source and WDT is locked using WDT_LOCK register.  This register resets when there is power related reset POR/XRES/BOD/OVD/WDT</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_IMO_CONFIG</name>
          <description>IMO Configuration (Lock Protected)</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80000000</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>ENABLE</name>
              <description>Master enable for IMO oscillator.  Clearing this bit will disable the IMO.  Don't do this if the system is running off it.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_DFT_SELECT</name>
          <description>Clock DFT Mode Selection Register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7F7F</resetMask>
          <fields>
            <field>
              <name>DFT_SEL0</name>
              <description>Select clock for Calibration Counter #1</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NC</name>
                  <description>Disabled - output is 0</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO</name>
                  <description>clk_ilo: ILO output</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>clk_imo: IMO primary output</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO</name>
                  <description>clk_eco: ECO output</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXTCLK</name>
                  <description>clk_ext: external clock input</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HFCLK</name>
                  <description>clk_hf: root of the high-speed clock tree</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LFCLK</name>
                  <description>clk_lf:  root of the low-speed clock tree</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SYSCLK</name>
                  <description>clk_sys:  root of the CPU/AHB clock tree (gated version of clk_hf)</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PUMPCLK</name>
                  <description>clk_pump: clock provided to charge pumps in FLASH and PA</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLPCTRLCLK</name>
                  <description>clk_slpctrl:  clock provided to Sleep Controller</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HPOSC</name>
                  <description>clk_hposc:  HPOSC output.  Applicable only if HPOSC_PRESENT=1</description>
                  <value>10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PILO</name>
                  <description>clk_pilo:  PILO output.  Applicable only if PILO_PRESENT=1</description>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO_EN</name>
                  <description>clk_ilo: enable. Use for startup time measurements.  Use only with DFT_DIV0.NO_DIV</description>
                  <value>12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IMO_EN</name>
                  <description>clk_imo: enable. Use for startup time measurements. Use only with DFT_DIV0.NO_DIV</description>
                  <value>13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HPOSC_EN</name>
                  <description>clk_hposc: enable. If HPOSC_PRESENT=1, Use for startup time measurements. Use only with DFT_DIV0.NO_DIV</description>
                  <value>14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PILO_EN</name>
                  <description>clk_pilo: enable. If PILO_PRESENT=1, Use for startup time measurements. Use only with DFT_DIV0.NO_DIV</description>
                  <value>15</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DFT_DIV0</name>
              <description>Calibration Counter #1 pre-divider</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_DIV</name>
                  <description>Direct Output</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_2</name>
                  <description>Divide by 2</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_4</name>
                  <description>Divide by 4</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_8</name>
                  <description>Divide by 8</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DFT_EDGE0</name>
              <description>Edge sensitivity for pre-divider (only relevant when DIV0&gt;0).</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>POSEDGE</name>
                  <description>Use posedge for divider</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NEGEDGE</name>
                  <description>Use negedge for divider</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DFT_SEL1</name>
              <description>Select clock for Calibration Counter #2</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NC</name>
                  <description>Disabled - output is 0</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO</name>
                  <description>clk_ilo: ILO output</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IMO</name>
                  <description>clk_imo: IMO primary output</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ECO</name>
                  <description>clk_eco: ECO output</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXTCLK</name>
                  <description>clk_ext: external clock input</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HFCLK</name>
                  <description>clk_hf: root of the high-speed clock tree</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LFCLK</name>
                  <description>clk_lf:  root of the low-speed clock tree</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SYSCLK</name>
                  <description>clk_sys:  root of the CPU/AHB clock tree (gated version of clk_hf)</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PUMPCLK</name>
                  <description>clk_pump: clock provided to charge pumps in FLASH and PA</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLPCTRLCLK</name>
                  <description>clk_slpctrl:  clock provided to Sleep Controller</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HPOSC</name>
                  <description>clk_hposc:  HPOSC output.  Applicable only if HPOSC_PRESENT=1</description>
                  <value>10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PILO</name>
                  <description>clk_pilo:  PILO output.  Applicable only if PILO_PRESENT=1</description>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ILO_EN</name>
                  <description>clk_ilo: enable. Use for startup time measurements.  Use only with DFT_DIV0.NO_DIV</description>
                  <value>12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IMO_EN</name>
                  <description>clk_imo: enable. Use for startup time measurements. Use only with DFT_DIV0.NO_DIV</description>
                  <value>13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HPOSC_EN</name>
                  <description>clk_hposc: enable. If HPOSC_PRESENT=1, Use for startup time measurements. Use only with DFT_DIV0.NO_DIV</description>
                  <value>14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PILO_EN</name>
                  <description>clk_pilo: enable. If PILO_PRESENT=1, Use for startup time measurements. Use only with DFT_DIV0.NO_DIV</description>
                  <value>15</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DFT_DIV1</name>
              <description>Calibration Counter #2 pre-divider</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NO_DIV</name>
                  <description>Direct Output</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_2</name>
                  <description>Divide by 2</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_4</name>
                  <description>Divide by 4</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIV_BY_8</name>
                  <description>Divide by 8</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DFT_EDGE1</name>
              <description>Edge sensitivity for pre-divider (only relevant when DIV0&gt;0).</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>POSEDGE</name>
                  <description>Use posedge for divider</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NEGEDGE</name>
                  <description>Use negedge for divider</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_MASKED</name>
          <description>SRSS Interrupt Masked Register</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1E</resetMask>
          <fields>
            <field>
              <name>TEMP_HIGH</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>LIFETIME_WAKEUP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CLK_CAL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CRWDT</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_INTR</name>
          <description>SRSS Interrupt Register</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1E</resetMask>
          <fields>
            <field>
              <name>TEMP_HIGH</name>
              <description>Regulator over-temp interrupt.  This interrupt can occur when a short circuit exists on the vccd pin or when extreme loads are applied on IO-cells causing the die to overheat.  Firmware is encourage to shutdown all IO cells and then go to DeepSleep mode when this interrupt occurs if protection against such conditions is desired.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LIFETIME_WAKEUP</name>
              <description>Wakeup Interrupt from LIFETIME Counter. This bit is set when LIFETIME_COUNTER ==LIFETIME_WAKEUP. This is a DeepSleep Interrupt.  The interrupt source will reset only with hard reset (power related, XRES, WDT).</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CAL</name>
              <description>Clock calibration counter is done.  This field is reset during DeepSleep mode.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CRWDT</name>
              <description>Interrupt from CRWDT. This bit is set by the CRWDT when enabled by CRWDT_CONFIG.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_INTR_SET</name>
          <description>SRSS Interrupt Set Register</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1E</resetMask>
          <fields>
            <field>
              <name>TEMP_HIGH</name>
              <description>Writing 1 to this bit internally sets the overtemp interrupt.  This can be observed by reading SRSS_INTR.TEMP_HIGH.  This bit always reads back as zero.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LIFETIME_WAKEUP</name>
              <description>Writing 1 to this bit internally sets the LIFETIME_WAKEUP interrupt.  Reads back same as SRSS_INTR.LIFETIME_WAKEUP.  The interrupt source will reset only with hard reset (power related, XRES, WDT).</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CAL</name>
              <description>Set interrupt for clock calibration counter done.  This field is reset during DeepSleep mode.  Reads back same as SRSS_INTR.CLK_CAL.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CRWDT</name>
              <description>Set interrupt for Challenge/Response Interrupt.  Reads back same as SRSS_INTR.CRWDT.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SRSS_INTR_MASK</name>
          <description>SRSS Interrupt Mask Register</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1E</resetMask>
          <fields>
            <field>
              <name>TEMP_HIGH</name>
              <description>Masks REG_OVERTEMP interrupt</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LIFETIME_WAKEUP</name>
              <description>Mask for lifetime counter</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLK_CAL</name>
              <description>Mask for clock calibration done</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CRWDT</name>
              <description>Mask for CRWDT interrupt</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RES_CAUSE</name>
          <description>Reset Cause Observation Register</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40000000</resetValue>
          <resetMask>0x415B021B</resetMask>
          <fields>
            <field>
              <name>RESET_WDT</name>
              <description>A WatchDog Timer reset has occurred since last power cycle.
This is a high-voltage cause detection, this bit blocks recording of other high-voltage cause bits, except RESET_PORVDDD and XRES.  Hardware clears this bit during POR.  This bit is not blocked by other HV cause bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_ACT_FAULT</name>
              <description>Reset caused by the Fault Infrastructure.   This is a low-voltage cause bit that hardware clears when the low-voltage supply is initialized (see comments above).</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_PROT_FAULT</name>
              <description>A protection violation occurred that requires a RESET.  This includes, but is not limited to, hitting a debug breakpoint while in Privileged Mode.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_SOFT</name>
              <description>Cortex-M0 requested a system reset through it's SYSRESETREQ.  This can be done via a debugger probe or in firmware.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_CRWDT</name>
              <description>Challenge/Response Watchdog reset.  This is a low-voltage cause bit that hardware clears when the low-voltage supply is initialized (see comments above).</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_XRES</name>
              <description>External XRES pin was asserted.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD.  Hardware clears this bit during POR.  This bit is not blocked by other HV cause bits.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_BODVDDD</name>
              <description>External VDDD supply crossed brown-out limit.  Note that this cause will only be observable as long as the VDDD supply does not go below the POR (power on reset) detection limit.  Below this limit it is not possible to reliably retain information in the device.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD and RESET_XRES.  Hardware clears this bit during POR.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_BODVCCD</name>
              <description>Internal VCCD core supply crossed the brown-out limit.  Note that this detector will detect gross issues with the internal core supply, but may not catch all brown-out conditions.  Functional and timing supervision (CSV, WDT) is provided to create fully failsafe internal crash detection.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD and RESET_XRES.  Hardware clears this bit during POR.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_OVDVDDD</name>
              <description>Overvoltage detection on the external VDDD supply.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD and RESET_XRES.  Hardware clears this bit during POR.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_OVDVCCD</name>
              <description>Overvoltage detection on the internal core VCCD supply.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD and RESET_XRES.  Hardware clears this bit during POR.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_BODHVSS</name>
              <description>External VDDD supply crossed brown-out limit.  Note that this cause will only be observable as long as the VDDD supply does not go below the POR (power on reset) detection limit.  Below this limit it is not possible to reliably retain information in the device.  This is a high-voltage cause bit that blocks recording of other high-voltage cause bits, except RESET_PORVDDD and RESET_XRES.  Hardware clears this bit during POR.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESET_PORVDDD</name>
              <description>Indicator that a POR occurred.  This is a high-voltage cause bit, and hardware clears the other bits when this one is set.  It does not block further recording of other high-voltage causes.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>REG_PROT</name>
          <description>Register Protection</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xF08169E7</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MAGIC</name>
              <description>Setting this register to the value 0xf08169e7 unlocks access to Lock Protected Registers. These registers can not be written to unless this value has been written into this register. Writing a value OTHER than the magic key will disable access to the registers. The register POR value is set to 'unlock' the register access. 
The registers locked are PWR_CONTROL, PWR_KEY_DELAY, CLK_SELECT, CLK_ILO_CONFIG, CLK_IMO_CONFIG, CRWDT_CTL, CRWDT_EARLY, PWR_SSV_CTL, CRWDT_WARN, CRWDT_LATE, LIFETIME_CTL,HPOSC_CTL(if HPOSC_PRESENT=1), PILO_CTL(if PILO_PRESENT=1), and all trim registers</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRWDT_CTL</name>
          <description>Challenge Response WatchDog Control (Lock Protected)</description>
          <addressOffset>0x90</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC0000000</resetMask>
          <fields>
            <field>
              <name>STATUS_ENABLED</name>
              <description>Indicates actual state of CRWDT enable.  May lag ENABLED by up to one clk_lf cycles.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>When set to '1' enables Challenge/Response WatchDog Timer to Count.  Will require 2 clk_lf cycles to take effect.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRWDT_CHALLENGE</name>
          <description>Challenge Response WatchDog Challenge Value</description>
          <addressOffset>0x94</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0xFF</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>CHALLENGE</name>
              <description>Challenge/Response WatchDog Challenge value. Implements the LFSR CCRC8-AutoSar using the polynomial x^8+x^5+x^3+x^2+x+1.  The next value in the LFSR sequence is used to compare against the value subsequently written to the CRWDT_RESPONSE register.  Incremented by write to CRWDT_RESPONSE to LFSR value next in the LFSR sequence after the value written to CRWDT_RESPONSE.  Also incremented each time this register before a response is written to CRWDT_RESPONSE.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRWDT_RESPONSE</name>
          <description>Challenge Response WatchDog Response Value</description>
          <addressOffset>0x98</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFF</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>RESPONSE</name>
              <description>Challenge/Response WatchDog Response value.  Value is compared against the expected next value in the LFSR sequence following the value obtained from CRWDT_CHALLENGE.  If the values match, the CRWDT_UPCNT resets. If the values miscompare,  the action selected by CRWDT_CONFIG.CHALLENGE_FAIL_ACTION occurs.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRWDT_UPCNT</name>
          <description>Challenge Response  WatchDog Up Counter</description>
          <addressOffset>0x9C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFF</resetMask>
          <fields>
            <field>
              <name>UPCNT</name>
              <description>Challenge/Response WatchDog Up Counter.  The counter upcounts upon every clk_lf occurrence when enabled.  If a match occurs between CRWDT_CHALLENGE and CRWDT_RESPONSE, the counter resets.    If there is a mismatch, the action is taken selected by CRWDT_CONFIG.CHALLENGE_FAIL_ACTION.  The counter will also reset when CRWDT_UPCNT=CRWDT_LATE.
CRWDT_CTL.ENABLED=0 - Counter reset
CRWDT_CTL.ENABLED=1 - Counter Increments</description>
              <bitRange>[23:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRWDT_EARLY</name>
          <description>Challenge Response  WatchDog Early Limit (Lock Protected)</description>
          <addressOffset>0xA0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFF</resetMask>
          <fields>
            <field>
              <name>EARLY</name>
              <description>Challenge/Response Early Value will cause the action selected by CRWDT_CONFIG.EARLY_ACTION if CRWDT_UPCNT &lt; CRWDT_EARLY and there is a CRWDT_CHALLENGE/CRWDT_RESPONSE match.
Writes to this register are ignored when CRWDT_CTL.ENABLED&lt;&gt;0.</description>
              <bitRange>[23:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRWDT_WARN</name>
          <description>Challenge Response  WatchDog Warning Limit  (Lock Protected)</description>
          <addressOffset>0xA4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFF</resetMask>
          <fields>
            <field>
              <name>WARNING</name>
              <description>Challenge/Response Warning Value will cause the action selected by CRWDT_CONFIGWARN_ACTION  if CRWDT_UPCNT&gt;CRWDT_WARN and there is a CRWDT_CHALLENGE/CRWDT_RESPONSE match.  
Writes to this register are ignored when CRWDT_CTL.ENABLED&lt;&gt;0.</description>
              <bitRange>[23:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRWDT_LATE</name>
          <description>Challenge Response  WatchDog Late Limit  (Lock Protected)</description>
          <addressOffset>0xA8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFF</resetMask>
          <fields>
            <field>
              <name>LATE</name>
              <description>Challenge/Response Late Value will cause action selected by CRWDT_CONFIG.LATE_ACTION if CRWDT_UPCNT = CRWDT_LATE.   
Writes to this register are ignored when CRWDT_CTL.ENABLED&lt;&gt;0.</description>
              <bitRange>[23:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CRWDT_CONFIG</name>
          <description>Challenge Response WatchDog Configuration</description>
          <addressOffset>0xAC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x810</resetValue>
          <resetMask>0x80000911</resetMask>
          <fields>
            <field>
              <name>EARLY_ACTION</name>
              <description>Action taken if this watchdog when the proper response is written to CRWDT_RESPONSE before CRWDT_UPCNT  reaches CRWDT_EARLY.  EARLY_ACTION is ignored (i.e. treated as NOTHING) when a debugger is connected.
For CRWDT_EARLY  &gt; CRWDT_UPCNT: The action is triggered on same edge as when it meets this condition.
For CRWDT_EARLY &lt;= CRWDT_UPCNT: No action is triggered. 

Writes to this register are ignored when CRWDT_CTL.ENABLED&lt;&gt;0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NOTHING</name>
                  <description>Do nothing</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FAULT_AND_INT</name>
                  <description>Trigger a Fault and interrupt</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LATE_ACTION</name>
              <description>Action taken if this watchdog is not serviced before CRWDT_LATE s reached.  The counter resets CRWDT_UPCNT when CRWDT_LATE is reached, regardless of CRWDT_CONFIG.LATE_ACTION setting.   LATE_ACTION  is ignored (i.e. treated as NOTHING) when a debugger is connected.
For CRWDT_LATE ==  CRWDT_UPCNT: The action is triggered on same edge as when it meets this condition.
For CRWDT_LATE &gt; CRWDT_UPCNT: No action is taken 

Writes to this register are ignored when CRWDT_CTL.ENABLED&lt;&gt;0.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NOTHING</name>
                  <description>Do nothing</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FAULT_RESET</name>
                  <description>Trigger a fault.  Further, trigger a system-wide reset if the CRWDT is not disabled within 6 clk_lf cycles.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>WARN_ACTION</name>
              <description>Action taken if this watchdog when the proper response is written to CRWDT_RESPONSE and  CRWDT_UPCNT  reaches CRWDT_WARN and CRWDT_UPCNT&lt;CRWDT_LATE. WARN_ACTION is ignored (i.e. treated as NOTHING) when a debugger is connected.
For CRWDT_WARN == CRWDT_UPCNT &amp;&amp; CRWDT_LATE &gt; CRWDT_UPCNT: The action is triggered on same edge as when it meets this condition.
For CRWDT_WARN &lt;CRWDT_UPCNT: No action is triggered.

Writes to this register are ignored when CRWDT_CTL.ENABLED&lt;&gt;0.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NOTHING</name>
                  <description>Do nothing</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FAULT_AND_INT</name>
                  <description>Trigger a Fault and interrupt</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CHALLENGE_FAIL_ACTION</name>
              <description>Action taken when a failed response occurs, i.e. the expected LFSR value is different than the  expected value.

Writes to this register are ignored when CRWDT_CTL.ENABLED&lt;&gt;0.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NOTHING</name>
                  <description>Do nothing</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RESET</name>
                  <description>Trigger a reset</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DEBUG_RUN</name>
              <description>Pauses/runs this counter while a debugger is connected.  Other behaviors are unchanged during debugging, including service, configuration updates and enable/disable.  Note it may take up to two clk_lf cycles for the counter to pause and another two cycles to unpause, due to internal synchronization.  If the debugger is connected for at least two clk_lf cycles, the EARLY_ACTION is ignored until after the first service after the debugger is disconnected.  This prevents an unintentional trigger of the EARLY_ACTION before the firmware realigns the servicing period.  After the first service, EARLY_ACTION behaves as configured.  If the debugger is disconnected before two clk_lf cycles, the EARLY_ACTION may or may not be ignored.
0: When debugger connected, counter pauses incrementing.
1: When debugger connected, counter increments normally, but reset generation is blocked. 

Writes to this register are ignored when CRWDT_CTL.ENABLED&lt;&gt;0.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LIFETIME_CTL</name>
          <description>Liftetime Counter Control (Lock Protected)</description>
          <addressOffset>0xB0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC0000007</resetMask>
          <fields>
            <field>
              <name>PRESEL</name>
              <description>Select Divide ratio for Preselector. Legal values are 0-4. Values 5, 6, and 7 yield the same result as  PERSEL_DIV32.  Do not change this setting when lifetime counter is enabled (LIFETIME_CTL.ENABLED=1).  Due to internal synchronization, it takes about 1 LFCLK cycles to update the counters after a write to this register.  This register bit only resets for XRES, POR, or a detected BOD.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PRESEL_DIV2</name>
                  <description>Divide CLK_LF by 2</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PRESEL_DIV4</name>
                  <description>Divide CLK_LF by 4</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PRESEL_DIV8</name>
                  <description>Divide CLK_LF by 8</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PRESEL_DIV16</name>
                  <description>Divide CLK_LF by 16</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PRESEL_DIV32</name>
                  <description>Divide CLK_LF by 32</description>
                  <value>4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>STATUS_ENABLED</name>
              <description>Indicates actual state of lifetime counter enable.  May lag ENABLED by up to one clk_lf cycles.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>When set to '1' enables LIFETIME_COUNTER to increment.   Due to internal synchronization, may take up to one clk_lf cycles to take effect.  The synchronization can be checked by waiting until ENABLED==STATUS_ENABLED whenever ENABLED is changed.  When ENABLE changes from 1-&gt;0, the counter can be loaded with new COUNT value.  Refer to LIFETIME_COUNTER.COUNT for details.  User can enter DeepSleep without waiting for synchronization to complete (ENABLED==STATUS_ENABLED).  This register bit only resets for XRES, POR, or a detected BOD.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LIFETIME_WAKEUP</name>
          <description>Lifetime Wakeup Value</description>
          <addressOffset>0xB4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFFFFFFFF</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WAKEUP</name>
              <description>Compare the WAKEUP value against LIFETIME_COUNTER. If they are equal interrupt_wakeup to set.   Due to internal synchronization, it may take up to 1 LFCLK cycles to update the counters after a write to this register.  This register bit only resets for XRES, POR, or a detected BOD.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LIFETIME_COUNTER</name>
          <description>Lifetime Counter Current Value</description>
          <addressOffset>0xB8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNT</name>
              <description>Lifetime Counter which clocks on the output of the CLK_LF PreScalar output controlled by LIFETIME_CTL.PRESEL. The counter doesn't increment unless LIFETIME_CTL.STATUS_ENABLED =1. FW is responsible for initializing this value after reset and maintaining the running value.  SW writes will be ignored when LIFETIME_CTL.ENABLED=1.  The counter needs to be disabled one LFCLK cycle (or LIFETIME_CTL.STATUS_ENABLED=0) for the internal synchronization of this field to take place.  This register bit only resets for XRES, POR, or a detected BOD.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_SSV_CTL</name>
          <description>Supply Supervisory Control Register  (Lock Protected)</description>
          <addressOffset>0xE0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x808</resetValue>
          <resetMask>0x88080808</resetMask>
          <fields>
            <field>
              <name>BODVDDD_ENABLE</name>
              <description>Enable for BOD on vddd.  This cannot be disabled during normal operation.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BODVCCD_ENABLE</name>
              <description>Enable for BOD on vccd.  This cannot be disabled during normal operation.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVDVDDD_ENABLE</name>
              <description>Enable for OVD on vddd.  FW should enable this after the OVD trims are set during boot-up and keep it enabled.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVDVCCD_ENABLE</name>
              <description>Enable for OVD on vccd.  FW should enable this after the OVD trims are set during boot-up and keep it enabled.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BODHVSS_ENABLE</name>
              <description>Enable for BOD on vddd from HVSS.  This gives BOD robustness during DeepSleep.  FW should enable during boot-up and keep it enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_SSV_STATUS</name>
          <description>Supply Supervision Status Register</description>
          <addressOffset>0xE4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x1005</resetValue>
          <resetMask>0x1505</resetMask>
          <fields>
            <field>
              <name>BODVDDD_OK</name>
              <description>BOD indicates vddd is ok.  This will always read 1, because a detected brownout will reset the chip.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BODVCCD_OK</name>
              <description>BOD indicates vccd is ok.  This will always read 1, because a detected brownout will reset the chip.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVDVDDD_OK</name>
              <description>OVD indicates vddd is ok.    After OVDVDDD is enabled it will always read 1, because a detected over-voltage condition will reset the chip.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVDVCCD_OK</name>
              <description>OVD indicates vccd is ok.    After OVDVCCD is enabled it will always read 1, because a detected over-over-voltage condition will reset the chip.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BODHVSS_OK</name>
              <description>BODHVSS indicates vddd is ok.   This will always read 1, because a detected brownout will reset the chip.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <cluster>
          <name>WDT</name>
          <description>Watchdog Timer</description>
          <headerStructName>WDT</headerStructName>
          <addressOffset>0x00000100</addressOffset>
          <register>
            <name>CTL</name>
            <description>WDT Control Register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x80000001</resetValue>
            <resetMask>0x80000001</resetMask>
            <fields>
              <field>
                <name>ENABLED</name>
                <description>Indicates actual state of watchdog.  May lag ENABLE by up to three clk_lf cycles.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>ENABLE</name>
                <description>Enable watchdog.  May take up to three clk_lf cycles to take effect.  When ENABLE changes from 1-&gt;0, the counter is cleared.  Do not enter DeepSleep if ENABLE&lt;&gt;ENABLED.  This can be done by waiting until ENABLE==ENABLED whenever ENABLE is changed.
0: Counter is disabled (not clocked).
1: Counter is enabled (counting up)</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LOWER_LIMIT</name>
            <description>WDT Lower Limit Register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>LOWER_LIMIT</name>
                <description>Lower limit for watchdog.  See LOWER_ACTION.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>UPPER_LIMIT</name>
            <description>WDT Upper Limit Register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x8000</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>UPPER_LIMIT</name>
                <description>Upper limit for watchdog.  See UPPER_ACTION.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>WARN_LIMIT</name>
            <description>WDT Warn Limit Register</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>WARN_LIMIT</name>
                <description>Warn limit for watchdog.  See WARN_ACTION.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CONFIG</name>
            <description>WDT Configuration Register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x10</resetValue>
            <resetMask>0xB0001111</resetMask>
            <fields>
              <field>
                <name>LOWER_ACTION</name>
                <description>Action taken if this watchdog is serviced before LOWER_LIMIT is reached.  LOWER_ACTION is ignored (i.e. treated as NOTHING) when a debugger is connected and/or when the chip is in DeepSleep modes.
For LOWER_LIMIT &gt;= 1: The action is triggered on same edge when it meets this condition.
For LOWER_LIMIT == 0: No action is triggered.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>NOTHING</name>
                    <description>Do nothing</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RESET</name>
                    <description>Trigger a reset.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UPPER_ACTION</name>
                <description>Action taken if this watchdog is not serviced before UPPER_LIMIT is reached.  The counter stops counting when UPPER_LIMIT is reached, regardless of UPPER_ACTION setting.   UPPER_ACTION is ignored (i.e. treated as NOTHING) when a debugger is connected.
For UPPER_LIMIT &gt;= 2: The action is triggered on same edge when it meets this condition.
For UPPER_LIMIT &lt; 2: The action may take up to one extra clk_lf cycle to trigger.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>NOTHING</name>
                    <description>Do nothing</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RESET</name>
                    <description>Trigger a reset.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>WARN_ACTION</name>
                <description>Action taken when the count value reaches WARN_LIMIT.  The minimum setting to achieve a periodic interrupt is WARN_LIMIT==1.  A setting of zero will trigger once but not periodically.
For WARN_LIMIT &gt;= 2: The action is triggered on same edge when it meets this condition.
For WARN_LIMIT &lt; 2  : The action may take up to one extra clk_lf cycle to trigger.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>NOTHING</name>
                    <description>Do nothing</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INT</name>
                    <description>Trigger an interrupt.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AUTO_SERVICE</name>
                <description>Automatically service when the count value reaches WARN_LIMIT.  This allows creation of a periodic interrupt if this counter is not needed as a watchdog.  This field is ignored when LOWER_ACTION&lt;&gt;NOTHING or when UPPER_ACTION&lt;&gt;NOTHING.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DEBUG_TRIGGER_EN</name>
                <description>Enables the trigger input for WDT to pause the counter during debug mode.  To pause at a breakpoint while debugging, configure the trigger matrix to connect the related CPU halted signal to the trigger input for this WDT, and then set this bit.  It takes up to two clk_lf cycles for the trigger signal to be processed.  Triggers that are less than two clk_lf cycles may be missed.  Synchronization error can accumulate each time it is halted.
0: Pauses the counter whenever a debug probe is connected.
1: Pauses the counter whenever a debug probe is connected and the trigger input is high.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DPSLP_PAUSE</name>
                <description>Pauses/runs this counter when the system is in DeepSleep.  Note it may take up to two clk_lf cycles for the counter to pause, due to internal synchronization.  During DeepSleep wakeup, the pause request is removed when clk_hf starts clocking, and then it may take up to two clk_lf cycles for the counter to start.  After wakeup, the LOWER_ACTION is ignored until after the first service.  This prevents an unintentional trigger of the LOWER_ACTION before the firmware realigns the servicing period.  After the first service, LOWER_ACTION behaves as configured.
0: Counter behaves normally during DeepSleep.
1: Counter pauses during DeepSleep.</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DEBUG_RUN</name>
                <description>Pauses/runs this counter while a debugger is connected.  Other behaviors are unchanged during debugging, including service, configuration updates and enable/disable.  Note it may take up to two clk_lf cycles for the counter to pause and another two cycles to unpause, due to internal synchronization.  If the debugger is connected for at least two clk_lf cycles, the LOWER_ACTION is ignored until after the first service after the debugger is disconnected.  This prevents an unintentional trigger of the LOWER_ACTION before the firmware realigns the servicing period.  After the first service, LOWER_ACTION behaves as configured.  If the debugger is disconnected before two clk_lf cycles, the LOWER_ACTION may or may not be ignored.
0: When debugger connected, counter pauses incrementing as configured in DEBUG_TRIGGER_EN.
1: When debugger connected, counter increments normally, but reset generation is blocked.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CNT</name>
            <description>WDT Count Register</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>CNT</name>
                <description>Current value of subcounter for this WDT.  This field may lag the actual count value by up to one clk_lf cycle, due to internal synchronization.  When this subcounter is disabled and unlocked, the count value can be written for verification and debugging purposes.  Software writes are always ignored when the subcounter is enabled.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>LOCK</name>
            <description>WDT Lock register</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x3</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>WDT_LOCK</name>
                <description>Prohibits writing control and configuration registers related to this WDT when not equal 0 (as specified in the other register descriptions).  Requires at least two different writes to unlock.
Note that this field is 2 bits to force multiple writes only.  This register also locks the clk_lf settings.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>NO_CHG</name>
                    <description>No effect</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLR0</name>
                    <description>Clears bit 0</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLR1</name>
                    <description>Clears bit 1</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>SET01</name>
                    <description>Sets both bits 0 and 1</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>SERVICE</name>
            <description>WDT Service register</description>
            <addressOffset>0x44</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>SERVICE</name>
                <description>Services the watchdog.  This resets the count value to zero.  This may take up to three clk_lf cycle to take effect.  Hardware clears this bit, after necessary synchronization.  To ensure a pending SERVICE write is reflected, firmware should wait until this bit reads low before attempting to write SERVICE=1.  If WDT is disabled, SERVICE will not trigger a LOWER_ACTION and will not clear a preloaded count value.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>WDT Interrupt Register</description>
            <addressOffset>0x50</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>WDT</name>
                <description>WDT Interrupt Request.  This bit is set as configured by WDT action and limits.  Due to internal synchronization, it takes up to 8 SYSCLK cycles to update after a W1C or reading this register and during this time AHB bus is stalled.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>WDT Interrupt Set Register</description>
            <addressOffset>0x54</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>WDT</name>
                <description>Set interrupt.
Due to internal synchronization, it takes up to 8 SYSCLK cycles to update after a W1S or reading from this register and during this time AHB bus is stalled.  Reads back same as WDT_B.INTR.WDT</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>WDT Interrupt Mask Register</description>
            <addressOffset>0x58</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>WDT</name>
                <description>Mask for watchdog timer.  Clearing this bit will not forward the interrupt to the CPU.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>WDT Interrupt Masked Register</description>
            <addressOffset>0x5C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>WDT</name>
                <description>Logical and of corresponding request and mask bits.
Due to internal synchronization, it takes up to 8 SYSCLK cycles to read from this register.  During this time AHB bus is stalled.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>HPOSC_CTL</name>
          <description>High Precision Oscillator Control  (Lock Protected)</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x80000013</resetMask>
          <fields>
            <field>
              <name>LEAKC_DIS</name>
              <description>N/A</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTAT_SEL</name>
              <description>CTAT generator selection, only valid when CTAT_SW = 1.
0 - Low noise type CTAT generator
1 - Fast start-up type CTAT generator</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTAT_SWB</name>
              <description>Selection control for internal CTAT generator. 
0 - Auto Select (Fast start followed by low noise generator)
1 - Generator selected by CTAT_SEL</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>IMO_EN</name>
              <description>HPOSC enable.  Setting this bit will enable the HPOSC and clearing this bit will disable the HPOSC.  Don't disable this clock if the system is using this clock as the source.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PILO_CTL</name>
          <description>Precision Low Power Oscillator Control  (Lock Protected)</description>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xC001</resetValue>
          <resetMask>0x8000FF13</resetMask>
          <fields>
            <field>
              <name>LEAKC_DIS</name>
              <description>N/A</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTAT_SEL</name>
              <description>CTAT generator selection, only valid when CTAT_SW = 1.
0 - Low noise type CTAT generator
1 - Fast start-up type CTAT generator</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTAT_SWB</name>
              <description>Selection control for internal CTAT generator. 
0 - Auto Select (Fast start followed by low noise generator)
1 - Generator selected by CTAT_SEL</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TR_CAP</name>
              <description>PILO user temperature fine trim.  This register field resets with hard reset (power related, XRES, WDT)..</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ILO_EN</name>
              <description>PILO enable.  Setting this bit will enable the PILO and clearing this bit will disable it.  Do not disable this clock prior to changing  CLK_LF to use the PILO as a source.  CLK_LF must be configured to use PILO as a source while the PILO clock is enabled prior to making such a change.   Writes to this field are ignored when LFCLK_SEL is using this clock as the source and WDT is locked using WDT_LOCK register.  Consequently, if CLK_LF is sourced by the PILO and the PILO is to be disabled, clear WDT_LOCK before-hand. This register field resets with hard reset (power related, XRES, WDT).</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_BG_TRIM1</name>
          <description>Bandgap Trim Register  (Lock Protected)</description>
          <addressOffset>0xFF00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xD</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>REF_VTRIM</name>
              <description>Trims the bandgap reference voltage output.  Used to trim the VBG to the voltage where its temperature curvature is minimal.  Bit [5] is unused within the bandgap block.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_BG_TRIM2</name>
          <description>Bandgap Trim Register  (Lock Protected)</description>
          <addressOffset>0xFF04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x23</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>REF_ITRIM</name>
              <description>Trims the bandgap reference current output.  Used to trim the IBG to the voltage where its temperature curvature is minimal.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_IMO_SELECT</name>
          <description>IMO Frequency Select Register  (Lock Protected)</description>
          <addressOffset>0xFF08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>FREQ</name>
              <description>Select operating frequency</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>24_MHZ</name>
                  <description>IMO runs at 24 MHz</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>28_MHZ</name>
                  <description>IMO runs at 28 MHz</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>32_MHZ</name>
                  <description>IMO runs at 32 MHz</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>36_MHZ</name>
                  <description>IMO runs at 36 MHz</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>40_MHZ</name>
                  <description>IMO runs at 40 MHz</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>44_MHZ</name>
                  <description>IMO runs at 44 MHz</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>48_MHZ</name>
                  <description>IMO runs at 48 MHz</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_IMO_TRIM1</name>
          <description>IMO Trim Register  (Lock Protected)</description>
          <addressOffset>0xFF0C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x6C</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>OFFSET</name>
              <description>Frequency trim bits.  These bits are determined at manufacturing time for each FREQ setting (IMO_TRIM2) and stored in SFLASH.  This field is hardware updated during USB osclock mode. This field is mapped to the most significant bits of the IMO trim imo_clk_trim[10:3].  The step size of 1 LSB on this field is nominally 160 kHz.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_IMO_TRIM2</name>
          <description>IMO Trim Register  (Lock Protected)</description>
          <addressOffset>0xFF10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xA0</resetValue>
          <resetMask>0xF7</resetMask>
          <fields>
            <field>
              <name>FSOFFSET</name>
              <description>Frequency trim bits.  These bits are not trimmed during manufacturing and kept at 0 under normal operation.  This field is hardware updated during USB osclock mode. This field is mapped to the least significant bits of the IMO trim imo_clk_trim[2:0].  The step size of 1 LSB on this field is nominally 20 kHz.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TCTRIM</name>
              <description>IMO temperature compensation trim.  These bits are determined at manufacturing time to adjust for temperature dependence. This bits are dependent on frequency and need to be changed using the Cypress provided frequency change algorithm.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CLK_IMO_TRIM3</name>
          <description>IMO Trim Register  (Lock Protected)</description>
          <addressOffset>0xFF14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xF</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>STEPSIZE</name>
              <description>IMO trim stepsize bits.  These bits are determined at manufacturing time to adjust for process variation.  They are used to tune the stepsize of the FSOFFSET and OFFSET trims.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PWR_PWRSYS_TRIM1</name>
          <description>Power System Trim Register  (Lock Protected)</description>
          <addressOffset>0xFF18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x10</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>DPSLP_REF_TRIM</name>
              <description>Trims the DeepSleep reference that is used by the DeepSleep regulator and DeepSleep power comparator.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPARE_TRIM</name>
              <description>Active-Reference temperature compensation trim (repurposed from spare bits).
Bits [7:6] - trim the Active-Reference IREF temperature coefficient (TC).
  00: TC = 0 (unchanged)
  01: TC = +80ppm/C 
  10: TC = -80ppm/C
  11: TC = -150ppm/C

Bits [5:4] - trim the Active-Reference VREF temperature coefficient (TC).
  00: TC = 0 (unchanged)
  01: TC = -50ppm/C 
  10: TC = -80ppm/C
  11: TC = +150ppm/C</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM_BODVCCD</name>
          <description>Brown Out Detect Trim (VCCD)  (Lock Protected)</description>
          <addressOffset>0xFF1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x8</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>BOD_TRIPSEL_VCCD</name>
              <description>BOD VCCD trim (production)</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BOD_RANGE_SELECT_VCCD</name>
              <description>Range select between 1.6V Vs 1.69V nominal.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM_OVDVCCD</name>
          <description>Over Voltage Detect Trim (VCCD)  (Lock Protected)</description>
          <addressOffset>0xFF20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x7</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>OVD_TRIPSEL_VCCD</name>
              <description>OVD VCCD trim (options)</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM_HPOSC0_CTL</name>
          <description>High Precision Oscillator Trim Control 0  (Lock Protected)</description>
          <addressOffset>0xFF24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xF</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>CTATEF</name>
              <description>HPOSC frequency CTAT extra-fine trim</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PTATEF</name>
              <description>Fine trim for HPOSC PTAT current</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTATEC</name>
              <description>Coarse trim for HPOSC CTAT current</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PTATEC</name>
              <description>Coarse trim for HPOSC PTAT current</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM_HPOSC1_CTL</name>
          <description>High Precision Oscillator Trim Control 1  (Lock Protected)</description>
          <addressOffset>0xFF28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xD</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>TCF</name>
              <description>HPOSC temp-co fine trim</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM_HPOSC2_CTL</name>
          <description>High Precision Oscillator Trim Control 2  (Lock Protected)</description>
          <addressOffset>0xFF2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xA4</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>PTAT</name>
              <description>HPOSC PTAT trim</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM_HPOSC3_CTL</name>
          <description>High Precision Oscillator Trim Control 3  (Lock Protected)</description>
          <addressOffset>0xFF30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xB1</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>CTAT</name>
              <description>HPOSC CTAT trim</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM_HPOSC4_CTL</name>
          <description>High Precision Oscillator Trim Control 4  (Lock Protected)</description>
          <addressOffset>0xFF34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>TOC</name>
              <description>HPOSC temp-co coarse trim</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HPOSC_LEAK</name>
              <description>HPOSC leakage cancellation trim</description>
              <bitRange>[7:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM_PILO0_CTL</name>
          <description>Low Frequency Oscillator Trim Control 0   (Lock Protected)</description>
          <addressOffset>0xFF38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>CTATEF</name>
              <description>PILO frequency CTAT extra-fine trim</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PTATEF</name>
              <description>PILO frequency PTATextra-fine trim</description>
              <bitRange>[3:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTATEC</name>
              <description>PILO temperature CTAT extra-coarse trim</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PTATEC</name>
              <description>PILO temperature PTATextra-coarse trim</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM_PILO1_CTL</name>
          <description>Low Frequency Oscillator Trim Control 1   (Lock Protected)</description>
          <addressOffset>0xFF3C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>TCF</name>
              <description>PILO temp-co fine trim (MSB, bit 4, is not used)</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM_PILO2_CTL</name>
          <description>Low Frequency Oscillator Trim Control 2  (Lock Protected)</description>
          <addressOffset>0xFF40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>PTAT</name>
              <description>PILO frequency PTAT coarse trim</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM_PILO3_CTL</name>
          <description>Low Frequency Oscillator Trim Control 3  (Lock Protected)</description>
          <addressOffset>0xFF44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>CTAT</name>
              <description>PILO frequency CTAT coarse trim</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM_PILO4_CTL</name>
          <description>Low Frequency Oscillator Trim Control 4  (Lock Protected)</description>
          <addressOffset>0xFF48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>TCC</name>
              <description>PILO temperature coarse trim</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM_PILO5_CTL</name>
          <description>Low Frequency Oscillator Trim Control 5  (Lock Protected)</description>
          <addressOffset>0xFF4C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>PILO_TR_LEAK</name>
              <description>PILO leakage cancellation trim</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM_BODVDDD</name>
          <description>Brown Out Detect Trim (VDDD)  (Lock Protected)</description>
          <addressOffset>0xFF50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x8</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>BOD_TRIPSEL_VDDD</name>
              <description>BOD VDDD trim (options)</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM_OVDVDDD</name>
          <description>Over Voltage Detect Trim  (VDDD) (Lock Protected)</description>
          <addressOffset>0xFF54</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x7</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>OVD_TRIPSEL_VDDD</name>
              <description>OVD VDDD trim (options)</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVD_RANGE_SELECT_VDDD</name>
              <description>Range select between 3.8V Vs 5.77V nominal.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>GPIO</name>
      <description>GPIO port control/configuration</description>
      <baseAddress>0x40040000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>16384</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>8</dim>
          <dimIncrement>256</dimIncrement>
          <name>PRT[%s]</name>
          <description>GPIO port registers</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>DR</name>
            <description>Port output data register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DATA0</name>
                <description>IO pad 0 output data.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA1</name>
                <description>IO pad 1 output data.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA2</name>
                <description>IO pad 2 output data.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA3</name>
                <description>IO pad 3 output data.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA4</name>
                <description>IO pad 4 output data.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA5</name>
                <description>IO pad 5 output data.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA6</name>
                <description>IO pad 6 output data.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA7</name>
                <description>IO pad 7 output data.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PS</name>
            <description>Port IO pad state register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF</resetMask>
            <fields>
              <field>
                <name>DATA0</name>
                <description>IO pad 0 state:
1: Logic high, if the pin voltage is above the input buffer threshold, logic high.
0: Logic low, if the pin voltage is below that threshold, logic low.
If the drive mode for the pin is set to high Z Analog, the pin state will read 0 independent of the voltage on the pin.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA1</name>
                <description>IO pad 1 state.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA2</name>
                <description>IO pad 2 state.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA3</name>
                <description>IO pad 3 state.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA4</name>
                <description>IO pad 4 state.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA5</name>
                <description>IO pad 5 state.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA6</name>
                <description>IO pad 6 state.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DATA7</name>
                <description>IO pad 7 state.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FLT_DATA</name>
                <description>Reads of this register return the logical state of the filtered pin.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PC</name>
            <description>Port configuration register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFBFFFFFF</resetMask>
            <fields>
              <field>
                <name>DM0</name>
                <description>N/A</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OFF</name>
                    <description>Mode 0 (analog mode): Output buffer off (high Z). Input buffer off.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INPUT</name>
                    <description>Mode 1: Output buffer off (high Z). Input buffer on.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>0_PU</name>
                    <description>Mode 2: Strong pull down ('0'), weak/resistive pull up (PU). Input buffer on.
For GPIOV1P2_I2C, Strong pull down only.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PD_1</name>
                    <description>Mode 3: Weak/resistive pull down (PD), strong pull up ('1'). Input buffer on.
For GPIOV1P2_I2C: Weak pull down only.</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>0_Z</name>
                    <description>Mode 4: Strong pull down ('0'), open drain (pull up off). Input buffer on.
For GPIOV1P2_I2C, Strong pull down only.</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>Z_1</name>
                    <description>Mode 5: Open drain (pull down off), strong pull up ('1'). Input buffer on.
Illegal for GPIOV1P2_I2C</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>0_1</name>
                    <description>Mode 6: Strong pull down ('0'), strong pull up ('1'). Input buffer on.
For GPIOV1P2_I2C, Strong pull down only.</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PD_PU</name>
                    <description>Mode 7: Weak/resistive pull down (PD), weak/resistive pull up (PU). Input buffer on.
For GPIOV1P2_I2C: Weak pull down only.</description>
                    <value>7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DM1</name>
                <description>N/A</description>
                <bitRange>[5:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DM2</name>
                <description>N/A</description>
                <bitRange>[8:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DM3</name>
                <description>N/A</description>
                <bitRange>[11:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DM4</name>
                <description>N/A</description>
                <bitRange>[14:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DM5</name>
                <description>N/A</description>
                <bitRange>[17:15]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DM6</name>
                <description>N/A</description>
                <bitRange>[20:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DM7</name>
                <description>N/A</description>
                <bitRange>[23:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PORT_VTRIP_SEL</name>
                <description>N/A</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PORT_SLOW</name>
                <description>N/A</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PORT_HYST_TRIM</name>
                <description>N/A</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PORT_SLEW_CTL</name>
                <description>This field is used to vary slew rate in I2C mode. It comes into picture only when slow=1 and DM=4 ( strong pull down, open drain). Following modes are supported and the corresponding fall time specs are mentioned:</description>
                <bitRange>[29:28]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>PORT_SLEW_CTL_0</name>
                    <description>HS mode (100pf &lt; Cb &lt; 400pF, 1.71&lt;VDDD&lt;5.5, Vext&gt;3.0)
FS mode (10pf&lt;Cb&lt;400pf,1.71&lt;VDDD&lt;5.5) (20-160ns)</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PORT_SLEW_CTL_1</name>
                    <description>HS mode (Cb&lt;100pf,1.71&lt;VDDD&lt;5.5,Vext&gt;2.8,F=1.7MHz) (10-80ns)
FS+ Mode (Vext&gt;2.8,1.71&lt;VDDD&lt;5.5) (20-120ns)</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PORT_SLEW_CTL_2</name>
                    <description>HS mode (100pf&lt;Cb&lt;400pf, 1.71&lt;VDDD&lt;5.5,Vext&lt;3.3) (20-160ns)</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PORT_SLEW_CTL_3</name>
                    <description>HS mode (Cb&lt;100pf,1.71&lt;VDDD&lt;5.5,Vext&lt;=2.8,F=1.7MHz) (10-80ns)
FS+ mode (Vext&lt;=2.8,1.71&lt;VDDD&lt;5.5) (20-120ns)</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PORT_IB_MODE_SEL</name>
                <description>N/A</description>
                <bitRange>[31:30]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_CFG</name>
            <description>Port interrupt configuration register</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FFFFF</resetMask>
            <fields>
              <field>
                <name>EDGE0_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pad 0.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <description>Disabled</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RISING</name>
                    <description>Rising edge</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING</name>
                    <description>Falling edge</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH</name>
                    <description>Both rising and falling edges</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>EDGE1_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pad 1.</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE2_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pad 2.</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE3_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pad 3.</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE4_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pad 4.</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE5_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pad 5.</description>
                <bitRange>[11:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE6_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pad 6.</description>
                <bitRange>[13:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>EDGE7_SEL</name>
                <description>Sets which edge will trigger an IRQ for IO pad 7.</description>
                <bitRange>[15:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FLT_EDGE_SEL</name>
                <description>Same for the glitch filtered pin (selected by FLT_SEL).</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLE</name>
                    <description>Disabled</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>RISING</name>
                    <description>Rising edge</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING</name>
                    <description>Falling edge</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH</name>
                    <description>Both rising and falling edges</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FLT_SEL</name>
                <description>Selects which pin is routed through the 50ns glitch filter to provide a glitch-safe interrupt.</description>
                <bitRange>[20:18]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Port interrupt status register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1FF01FF</resetMask>
            <fields>
              <field>
                <name>DATA0</name>
                <description>Interrupt pending on IO pad 0. Firmware writes 1 to clear the interrupt.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA1</name>
                <description>Interrupt pending on IO pad 1. Firmware writes 1 to clear the interrupt.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA2</name>
                <description>Interrupt pending on IO pad 2. Firmware writes 1 to clear the interrupt.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA3</name>
                <description>Interrupt pending on IO pad 3. Firmware writes 1 to clear the interrupt.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA4</name>
                <description>Interrupt pending on IO pad 4. Firmware writes 1 to clear the interrupt.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA5</name>
                <description>Interrupt pending on IO pad 5. Firmware writes 1 to clear the interrupt.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA6</name>
                <description>Interrupt pending on IO pad 6. Firmware writes 1 to clear the interrupt.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA7</name>
                <description>Interrupt pending on IO pad 7. Firmware writes 1 to clear the interrupt.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FLT_DATA</name>
                <description>Deglitched interrupt pending (selected by FLT_SEL).</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PS_DATA0</name>
                <description>`</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PS_DATA1</name>
                <description>N/A</description>
                <bitRange>[17:17]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PS_DATA2</name>
                <description>N/A</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PS_DATA3</name>
                <description>N/A</description>
                <bitRange>[19:19]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PS_DATA4</name>
                <description>N/A</description>
                <bitRange>[20:20]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PS_DATA5</name>
                <description>N/A</description>
                <bitRange>[21:21]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PS_DATA6</name>
                <description>N/A</description>
                <bitRange>[22:22]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PS_DATA7</name>
                <description>N/A</description>
                <bitRange>[23:23]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>PS_FLT_DATA</name>
                <description>This is a duplicate of the contents of the PS register, provided here to allow reading of both pin state and interrupt state of the port in a single read operation.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SIO</name>
            <description>Port SIO configuration register</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>PAIR_VREG01_EN</name>
                <description>Selects output buffer mode:
0: unregulated output buffer
1: regulated output buffer

The regulated output configuration is selected ONLY if the dm&lt;2:0&gt; bits set a strong pull up configuration (Modes 3, 5, or 6). Weak pull up modes pull to VDDIO.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_IBUF01_SEL</name>
                <description>Selects input buffer mode:
0: singled ended input buffer with a threshold controlled by PAIR_VTRIP01_SEL
1: differential input buffer, see table in PAIR_VTRIP01_SEL description for details</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VTRIP01_SEL</name>
                <description>In single ended input buffer mode (PAIR_IBUF01_SEL = '0'):
VTRIP_SEL=0: input buffer functions as a CMOS input buffer.
VTRIP_SEL=1: input buffer functions as a LVTTL input buffer.

In differential input buffer mode (PAIR_IBUF01_SEL = '1'): 
PAIR_VREF01_SEL=00: 
  a) PAIR_VTRIP01_SEL=0 -&gt; Trip point=50 percent of vddio
  b) PAIR_VTRIP01_SEL=1 -&gt; Trip point=40 percent of vddio

PAIR_VREF01_SEL=01/10/11:
  a) PAIR_VTRIP01_SEL=0 -&gt; Trip point=50 percent of Voh (see table in PAIR_VOH01_SEL for details)
  b) PAIR_VTRIP01_SEL=1 -&gt; Trip point=Vref  (see table in PAIR_VREF01_SEL for details)</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VREF01_SEL</name>
                <description>Selects reference voltage Vref for trip-point of input buffer and reference for VOH regulator:
0: Vref = 1.2V (input buffers use vddio as Vref)
1: Vref = 1.2V
2: Vref = AMUXBUS_A
3: Vref = AMUXBUS_B</description>
                <bitRange>[4:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VOH01_SEL</name>
                <description>Selects regulated Voh output level and trip point of input buffer for a specific SIO pin pair. Voh depends on the selected Vref voltage (see table in PAIR_VREF_01SEL description for details). 
0: Voh = 1*vref 
1: Voh = 1.25*vref
2: Voh = 1.49*vref
3: Voh = 1.67*vref
4: Voh = 2.08*vref
5: Voh = 2.5*vref
6: Voh = 2.78*vref
7: Voh = 4.16*vref
Note: The upper value on Voh is limited to Vddio - 400mV</description>
                <bitRange>[7:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VREG23_EN</name>
                <description>N/A</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_IBUF23_SEL</name>
                <description>N/A</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VTRIP23_SEL</name>
                <description>N/A</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VREF23_SEL</name>
                <description>N/A</description>
                <bitRange>[12:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VOH23_SEL</name>
                <description>N/A</description>
                <bitRange>[15:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VREG45_EN</name>
                <description>N/A</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_IBUF45_SEL</name>
                <description>N/A</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VTRIP45_SEL</name>
                <description>N/A</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VREF45_SEL</name>
                <description>N/A</description>
                <bitRange>[20:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VOH45_SEL</name>
                <description>N/A</description>
                <bitRange>[23:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VREG67_EN</name>
                <description>N/A</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_IBUF67_SEL</name>
                <description>N/A</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VTRIP67_SEL</name>
                <description>N/A</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VREF67_SEL</name>
                <description>N/A</description>
                <bitRange>[28:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PAIR_VOH67_SEL</name>
                <description>N/A</description>
                <bitRange>[31:29]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PC2</name>
            <description>Port configuration register 2</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>INP_DIS0</name>
                <description>Disables the input buffer for IO pad 0 independent of the port control drive mode (PC.DM). This bit should be set when analog signals are present on the pin and PC.DM != 0 is required to use the output driver.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INP_DIS1</name>
                <description>Disables the input buffer for IO pad 1.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INP_DIS2</name>
                <description>Disables the input buffer for IO pad 2.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INP_DIS3</name>
                <description>Disables the input buffer for IO pad 3.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INP_DIS4</name>
                <description>Disables the input buffer for IO pad 4.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INP_DIS5</name>
                <description>Disables the input buffer for IO pad 5.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INP_DIS6</name>
                <description>Disables the input buffer for IO pad 6.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INP_DIS7</name>
                <description>Disables the input buffer for IO pad 7.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DR_SET</name>
            <description>Port output data set register</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>IO pad i:
'0': Output state DR.DATA[i] not affected.
'1': Output state DR.DATA[i] set to '1'.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DR_CLR</name>
            <description>Port output data clear register</description>
            <addressOffset>0x44</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>IO pad i:
'0': Output state DR.DATA[i] not affected.
'1': Output state DR.DATA[i] set to '0'.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DR_INV</name>
            <description>Port output data invert register</description>
            <addressOffset>0x48</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>IO pad i:
'0': Output state DR.DATA[i] not affected.
'1': Output state DR.DATA[i] inverted ('0' =&gt; '1', '1' =&gt; '0').</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DS</name>
            <description>Port drive strength register</description>
            <addressOffset>0x4C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x1AAAA</resetValue>
            <resetMask>0x3FFFF</resetMask>
            <fields>
              <field>
                <name>DS0</name>
                <description>N/A</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>0</name>
                    <description>1 ma drive nominal - changes with external R/C loading and I2C speed (Standard, Fast, Fast+)</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>1</name>
                    <description>2 ma drive nominal - changes with external R/C loading and I2C speed (Standard, Fast, Fast+)</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>2</name>
                    <description>4 ma drive nominal - changes with external R/C loading and I2C speed (Standard, Fast, Fast+)</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>3</name>
                    <description>8 ma drive nominal - changes with external R/C loading and I2C speed (Standard, Fast, Fast+)</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>DS1</name>
                <description>N/A</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DS2</name>
                <description>N/A</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DS3</name>
                <description>N/A</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DS4</name>
                <description>N/A</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DS5</name>
                <description>N/A</description>
                <bitRange>[11:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DS6</name>
                <description>N/A</description>
                <bitRange>[13:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DS7</name>
                <description>N/A</description>
                <bitRange>[15:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PORT_V1P2_VTRIP_SEL</name>
                <description>N/A</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PORT_V1P2_IB_MODE_SEL</name>
                <description>N/A</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>FILT_CONFIG</name>
            <description>IO filter config register</description>
            <addressOffset>0x50</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFF</resetMask>
            <fields>
              <field>
                <name>TRIM0</name>
                <description>N/A</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIM1</name>
                <description>N/A</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIM2</name>
                <description>N/A</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIM3</name>
                <description>N/A</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIM4</name>
                <description>N/A</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIM5</name>
                <description>N/A</description>
                <bitRange>[11:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIM6</name>
                <description>N/A</description>
                <bitRange>[13:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TRIM7</name>
                <description>N/A</description>
                <bitRange>[15:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FILT0_EN</name>
                <description>N/A</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FILT1_EN</name>
                <description>N/A</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FILT2_EN</name>
                <description>N/A</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FILT3_EN</name>
                <description>N/A</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FILT4_EN</name>
                <description>N/A</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FILT5_EN</name>
                <description>N/A</description>
                <bitRange>[21:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FILT6_EN</name>
                <description>N/A</description>
                <bitRange>[22:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FILT7_EN</name>
                <description>N/A</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>VREFGEN</name>
            <description>Reference generator configuration register</description>
            <addressOffset>0x80</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x11F</resetMask>
            <fields>
              <field>
                <name>REF_SEL</name>
                <description>Reference selection. A reference Voltage vinref is created using a Voltage vddio:
'0': vinref = (0 * 13 + 184)/600 * vddio = 184/600 * vddio.
'1': vinref = (1 * 13 + 184)/600 * vddio = 197/600 * vddio.
'2': vinref = (2 * 13 + 184)/600 * vddio = 210/600 * vddio.
...
'31': vinref = (31 * 13 + 184)/600 * vddio = 587/600 * vddio.</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VREFGEN_EN</name>
                <description>Reference generator enable:
'0': Disabled.
'1': Enabled.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>INTR_CAUSE</name>
          <description>Interrupt port cause register</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>PORT_INT</name>
              <description>Each IO port has an associated bit field in this register. The bit field reflects the IO port's interrupt line (bit field i reflects 'interrupts_gpio[i]' for IO port i). The register is used when the system uses a shared/combined interrupt line 'interrupt_gpio'. The SW ISR reads the register to determine which IO port(s) is responsible for the shared/combined interrupt line 'interrupt_gpio'. Once, the IO port(s) is determined, the IO port's INTR register is read to determine the IO pad(s) in the IO port that caused the interrupt.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DFT_IO_TEST</name>
          <description>IO SELF TEST control register for DfT purposes only</description>
          <addressOffset>0x1010</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2020200</resetValue>
          <resetMask>0x1F1F1F03</resetMask>
          <fields>
            <field>
              <name>DFT_IO_TEST_MODE</name>
              <description>DfT IO SELF TEST mode:</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>Functional mode: disables the DfT IO SELF TEST; none of the 'DFT_*' control signals from this register control the IO cells.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TEST_ADFT</name>
                  <description>select this mode during ADFT testing to control 'hld_ovr/oe_n/ analog_sel/ analog_pol/ analog_en' signals of IO cells as below:
the ADFT-0 assigned IO cell connects to: DFT_*_0;  
the ADFT-1 assigned IO cell connects to: DFT_*_1; ...</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TEST_ANA</name>
                  <description>select this mode for testing analog switches to control 'hld_ovr/oe_n/analog_en/analog_sel/analog_pol' signals of IO cells as below:
the IO_TEST_0 assigned IO cell connects to: DFT_*_0;
the IO_TEST_1 assigned IO cell connects to: DFT_*_1;...</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TEST_GEN</name>
                  <description>select this mode for generic testing to control 'hld_ovr/oe_n/analog_en/analog_sel/analog_pol' signals of IO cells as below:
All IO cells connect to: DFT_*_2;</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DFT_HLD_OVR_0</name>
              <description>'hld_ovr' DfT control for IO cells depending on DFT_IO_TEST_MODE as given below.
TEST_ADFT: Connects to 'hld_ovr' of the ADFT-0  assigned IO cell.
TEST_ANA: Connects to 'hld_ovr' of the IO_TEST_0  assigned IO cell.
TEST_GEN: not used.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_OE_N_0</name>
              <description>'oe_n' DfT control for IO cells depending on DFT_IO_TEST_MODE as given below.
TEST_ADFT: Connects to 'oe_n' of the ADFT-0  assigned IO cell.
TEST_ANA: Connects to 'oe_n' of the IO_TEST_0  assigned IO cell.
TEST_GEN: not used.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_ANALOG_EN_0</name>
              <description>'analog_en' DfT control for IO cells depending on DFT_IO_TEST_MODE as given below.
TEST_ADFT: Connects to 'analog_en' of the ADFT-0  assigned IO cell.
TEST_ANA: Connects to 'analog_en' of the IO_TEST_0  assigned IO cell.
TEST_GEN: not used.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_ANA_SEL_0</name>
              <description>'analog_sel' DfT control for IO cells depending on DFT_IO_TEST_MODE as given below.
TEST_ADFT: Connects to 'analog_sel' of the ADFT-0  assigned IO cell.
TEST_ANA: Connects to 'analog_sel' of the IO_TEST_0  assigned IO cell.
TEST_GEN: not used.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_ANA_POL_0</name>
              <description>'analog_pol' DfT control for IO cells depending on DFT_IO_TEST_MODE as given below.
TEST_ADFT: Connects to 'analog_pol' of the ADFT-0  assigned IO cell.
TEST_ANA: Connects to 'analog_pol' of the IO_TEST_0  assigned IO cell.
TEST_GEN: not used.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_HLD_OVR_1</name>
              <description>'hld_ovr' DfT control for IO cells depending on DFT_IO_TEST_MODE as given below.
TEST_ADFT: Connects to 'hld_ovr' of the ADFT-1  assigned IO cell.
TEST_ANA: Connects to 'hld_ovr' of the IO_TEST_1  assigned IO cell.
TEST_GEN: not used.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_OE_N_1</name>
              <description>'oe_n' DfT control for IO cells depending on DFT_IO_TEST_MODE as given below.
TEST_ADFT: Connects to 'oe_n' of the ADFT-1  assigned IO cell.
TEST_ANA: Connects to 'oe_n' of the IO_TEST_1  assigned IO cell.
TEST_GEN: not used.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_ANALOG_EN_1</name>
              <description>'analog_en' DfT control for IO cells depending on DFT_IO_TEST_MODE as given below.
TEST_ADFT: Connects to 'analog_en' of the ADFT-1  assigned IO cell.
TEST_ANA: Connects to 'analog_en' of the IO_TEST_1  assigned IO cell.
TEST_GEN: not used.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_ANA_SEL_1</name>
              <description>'analog_sel' DfT control for IO cells depending on DFT_IO_TEST_MODE as given below.
TEST_ADFT: Connects to 'analog_sel' of the ADFT-1  assigned IO cell.
TEST_ANA: Connects to 'analog_sel' of the IO_TEST_1  assigned IO cell.
TEST_GEN: not used.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_ANA_POL_1</name>
              <description>'analog_pol' DfT control for IO cells depending on DFT_IO_TEST_MODE as given below.
TEST_ADFT: Connects to 'analog_pol' of the ADFT-1  assigned IO cell.
TEST_ANA: Connects to 'analog_pol' of the IO_TEST_1  assigned IO cell.
TEST_GEN: not used.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_HLD_OVR_2</name>
              <description>'hld_ovr' DfT control for IO cells depending on DFT_IO_TEST_MODE as given below.
TEST_ADFT: Connects to 'hld_ovr' of all IO cells other than ADFT-0/1 .
TEST_ANA: Connects to 'hld_ovr' of all IO cells other than IO_TEST_0/1.
TEST_GEN: Connects to 'hld_ovr' of all IO cells.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_OE_N_2</name>
              <description>'oe_n' DfT control for IO cells depending on DFT_IO_TEST_MODE as given below.
TEST_ADFT: Connects to 'oe_n' of all IO cells other than ADFT-0/1.
TEST_ANA: Connects to 'oe_n' of all IO cells other than IO_TEST_0/1.
TEST_GEN: Connects to 'oe_n' of all IO cells</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_ANALOG_EN_2</name>
              <description>'analog_en' DfT control for IO cells depending on DFT_IO_TEST_MODE as given below.
TEST_ADFT: Connects to 'analog_en' of all IO cells other than ADFT-0/1.
TEST_ANA: DFT_ANALOG_EN_2 &amp;&amp; DM[0] connects to 'analog_en' of all IO cells other than IO_TEST_0/1.
TEST_GEN: Connects to 'analog_en' of all IO cells</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_ANA_SEL_2</name>
              <description>'analog_sel' DfT control for IO cells depending on DFT_IO_TEST_MODE as given below.
TEST_ADFT: Connects to 'analog_sel' of all IO cells other than ADFT-0/1.
TEST_ANA: Connects to 'analog_sel' of all IO cells other than IO_TEST_0/1.
TEST_GEN: Connects to 'analog_sel' of all IO cells.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_ANA_POL_2</name>
              <description>'analog_pol' DfT control for IO cells depending on DFT_IO_TEST_MODE as given below.
TEST_ADFT: Connects to 'analog_pol' of all IO cells other than ADFT-0/1.
TEST_ANA: Connects to 'analog_pol' of all IO cells other than IO_TEST_0/1.
TEST_GEN: Connects to 'analog_pol' of all IO cells.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>GPIOV1P2_DET</name>
          <description>GPIOV1P2 Detect output</description>
          <addressOffset>0x1020</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>DET</name>
              <description>Indicates HI when VDDIO is in 1.8V range, and LOW when VDDIO is in 1.2V range.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PRGIO</name>
      <description>Programmable IO configuration</description>
      <baseAddress>0x40050000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>4096</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>2</dim>
          <dimIncrement>256</dimIncrement>
          <name>PRT[%s]</name>
          <description>Programmable IO port registers</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>CTL</name>
            <description>Control register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x2001400</resetValue>
            <resetMask>0x82001F00</resetMask>
            <fields>
              <field>
                <name>BYPASS</name>
                <description>Bypass of the programmable IO, one bit for each IO pin: BYPASS[i] is for IO pin i. When ENABLED is '1', this field is used. When ENABLED is '0', this field is NOT used and PRGIO is always bypassed.
'0': No bypass (programmable IO fabric is exposed). 
'1': Bypass (programmable IO fabric is hidden).</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CLOCK_SRC</name>
                <description>Clock ('clk_fabric') and reset ('rst_fabric_n') source selection:
'0': io_data_in[0]/'1'.
...
'7': io_data_in[7]/'1'.
'8': chip_data[0]/'1'.
...
'15': chip_data[7]/'1'.
'16': clk_prgio/rst_sys_act_n. Used for both Active functionality synchronous logic on 'clk_prgio'. This selection is intended for synchronous operation on a PCLK specified clock frequency ('clock_prgio_en'). Note that the fabric's clocked elements are frequency aligned, but NOT phase aligned to 'clk_sys'. 
'17': clk_prgio/rst_sys_dpslp_n. Used for both DeepSleep functionality synchronous logic on 'clk_prgio' (note that 'clk_prgio' is NOT available in DeepSleep and Hibernate power modes).  This selection is intended for synchronous operation on a PCLK specified clock frequency ('clock_prgio_en'). Note that the fabric's clocked elements are frequency aligned, but NOT phase aligned to 'clk_sys'. 
'18': clk_prgio/rst_sys_hib_n. Used for both Hibernate functionality synchronous logic on 'clk_prgio' (note that 'clk_prgio' is NOT available in DeepSleep and Hibernate power modes).  This selection is intended for synchronous operation on a PCLK specified clock frequency ('clock_prgio_en'). Note that the fabric's clocked elements are frequency aligned, but NOT phase aligned to 'clk_sys'. 
'19': clk_lf/rst_lf_dpslp_n (note that 'clk_lf' is only available in DeepSleep power mode). This selection is intended for synchronous operation on'clk_lf'. Note that the fabric's clocked elements are frequency aligned, but NOT phase aligned to other 'clk_lf' clocked elements.
'20'-'30': Clock source is constant '0'. Any of these clock sources should be selected when the IP is disabled to ensure low power consumption.
'31': clk_sys/'1'. This selection is NOT intended for 'clk_sys' operation, but for asynchronous operation: three 'clk_sys' cycles after enabling the IP, the IP is fully functional (reset is de-activated). To be used for asynchronous (clockless) fabric functionality.</description>
                <bitRange>[12:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>HLD_OVR</name>
                <description>IO cell hold override functionality. In DeepSleep and Hibernate power modes, the HSIOM holds the IO cell output and output enable signals if Active functionality is connected to the IO pads. This is undesirable if the PRGIO is supposed to deliver DeepSleep or Hibernate output functionality on these IO pads. This field is used to control the hold override functionality from the PRGIO:
'0': The HSIOM controls the IO cell hold override functionality ('hsiom_hld_ovr').
'1': The PRGIO controls the IO cel hold override functionality:
- In bypass mode (ENABLED is '0' or BYPASS[i] is '1'), the HSIOM control is used.
- In NON bypass mode (ENABLED is '1' and BYPASS[i] is '0'), the PRGIO sets hold override to 'pwr_hld_ovr_hib' to enable PRGIO functionality in DeepSleep and Hibernate power modes (but disables it in Stop power mode).

Note that in Hibernate power mode, the PRGIO should not rely on the state of Active or DeepSleep functionality signals from the HSIOM: these signals are clamped to '0' in Hibernate'</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PIPELINE_EN</name>
                <description>Enable for pipeline register:
'0': Disabled (register is bypassed).
'1': Enabled.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED</name>
                <description>Enable for programmable IO. Should only be set to '1' when the programmable IO is completely configured:
'0': Disabled (signals are bypassed; behavior as if BYPASS is 0xFF). When disabled, the fabric (data unit and LUTs) reset is activated.

If the IP is disabled:
- The PIPELINE_EN register field should be set to '1', to ensure low power consumption by preventing combinatorial loops.
- The CLOCK_SRC register field should be set to '20'-'30' (clock is constant '0'), to ensure low power consumption.

'1': Enabled. Once enabled, it takes 3 'clk_fabric' clock cycles till the fabric reset is de-activated and the fabric becomes fully functional. This ensures that the IO pins' input synchronizer states are flushed when the fabric is fully functional.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>SYNC_CTL</name>
            <description>Synchronization control register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>IO_SYNC_EN</name>
                <description>Synchronization of the IO pin input signals to 'clk_fabric', one bit for each IO pin: IO_SYNC_EN[i] is for IO pin i.
'0': No synchronization.
'1': Synchronization.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CHIP_SYNC_EN</name>
                <description>Synchronization of the chip input signals to 'clk_fabric', one bit for each input: CHIP_SYNC_EN[i] is for input i.
'0': No synchronization.
'1': Synchronization.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>8</dim>
            <dimIncrement>4</dimIncrement>
            <name>LUT_SEL[%s]</name>
            <description>LUT component input selection</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>LUT_TR0_SEL</name>
                <description>LUT input signal 'tr0_in' source selection:
'0': Data unit output.
'1': LUT 1 output.
'2': LUT 2 output.
'3': LUT 3 output.
'4': LUT 4 output.
'5': LUT 5 output.
'6': LUT 6 output.
'7': LUT 7 output.
'8': chip_data[0] (for LUTs 0, 1, 2, 3); chip_data[4] (for LUTs 4, 5, 6, 7).
'9': chip_data[1] (for LUTs 0, 1, 2, 3); chip_data[5] (for LUTs 4, 5, 6, 7).
'10': chip_data[2] (for LUTs 0, 1, 2, 3); chip_data[6] (for LUTs 4, 5, 6, 7).
'11': chip_data[3] (for LUTs 0, 1, 2, 3); chip_data[7] (for LUTs 4, 5, 6, 7).
'12': io_data_in[0] (for LUTs 0, 1, 2, 3); io_data_in[4] (for LUTs 4, 5, 6, 7).
'13': io_data_in[1] (for LUTs 0, 1, 2, 3); io_data_in[5] (for LUTs 4, 5, 6, 7).
'14': io_data_in[2] (for LUTs 0, 1, 2, 3); io_data_in[6] (for LUTs 4, 5, 6, 7).
'15': io_data_in[3] (for LUTs 0, 1, 2, 3); io_data_in[7] (for LUTs 4, 5, 6, 7).</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LUT_TR1_SEL</name>
                <description>LUT input signal 'tr1_in' source selection:
'0': LUT 0 output.
'1': LUT 1 output.
'2': LUT 2 output.
'3': LUT 3 output.
'4': LUT 4 output.
'5': LUT 5 output.
'6': LUT 6 output.
'7': LUT 7 output.
'8': chip_data[0] (for LUTs 0, 1, 2, 3); chip_data[4] (for LUTs 4, 5, 6, 7).
'9': chip_data[1] (for LUTs 0, 1, 2, 3); chip_data[5] (for LUTs 4, 5, 6, 7).
'10': chip_data[2] (for LUTs 0, 1, 2, 3); chip_data[6] (for LUTs 4, 5, 6, 7).
'11': chip_data[3] (for LUTs 0, 1, 2, 3); chip_data[7] (for LUTs 4, 5, 6, 7).
'12': io_data_in[0] (for LUTs 0, 1, 2, 3); io_data_in[4] (for LUTs 4, 5, 6, 7).
'13': io_data_in[1] (for LUTs 0, 1, 2, 3); io_data_in[5] (for LUTs 4, 5, 6, 7).
'14': io_data_in[2] (for LUTs 0, 1, 2, 3); io_data_in[6] (for LUTs 4, 5, 6, 7).
'15': io_data_in[3] (for LUTs 0, 1, 2, 3); io_data_in[7] (for LUTs 4, 5, 6, 7).</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LUT_TR2_SEL</name>
                <description>LUT input signal 'tr2_in' source selection. Encoding is the same as for LUT_TR1_SEL.</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>8</dim>
            <dimIncrement>4</dimIncrement>
            <name>LUT_CTL[%s]</name>
            <description>LUT component control register</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>LUT</name>
                <description>LUT configuration. Depending on the LUT opcode LUT_OPC, the internal state lut_reg (captured in a flip-flop) and the LUT input signals tr0_in, tr1_in, tr2_in, the LUT configuration is used to determine the LUT output signal and the next sequential state (lut_reg).</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>LUT_OPC</name>
                <description>LUT opcode specifies the LUT operation:
'0': Combinatoral output, no feedback.
   tr_out   = LUT[{tr2_in, tr1_in, tr0_in}].
'1': Combinatorial output, feedback.
   tr_out   = LUT[{lut_reg, tr1_in, tr0_in}].
On clock:
    lut_reg &lt;= tr_in2.
'2': Sequential output, no feedback.
   temp    = LUT[{tr2_in, tr1_in, tr0_in}].
   tr_out   = lut_reg.
On clock:
   lut_reg &lt;= temp.
'3': Register with asynchronous set and reset.
   tr_out           = lut_reg.
   enable          = (tr2_in ^ LUT[4]) | LUT[5].
   set               = enable &amp; (tr1_in ^ LUT[2]) &amp; LUT[3].
   clr                = enable &amp; (tr0_in ^ LUT[0]) &amp; LUT[1].
Asynchronously (no clock required):
   lut_reg         &lt;= if (clr) '0' else if (set) '1'</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DU_SEL</name>
            <description>Data unit component input selection</description>
            <addressOffset>0xC0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DU_TR0_SEL</name>
                <description>Data unit input signal 'tr0_in' source selection:
'0': Constant '0'.
'1': Constant '1'.
'2': Data unit output.
'10-3': LUT 7 - 0 outputs.
Otherwise: Undefined.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DU_TR1_SEL</name>
                <description>Data unit input signal 'tr1_in' source selection. Encoding is the same as for DU_TR0_SEL.</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DU_TR2_SEL</name>
                <description>Data unit input signal 'tr2_in' source selection. Encoding is the same as for DU_TR0_SEL.</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DU_DATA0_SEL</name>
                <description>Data unit input data 'data0_in' source selection:
'0': Constant '0'.
'1': chip_data[7:0].
'2': io_data_in[7:0].
'3': DATA.DATA MMIO register field.</description>
                <bitRange>[25:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DU_DATA1_SEL</name>
                <description>Data unit input data 'data1_in' source selection. Encoding is the same as for DU_DATA0_SEL.</description>
                <bitRange>[29:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DU_CTL</name>
            <description>Data unit component control register</description>
            <addressOffset>0xC4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DU_SIZE</name>
                <description>Size/width of the data unit data operands (in bits) is DU_SIZE+1. E.g., if DU_SIZE is 7, the width is 8 bits.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DU_OPC</name>
                <description>Data unit opcode specifies the data unit operation:
'1': INCR
'2': DECR
'3': INCR_WRAP
'4': DECR_WRAP
'5': INCR_DECR
'6': INCR_DECR_WRAP
'7': ROR
'8': SHR
'9': AND_OR
'10': SHR_MAJ3
'11': SHR_EQL.
Otherwise: Undefined.</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DATA</name>
            <description>Data register</description>
            <addressOffset>0xF0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>Data unit input data source.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>HVSS</name>
      <description>High Voltage Subsystem</description>
      <baseAddress>0x40060000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>HVREG_STATUS</name>
          <description>HVREG Status</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>PWR_GOOD</name>
              <description>High if regulator is settled and operating within normal limits</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PWR_GOOD_MAST</name>
              <description>Master Power Good</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PWR_GOOD_SLAVE</name>
              <description>Slave Power Good</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>THERMAL_SHUTDOWN</name>
              <description>Thermal Shutdown Active</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HVREG_BIST</name>
          <description>HVREG Bist</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF11F</resetMask>
          <fields>
            <field>
              <name>HVREG_ADFT</name>
              <description>Controls ADFT switches</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <description>Normal operation, amuxbus_a=Z</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BIAS_CIRCUIT_CURRENT_MONITOR</name>
                  <description>Vbias monitor</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IREF1P4V</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>IBIAS</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MAST_IDRIVE</name>
                  <description>N/A</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MAST_TSD_GATE</name>
                  <description>N/A</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MAST_TSD_DIODE</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MAST_ZENER_GATE</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MAST_ILIM</name>
                  <description>N/A</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MAST_ILIM2</name>
                  <description>N/A</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TSD_VTH_VOTAGE_DET</name>
                  <description>N/A</description>
                  <value>10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TSD_VTH_VOTAGE_REL</name>
                  <description>N/A</description>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TSD_OUT_VCCD</name>
                  <description>N/A</description>
                  <value>12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TSD_OUT_VCCD2</name>
                  <description>N/A</description>
                  <value>13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD_14</name>
                  <description>N/A</description>
                  <value>14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD_15</name>
                  <description>N/A</description>
                  <value>15</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HVREG_DDFT</name>
              <description>Enable HVREG DDFT outputs to DDFT interface when '1'
(PG on ddft0, '0' on ddft1)</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_BURN_IN</name>
              <description>Enable burn-in test mode with Vccd(1.8V) domain</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SLAVE_ADFT</name>
              <description>Controls ADFT switches</description>
              <bitRange>[15:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <description>Normal operation, amuxbus_a=Z</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD_1</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD_2</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD_3</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLAVE_IDRIVE</name>
                  <description>Slave driver current monitor (3uA nominal)</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLAVE_TSD_GATE</name>
                  <description>Slave TSD NMOS gate voltage</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD_6</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLAVE_ZENER_GATE</name>
                  <description>Slave Zener enable gate voltage</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLAVE_ILIM</name>
                  <description>Slave Current limit mirror</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLAVE_ILIM2</name>
                  <description>Slave Current limit2 monitor</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD_10</name>
                  <description>N/A</description>
                  <value>10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD_11</name>
                  <description>N/A</description>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD_12</name>
                  <description>N/A</description>
                  <value>12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD_13</name>
                  <description>N/A</description>
                  <value>13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD_14</name>
                  <description>N/A</description>
                  <value>14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD_15</name>
                  <description>N/A</description>
                  <value>15</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>HVREG_CTRL</name>
          <description>HVREG Control</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3</resetValue>
          <resetMask>0x8133</resetMask>
          <fields>
            <field>
              <name>ZENER_CLAMP_MODE</name>
              <description>Controls zener clamp mode</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CLAMP_NOT_PRESENT_0</name>
                  <description>Zener disabled</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLAMP_NOT_PRESENT_1</name>
                  <description>Zener disabled</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ZENER_CLAMP_PRESENT</name>
                  <description>Zener enabled</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ZENER_CLAMP_DIODE_PRESENT</name>
                  <description>Zener and diode enabled</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TSD_MODE</name>
              <description>Controls thermal shutdown mode</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>KEEP_REGULATORS_ON_FOR_TSD</name>
                  <description>Keep Vdd on for TSD event (LIN turns off)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TURN_OFF_REGULATORS_ON_TSD</name>
                  <description>Turn off Vdd and LIN on TSD event</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD_2</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TURN_OFF_TSD</name>
                  <description>Turn off TSD circuit</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EN_VDIV</name>
              <description>Enable Vbat Voltage divider</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_SLAVE</name>
              <description>Enable slave</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RDIV_CTL</name>
          <description>Resistor Attenuator Control</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x37</resetMask>
          <fields>
            <field>
              <name>RDIV_EN_0</name>
              <description>Enable VS0
0=Disabled
1=Enabled during power modes selected by RDIV_ACT_EN</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RDIV_EN_1</name>
              <description>Enable VS1
0=Disabled
1=Enabled during power modes selected by RDIV_ACT_EN</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RDIV_ACT_EN</name>
              <description>Power modes where RDIV is enabled
0=Enable in Active and Deep-Sleep modes
1=Enable in Active mode only</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RDIV_SCALE_0</name>
              <description>VS0 attenuation
0=16X attenuation
1=24X attenuation</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RDIV_SCALE_1</name>
              <description>VS1 attenuation
0=16X attenuation
1=24X attenuation</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LIN_CTL</name>
          <description>LIN PHY Control</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80003117</resetMask>
          <fields>
            <field>
              <name>LIN_MODE</name>
              <description>Controls LIN mode</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>OFF (TX off, Rx off, Bias Circuits Off), LIN pin recessive</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SLEEP</name>
                  <description>TX off, RX on, LIN pin recessive (typically used in deep-sleep)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>STANDBY</name>
                  <description>TX off, RX off, Bias circuits on (faster turn-on, not normally used)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIAGNOSIS</name>
                  <description>TX on, RX on, TX w/weak pull-down (broken wire detect diag)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NORMAL_1_0</name>
                  <description>TX on, RX on, 1.0V/us TX edge rate, may not meet all parameters of LIN spec at some operating conditions</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NORMAL_1_5</name>
                  <description>TX on, RX on, 1.5V/us TX edge rate, meets all parameters of LIN spec</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>NORMAL_2_0</name>
                  <description>TX on, RX on, 2.0V/us TX edge rate, may not meet all parameters of LIN spec at some operating conditions</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FAST</name>
                  <description>Fast mode (non-lin compliant, up to 100kb/s capable)</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>RF_DETECT</name>
              <description>Renamed from SL_ROUND. 0=off; 1=on, reduce impact on LIN driver from incoming EMI.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>USE_ALT_INTERFACE</name>
              <description>Selects Primary or Alternate interface for PHY.  The primary use is to enable compliance testing by directly manipulating the PHY interface through GPIOs.
0 = Primary interface (connected to internal LIN/CXPI controller through HSIOM)
1 = Alternate interface (connected to GPIOs through HSIOM)</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEL_CXPI_LIN</name>
              <description>Selects LIN or CXPI interface. Bit 1 selects between LIN and CXPI, Bit 0 selects between CXPI master and slave</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LIN_PHY_0</name>
                  <description>Operates as LIN interface</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LIN_PHY_1</name>
                  <description>Operates as LIN interface</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CXPI_MASTER</name>
                  <description>Operates as CXPI master</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CXPI_SLAVE</name>
                  <description>Operates as CXPI slave</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LIN_EN</name>
              <description>Master enable of the LIN/CXPI interface.  
0=Interface is reset and LIN pin is in Hi-Z state
1=Enable the LIN interface</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LIN_TIMER</name>
          <description>LIN Timer Control</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xCFFF0FFF</resetMask>
          <fields>
            <field>
              <name>WAKEUP_TIMER</name>
              <description>Number of CLK_LF edges before wakeup interrupt is triggered</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FAULT_TIMER</name>
              <description>Number of CLK_LF edges before fault interrupt is triggered</description>
              <bitRange>[27:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>WAKEUP_TIMER_EN</name>
              <description>Wakeup timer is running, required for full LIN compatibility if using Deep-sleep power mode</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FAULT_TIMER_EN</name>
              <description>Dominant state fault timer is running, required for full LIN compatibility</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LIN_STATUS</name>
          <description>LIN Status</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>LIN_RXD</name>
              <description>Current state of LIN pin, except when LIN_CTL.LIN_MODE is 0 or 2, when RXD = 1.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LIN_BIST</name>
          <description>LIN BIST Control</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x37</resetMask>
          <fields>
            <field>
              <name>LIN_ADFT</name>
              <description>Enables Test Modes</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NORMAL</name>
                  <description>Normal Operation (DFT disabled), amuxbus_a=Z, dft&lt;1:0&gt;=0</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CURRENT_MONITOR_LWAVE</name>
                  <description>amuxbus_a=Iwave (PMOS drain), dft&lt;1:0&gt;=0</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VOLTAGE_MONITOR_ERRBUFF</name>
                  <description>amuxbus_a=ErrBuff, dft&lt;1:0&gt;=0</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WEAK_OUTFET</name>
                  <description>OUTFET = 1/10,  (amuxbus_a=Z, dft&lt;1:0&gt;=0)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CURRENT_MONITOR_FOR_BIAS_CKT</name>
                  <description>amuxbus_a=Ibias monitor (PMOS drain), dft&lt;1:0&gt;=0</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SL_ROUND</name>
                  <description>0=Normal, 1=More moderate (rounded) edge for lower EMI</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DDFT_OSC</name>
                  <description>amuxbus_a = Z
dft&lt;1&gt; = LIN_DFT_START,  dft&lt;0&gt; = LIN_OSC</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DDFT_DELAY</name>
                  <description>amuxbus_a = Z
dft&lt;1&gt; = LIN_DFT_START,  dft&lt;0&gt; = LIN_DELAY</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LIN_DDFT</name>
              <description>Enable LIN DDFT outputs to DDFT interface
ddft1 = dft&lt;1&gt;, ddft0 = dft&lt;0&gt;</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_DFT_START</name>
              <description>Delay line input</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LIN_INTR</name>
          <description>HVSS Interrupt Request Register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>WAKEUP</name>
              <description>Master asserted dominant state wakeup (wakeup timer timeout)</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FAULT</name>
              <description>Interface asserted state for too long (dominant state timeout)</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVREG_TSD</name>
              <description>Thermal Shutdown Detected</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LIN_INTR_SET</name>
          <description>HVSS Interrupt set register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>WAKEUP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FAULT</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVREG_TSD</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LIN_INTR_MASK</name>
          <description>HVSS Interrupt mask register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>WAKEUP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FAULT</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HVREG_TSD</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LIN_INTR_MASKED</name>
          <description>HVSS Interrupt masked register</description>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7</resetMask>
          <fields>
            <field>
              <name>WAKEUP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FAULT</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>HVREG_TSD</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HVSS_DDFT</name>
          <description>HVSS DDFT Control</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>LSOUT_DDFT</name>
              <description>Enable LSOUT DDFT output to DDFT interface
ddft1 = lsout_ddft, ddft0 = 0</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HVREG_TRIM</name>
          <description>HVREG Master Trim (Output Voltage)</description>
          <addressOffset>0xFF00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>TRIM</name>
              <description>Trim for VDDD output.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>LIN_TRIM</name>
          <description>LIN Trim Settings</description>
          <addressOffset>0xFF04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>SLEW_CTL</name>
              <description>N/A</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HVREG_TRIM_VREF</name>
          <description>HVREG Vref Trim</description>
          <addressOffset>0xFF10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>VREF_CTL</name>
              <description>Vref Trim</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HVREG_TRIM_VREF_TC</name>
          <description>HVREG Vref Output Voltage temp-co Trim</description>
          <addressOffset>0xFF14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>TC_CTL</name>
              <description>Vref Temperature Trim</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HVREG_TRIM_TSD</name>
          <description>HVREG TSD detection temperatureTrim</description>
          <addressOffset>0xFF18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>TSD_CTL</name>
              <description>TSD Trim</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>HVREG_TRIM_S</name>
          <description>HVREG Slave Trim (Output Voltage)</description>
          <addressOffset>0xFF1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>TRIM</name>
              <description>Trim for VDDD output.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>CPUSS</name>
      <description>CPU Subsystem</description>
      <baseAddress>0x40100000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>4096</size>
        <usage>registers</usage>
      </addressBlock>
      <interrupt>
        <name>srss_interrupt_srss</name>
        <description>SRSS interrupts</description>
        <value>0</value>
      </interrupt>
      <interrupt>
        <name>srss_wdt_irq</name>
        <description>WDT Interrupt</description>
        <value>1</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupt_gpio</name>
        <description>GPIO consolidated interrupt</description>
        <value>2</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_0</name>
        <description>GPIO P0</description>
        <value>3</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_1</name>
        <description>GPIO P1</description>
        <value>4</value>
      </interrupt>
      <interrupt>
        <name>ioss_interrupts_gpio_2</name>
        <description>GPIO P2</description>
        <value>5</value>
      </interrupt>
      <interrupt>
        <name>hvss_interrupt_hvss</name>
        <description>HVSS interface interrupt</description>
        <value>6</value>
      </interrupt>
      <interrupt>
        <name>lpcomp_interrupt</name>
        <description>LPCOMP#0 trigger interrupt</description>
        <value>7</value>
      </interrupt>
      <interrupt>
        <name>scb_0_interrupt</name>
        <description>SCB #0 interrupt</description>
        <value>8</value>
      </interrupt>
      <interrupt>
        <name>scb_1_interrupt</name>
        <description>SCB #0 interrupt</description>
        <value>9</value>
      </interrupt>
      <interrupt>
        <name>pass_0_interrupt_ctbs</name>
        <description>CTBm</description>
        <value>10</value>
      </interrupt>
      <interrupt>
        <name>scb_2_interrupt</name>
        <description>SCB #2 interrupt</description>
        <value>11</value>
      </interrupt>
      <interrupt>
        <name>scb_3_interrupt</name>
        <description>SCB #3 interrupt</description>
        <value>12</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupt_dma</name>
        <description>DMA Interrupt</description>
        <value>13</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupt_spcif</name>
        <description>SPCIF interrupt</description>
        <value>14</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupt_fault_0</name>
        <description>Fault structure 0 interrupt</description>
        <value>15</value>
      </interrupt>
      <interrupt>
        <name>cpuss_interrupt_fault_1</name>
        <description>Fault structure 1 interrupt</description>
        <value>16</value>
      </interrupt>
      <interrupt>
        <name>lin_interrupts_0</name>
        <description>LIN interrupt, channel #0</description>
        <value>17</value>
      </interrupt>
      <interrupt>
        <name>lin_interrupts_1</name>
        <description>LIN interrupt, channel #1</description>
        <value>18</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_interrupts_0</name>
        <description>TCPWM #0, Counter #0</description>
        <value>19</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_interrupts_1</name>
        <description>TCPWM #0, Counter #1</description>
        <value>20</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_interrupts_2</name>
        <description>TCPWM #0, Counter #2</description>
        <value>21</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_interrupts_3</name>
        <description>TCPWM #0, Counter #3</description>
        <value>22</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_interrupts_4</name>
        <description>TCPWM #0, Counter #4</description>
        <value>23</value>
      </interrupt>
      <interrupt>
        <name>pass_0_interrupt_sar</name>
        <description>SAR</description>
        <value>24</value>
      </interrupt>
      <interrupt>
        <name>msc_0_interrupt</name>
        <description>CSD</description>
        <value>25</value>
      </interrupt>
      <interrupt>
        <name>cxpi_interrupts_0</name>
        <description>CXPI interrupt, channel #0</description>
        <value>26</value>
      </interrupt>
      <interrupt>
        <name>cxpi_interrupts_1</name>
        <description>CXPI interrupt, channel #1</description>
        <value>27</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_interrupts_5</name>
        <description>TCPWM #0, Counter #5</description>
        <value>28</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_interrupts_6</name>
        <description>TCPWM #0, Counter #6</description>
        <value>29</value>
      </interrupt>
      <interrupt>
        <name>tcpwm_interrupts_7</name>
        <description>TCPWM #0, Counter #7</description>
        <value>30</value>
      </interrupt>
      <registers>
        <register>
          <name>CONFIG</name>
          <description>Configuration register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>VECT_IN_RAM</name>
              <description>0': Vector Table is located at 0x0000:0000 in flash
'1': Vector Table is located at 0x2000:0000 in SRAM
Note that vectors for RESET and FAULT are always fetched from ROM. Value in flash/RAM is ignored for these vectors.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SYSREQ</name>
          <description>SYSCALL control register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x30000000</resetValue>
          <resetMask>0xFC00FFFF</resetMask>
          <fields>
            <field>
              <name>SYSCALL_COMMAND</name>
              <description>Opcode of the system call being requested.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EXTERNAL_SYS_REQ</name>
              <description>External HW SYS REQ. This bit is set by HW to cause a SYSCALL to BOOTROM.  This bit may only be cleared by SW. When this bit is set, the SYSCALL_COMMAND, PRIVILEDGED, HMASTER0,  and SYSCALL_ARG content are invalid.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DIS_RESET_VECT_REL</name>
              <description>Disable Reset Vector fetch relocation:
'0': CPU accesses to locations 0x0000:0000 - 0x0000:0007 are redirected to ROM.
'1': CPU accesses to locations 0x0000:0000 - 0x0000:0007 are made to flash.
Note that this field defaults to '0' on reset, ensuring actual reset vector fetches are always made to ROM. Note that this field does not affect DAP accesses. Flash DfT routines may set this bit to '1' to enable uninhibited read-back of programmed data in the first flash page.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PRIVILEGED</name>
              <description>Indicates whether the system is in privileged ('1') or user mode ('0'). Only CPU SW executing from ROM can set this field to '1' when ROM_ACCESS_EN is '1' (the CPU is executing a SystemCall NMI interrupt handler). Any other write to this field sets is to '0'. This field is used as the AHB-Lite hprot[1] signal to implement Cypress proprietary user/privileged modes. These modes are used to enable/disable access to specific MMIO registers and memory regions.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ROM_ACCESS_EN</name>
              <description>Indicates that executing from Boot ROM is enabled. HW sets this field to '1', on reset or when the SystemCall NMI vector is fetched from Boot ROM. HW sets this field to '0', when the CPU is NOT executing from either Boot or System ROM. This bit is used for debug purposes only.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>HMASTER_0</name>
              <description>Indicates the source of the write access to the SYSREQ register.
'0': CPU write access.
'1': DAP write access.

For a SW write to the SYSREQ register, the HW will update this field based on the value of SYSCALL_REQ.

SYSCALL_REQ = 0 : the current source of write access is captured.
SYSCALL_REQ = 1 : the previous value (captured when SYSCALL_REQ was 0), is retained/maintained until the next SW write to this register.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SYSCALL_REQ</name>
              <description>CPU/DAP writes a '1' to this field to request a SystemCall. The HMASTER_0 field indicates the source of the write access. Setting this field to '1' immediate results in a NMI. The SystemCall NMI interrupt handler sets this field to '0' after servicing the request.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SYSARG</name>
          <description>SYSARG control register</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SYSCALL_ARG</name>
              <description>Argument to System Call specified in SYSREQ. Semantics of argument depends on system call made. Typically a pointer to a parameter block.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_SEL</name>
          <description>Interrupt multiplexer select register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DSI</name>
              <description>Specifies interrupt source:
'0': Fixed Function.
'1': DSI.
When changing the source of a specific interrupt, it is advised to temporarily disable the interrupt using the CM0 NVIC's CLRENA and SETENA interrupt enable clear and set registers to prevent a spurious interrupt activation. In addition, the CM0 NVIC's CLRPEND interrupt pending clear register should be used clear a pending interrupt before re-enabling the interrupt.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INT_MODE</name>
          <description>DSI interrupt pulse mode register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DSI_INT_PULSE</name>
              <description>Specifies DSI interrupt format:
'0': level sensitive; i.e. no pulse generator.
'1': pulse generator on rising edge.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NMI_MODE</name>
          <description>DSI NMI pulse mode register</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>DSI_NMI_PULSE</name>
              <description>Specifies DSI NMI format:
'0': level sensitive; i.e. no pulse generator.
'1': pulse generator on rising edge.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_CTL</name>
          <description>FLASH control register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x33011F</resetMask>
          <fields>
            <field>
              <name>FLASH_WS</name>
              <description>For Flash With ECC the number of wait states (WS):
WS = 3 for SYSCLK &lt;= FMAX
WS = 2 for SYSCLK &lt;= 3/4 * FMAX
WS = 1 for SYSCLK &lt;= 1/2 * FMAX
WS = 0 for SYSCLK &lt;= 1/4 * FMAX
4-15 : Future Use - To be used, if 3 Wait State is not sufficient.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PREF_EN</name>
              <description>N/A</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLASH_INVALIDATE</name>
              <description>N/A</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARB</name>
              <description>N/A</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLASH_ECC_INJ_EN</name>
              <description>N/A</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLASH_ERR_SILENT</name>
              <description>N/A</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ROM_CTL</name>
          <description>ROM control register</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x30001</resetMask>
          <fields>
            <field>
              <name>ROM_WS</name>
              <description>Amount of ROM wait states:
'0': 0 wait states. Use this setting for newer, faster ROM design. Use this setting for older, slower ROM design and frequencies in the range [0, 24] MHz.
'1': 1 wait state. Use this setting for older, slower ROM design and frequencies in the range &lt;24, 48] MHz.

Should always be set to 0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARB</name>
              <description>N/A</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM_CTL</name>
          <description>RAM control register</description>
          <addressOffset>0x38</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x30055</resetMask>
          <fields>
            <field>
              <name>ECC_ENABLE</name>
              <description>Enable ECC operation:
'0': ECC Disabled - ECC is not generated/checked
'1': ECC Enabled - ECC is generated/checked</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_AUTO_CORRECT</name>
              <description>HW ECC autocorrect functionality:
'0': Disabled.
'1': Enabled. HW automatically writes back SRAM with corrected data when a recoverable ECC error is detected.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_INJ_EN</name>
              <description>Enable error injection.
0:  Syndrome is source from ECC Syndrome hardware.
1: ECC_TEST.SYND_DATA is used when a full 32-bit write is done to the ECC_TEST.WORD_ADDR word address of SRAM0.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_BIST_SWITCH</name>
              <description>ECC_BIST_SWITCH: Substitutes Syndrome bits for normal data path during BIST testing. Data bits 31:25 on the SRAM data path both to and from the SRAM are replaced with the SRAM Syndrome data bits 38:32 during BIST testing when this bit is set to 1.
'0': Source normal datapath to BIST bus
'1': Source Syndrome bits to BIST bus</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARB</name>
              <description>Arbitration Policy:
'0': CPU has priority
'1': DW/DMA has priority
'2': Roundrobin
'3': Roundrobin - sticky</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DMAC_CTL</name>
          <description>DMA controller register</description>
          <addressOffset>0x3C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x30000</resetMask>
          <fields>
            <field>
              <name>ARB</name>
              <description>Arbitration policy:
0: CPU has priority
1: DW/DMA has priority
2: Roundrobin
3: Roundrobin - sticky</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM1_CTL</name>
          <description>RAM 1 control register</description>
          <addressOffset>0xA4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x30055</resetMask>
          <fields>
            <field>
              <name>ECC_ENABLE</name>
              <description>Enable ECC operation:
'0': ECC Disabled - ECC is not generated/checked
'1': ECC Enabled - ECC is generated/checked</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_AUTO_CORRECT</name>
              <description>HW ECC autocorrect functionality:
'0': Disabled.
'1': Enabled. HW automatically writes back SRAM with corrected data when a recoverable ECC error is detected.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_INJ_EN</name>
              <description>Enable error injection.
0:  Syndrome is source from ECC Syndrome hardware.
1: ECC_TEST.SYND_DATA is used when a full 32-bit write is done to the ECC_TEST.WORD_ADDR word address of SRAM1.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ECC_BIST_SWITCH</name>
              <description>ECC_BIST_SWITCH: Substitutes Syndrome bits for normal data path during BIST testing. Data bits 31:25 on the SRAM data path both to and from the SRAM are replaced with the SRAM Syndrome data bits 38:32 during BIST testing when this bit is set to 1.
'0': Source normal datapath to BIST bus
'1': Source Syndrome bits to BIST bus</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARB</name>
              <description>Arbitration policy:
0: CPU has priority
1: DW/DMA has priority
2: Roundrobin
3: Roundrobin - sticky</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASHC1_CTL</name>
          <description>FLASH Control1  control register</description>
          <addressOffset>0xA8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x33011F</resetMask>
          <fields>
            <field>
              <name>FLASH_WS</name>
              <description>Amount of ROM wait states:
For Flash (without ECC).
0: 0 wait states (fast flash: [0, 24] MHz system frequency, slow flash: [0, 16] MHz system frequency)
1: 1 wait state (fast flash: [24, 48] MHz system frequency, slow flash: [16, 32] MHz system frequency)
2: 2 wait states (slow flash: [32, 48] MHz system frequency)
3-15 : Future Use.

For Flash With ECC.
0: 0 wait states ([0, 12] MHz system frequency)
1: 1 wait state ([12, 24] MHz system frequency)
2: 2 wait states (24,36] MHz system frequency)
3: 3 wait states ([36,48] MHz System Frequency)
4-15 : Future Use - To be used, if 3 Wait State is not sufficient.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PREF_EN</name>
              <description>Prefetch enable:
'0': disabled. This is a desirable setting when FLASH_WS is 0 or when predictable execution behavior is required.
'1': enabled.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLASH_INVALIDATE</name>
              <description>1': Invalidates the content of the flash controller's buffers.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ARB</name>
              <description>Arbitration policy:
0: CPU has priority
1: DW/DMA has priority
2: Roundrobin
3: Roundrobin - sticky</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLASH_ECC_INJ_EN</name>
              <description>Enable error injection for FLASH main interface.
When'1', the parity (ECC_CTL.PARITY[7:0]) is used for a load from the ECC_CTL.WORD_ADDR[23:0] word address.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLASH_ERR_SILENT</name>
              <description>Specifies bus transfer behavior for a non-recoverable error on the FLASH macro main interface (either a non-correctable ECC error, a FLASH macro main interface internal error, a FLASH macro main interface memory hole access, a M0S8 protection violation error):
0: Bus transfer has a bus error.
1: Bus transfer does NOT have a bus error; i.e. the error is 'silent'

In either case, a Zero value is returned. 

This field is ONLY used by CPU bus transfers. Non-CPU bus transfers always have a bus transfer with a bus error, in case of a non-recoverable error</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FAULT_CTL</name>
          <description>Fault Control Register</description>
          <addressOffset>0xAC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x30000</resetMask>
          <fields>
            <field>
              <name>ARB</name>
              <description>Arbitration policy:
0: CPU has priority
1: DW/DMA has priority
2: Roundrobin
3: Roundrobin - sticky</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MTB_CTL</name>
          <description>MTB control register</description>
          <addressOffset>0xB0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>CPU_HALT_TSTOP_EN</name>
              <description>1': Enable CPU Halt to stop MTB trace. (HALTED output of CM0+ can stop the trace when high/'1')
'0': HALTED output of CM0+ can not strop trace.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DAP_CTL</name>
          <description>SWD DP Instance ID</description>
          <addressOffset>0xC4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>INSTANCE_ID</name>
              <description>Specifies the SWD DP Instance ID
This is used with the SWD Multi-Drop feature to uniquely identify a chip.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM_STATUS</name>
          <description>RAM Controller 0 Status</description>
          <addressOffset>0xD0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>WB_EMPTY</name>
              <description>Write buffer empty. This information is used when entering DeepSleep power mode: WB_EMPTY must be '1' before a transition to system DeepSleep power mode.
'0': Write buffer NOT empty.
'1': Write buffer empty.

Note: the SRAM controller write buffer is only used when ECC checking is enabled. (RAMi_CTL.ECC_EN is '1').</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM1_STATUS</name>
          <description>RAM Controller 1 Status</description>
          <addressOffset>0xD4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>WB_EMPTY</name>
              <description>Write buffer empty. This information is used when entering DeepSleep power mode: WB_EMPTY must be '1' before a transition to system DeepSleep power mode.
'0': Write buffer NOT empty.
'1': Write buffer empty.

Note: the SRAM controller write buffer is only used when ECC checking is enabled. (RAMi_CTL.ECC_EN is '1').</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BOOT_RESULT_0</name>
          <description>Boot Result Register 0</description>
          <addressOffset>0xE0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BOOT_RESULT</name>
              <description>Record details of Boot Process.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>BOOT_RESULT_1</name>
          <description>Boot Result Register 1</description>
          <addressOffset>0xE4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BOOT_RESULT</name>
              <description>Record details of Boot Process.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>24</dim>
          <dimIncrement>4</dimIncrement>
          <name>SL_CTL[%s]</name>
          <description>Slave control register</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x30000</resetMask>
          <fields>
            <field>
              <name>ARB</name>
              <description>Arbitration policy:
0: CPU priority
1: DMA priority
2: Roundrobin
3: Roundrobin - sticky</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM_ECC_STATUS0</name>
          <description>RAM ECC Status 0</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>ECC_CAPTURE_ADDR_31_2</name>
              <description>Snapshot of CPUSS Address which caused the first correctable/un-correctable error interrupt. When first correctable/un-correctable error interrupt is generated, ECC_CAPTURE_ADDR_SYNDROME_VALID is transitioned from 0 to 1 , and this registered captures the first error address. The register only captures bits 31-2 of the address.</description>
              <bitRange>[29:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ECC_CAPTURE_ADDR_SYNDROME_VALID</name>
              <description>ECC Capture address and Syndrome valid.  
0: ECC_CAPTURE_ADDR_31_2 not valid
1: ECC_CAPTURE_ADDR_31_2 valid - SW writes a 1 to clear</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM_ECC_STATUS1</name>
          <description>RAM ECC Status 1</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>ECC_CAPTURE_SYNDROME</name>
              <description>Snapshot of CPUSS Syndrome which caused the first correctable/un-correctable error interrupt. When first correctable/un-correctable error interrupt is generated, ECC_CAPTURE_ADDR_SYNDROME_VALID is transitioned from 0 to 1 , and this registered captures the first Syndrome corresponding to the Error.</description>
              <bitRange>[6:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM1_ECC_STATUS0</name>
          <description>RAM1 ECC Status 0</description>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>ECC_CAPTURE_ADDR_31_2</name>
              <description>Snapshot of CPUSS Address which caused the first correctable/un-correctable error interrupt. When first correctable/un-correctable error interrupt is generated, ECC_CAPTURE_ADDR_SYNDROME_VALID is transitioned from 0 to 1 , and this registered captures the first error address. The register only captures bits 31-2 of the address.</description>
              <bitRange>[29:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ECC_CAPTURE_ADDR_SYNDROME_VALID</name>
              <description>ECC Capture address and Syndrome valid.  
0: ECC_CAPTURE_ADDR_31_2 not valid
1: ECC_CAPTURE_ADDR_31_2 valid - SW writes a 1 to clear</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RAM1_ECC_STATUS1</name>
          <description>RAM1 ECC Status 1</description>
          <addressOffset>0x20C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>ECC_CAPTURE_SYNDROME</name>
              <description>Snapshot of CPUSS Syndrome which caused the first correctable/un-correctable error interrupt. When first correctable/un-correctable error interrupt is generated, ECC_CAPTURE_ADDR_SYNDROME_VALID is transitioned from 0 to 1 , and this registered captures the first Syndrome corresponding to the Error.</description>
              <bitRange>[6:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ECC_TEST</name>
          <description>ECC Test</description>
          <addressOffset>0x210</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>WORD_ADDR</name>
              <description>Specifies the word address where an error will be injected.
- For SRAMs, the word address WORD_ADDR[24:0] is the device address A[26:2]. On a write transfer to this SRAM address and when the corresponding RAM_CTL.ECC_INJ_EN or RAM1_CTL.ECC_INJ_EN bit is '1', the parity (SYND_DATA[6:0]) is injected into the corresponding SRAM location.</description>
              <bitRange>[24:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SYND_DATA</name>
              <description>ECC syndrome to use for error injection at address WORD_ADDR.</description>
              <bitRange>[31:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>Interrupt register</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>SRAM0_C_ERROR</name>
              <description>Correctable ECC Error For SRAM - interrupt signaled on interrupt_sram_nc_ecc</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SRAM0_NC_ERROR</name>
              <description>Uncorrectable ECC Error For SRAM - interrupt signaled on interrupt_sram_nc_ecc</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SRAM1_C_ERROR</name>
              <description>Correctable ECC Error For SRAM1 - interrupt signaled on interrupt_sram1_c_ecc</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SRAM1_NC_ERROR</name>
              <description>Uncorrectable ECC Error For SRAM1 - interrupt signaled on interrupt_sram1_nc_ecc</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>Interrupt set register</description>
          <addressOffset>0x304</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>SRAM0_C_ERROR</name>
              <description>SW writes a '1' to this field to set the corresponding field in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SRAM0_NC_ERROR</name>
              <description>SW writes a '1' to this field to set the corresponding field in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SRAM1_C_ERROR</name>
              <description>SW writes a '1' to this field to set the corresponding field in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SRAM1_NC_ERROR</name>
              <description>SW writes a '1' to this field to set the corresponding field in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>Interrupt mask register</description>
          <addressOffset>0x308</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>SRAM0_C_ERROR</name>
              <description>Mask bit for corresponding field in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SRAM0_NC_ERROR</name>
              <description>Mask bit for corresponding field in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SRAM1_C_ERROR</name>
              <description>Mask bit for corresponding field in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SRAM1_NC_ERROR</name>
              <description>Mask bit for corresponding field in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>Interrupt masked register</description>
          <addressOffset>0x30C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>SRAM0_C_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SRAM0_NC_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SRAM1_C_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SRAM1_NC_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>EXT_MS_CTL</name>
          <description>External master control register</description>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x30000</resetMask>
          <fields>
            <field>
              <name>ARB</name>
              <description>Arbitration policy:
0: EXTM0/DMAC has priority
1: EXTM1 has priority
2: Roundrobin
3: Roundrobin - sticky</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASHC_BERR_STATUS</name>
          <description>Flash Bus Error Status</description>
          <addressOffset>0x500</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>INTERNAL_ERROR</name>
              <description>N/A</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLASH_UNCORRECTABLE</name>
              <description>N/A</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLASH_MEMORY_HOLE</name>
              <description>N/A</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLASH_PROT_VIO</name>
              <description>A protection violation occurred in Flash Controller.

SW clears this field to '0'. HW sets this field to '1' on a protection violation occurred in Flash Controllers. Typically, SW reads this field after a code section to detect the occurrence of an error.

Note: this field is independent of FLASH_CTL.FLASH_ERR_SILENT.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASHC1_BERR_STATUS</name>
          <description>Flash 1 Bus Error Status</description>
          <addressOffset>0x504</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>INTERNAL_ERROR</name>
              <description>See the Explanation for FLASHC_BERR_STATUS</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLASH_UNCORRECTABLE</name>
              <description>See the Explanation for FLASHC_BERR_STATUS</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLASH_MEMORY_HOLE</name>
              <description>See the Explanation for FLASHC_BERR_STATUS</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FLASH_PROT_VIO</name>
              <description>See the Explanation for FLASHC_BERR_STATUS</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASHC_ECC_CTL</name>
          <description>Flash ECC Control</description>
          <addressOffset>0x508</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FLASH_WORD_ADDR</name>
              <description>Specifies the word address where an error will be injected.
- For FLASH  interface ECC, the word address WORD_ADDR[23:0] is device address A[26:3]. On a FLASH main interface read and when FLASH_CTL.MAIN_ECC_INJ_EN bit is '1', the parity (PARITY[7:0]) replaces the FLASH macro parity (FLASH main interface read path is manipulated).</description>
              <bitRange>[23:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>ECC parity to use for ECC error injection at address WORD_ADDR. 
- For FLASH  interface ECC, the 8-bit parity PARITY[7:0] is for a 64-bit word.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASHC1_ECC_CTL</name>
          <description>Flash 1 ECC Control</description>
          <addressOffset>0x50C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FLASH_WORD_ADDR</name>
              <description>See the Explanation for FLASHC_ECC_CTL</description>
              <bitRange>[23:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>See the Explanation for FLASHC_ECC_CTL</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>DMAC</name>
      <description>DataWire/DMA Controller</description>
      <baseAddress>0x40101000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>4096</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Control register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>ENABLED</name>
              <description>0': IP is disabled. Non-retainable MMIO registers and logic functionality are reset (retainable MMIO registers are NOT reset):
- INTR register is set to '0'.
- DW/DMA functionality is aborted.
- DW/DMA controller input/pending triggers are de-activated.
- DW/DMA controller output triggers are de-activated.
Disabling the IP has the same effect as an active 'rst_sys_act_n' reset in DeepSleep power mode. To prevent a loss of active (pending) DW/DMA triggers when disabling the IP or when transitioning from Active to DeepSleep power mode, the STATUS.ACTIVE and STATUS_CH_ACT.CH fields can be used.

Note that most MMIO registers are retainable, and a transition from DeepSleep to Active/Sleep power modes makes the DW/DMA controller operational, and ready to react to DW/DMA input triggers that are activated after the transition. Triggers are Active/Sleep functionality.
'1': IP is enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Status register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x87000000</resetMask>
          <fields>
            <field>
              <name>DATA_NR</name>
              <description>Specifies the index of the currently active data transfer. This value increases from '0' to CONTROL.DATA_NR.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CH_ADDR</name>
              <description>Specifies the channel number of the currently active channel. E.g. if we have 32 channels, the channel number address with CH_ADDR_WIDTH is LOG2 (32) = 5, and this field is a 5-bit field. If channel 7 is active, STATUS.ACTIVE is '1' and STATUS.CH_ADDR is '7'.</description>
              <bitRange>[20:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>STATE</name>
              <description>State of the data transfer engine. 
'0': DEFAULT state.
'1': Loading descriptor (SRC, DST, CONTROL and STATUS words).
'2': Loading data element from source location.
'3': Storing data element to destination location.
'4': Storing descriptor (STATUS word).
'5': Wait for trigger de-activation.
'6': Storing descriptor with error response (STATUS word).</description>
              <bitRange>[26:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PRIO</name>
              <description>Specifies the priority of the currently active channel.</description>
              <bitRange>[29:28]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Specifies the descriptor of the channel is currently in use.
'0' - PING descriptor 
'1' - PONG descriptor</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ACTIVE</name>
              <description>Specifies if there is a currently active (pending) channel in the data transfer engine: 
'0': no currently active channel.
'1': currently active channel.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS_SRC_ADDR</name>
          <description>Source address status register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Base address or current address of source location of currently active channel. The specific address information is cycle dependent. This field is provided for debug purposes. Functionally, no assumption should be made on whether the base or current address is provided. The specifics of the currently active channel are available through STATUS. Note while reading the STATUS, STATUS_SRC_ADDR and STATUS_DST_ADDR registers, the transfer engine may have moved from one active channel to another.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS_DST_ADDR</name>
          <description>Destination address register</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>Base address or current address of destination location of currently active channel. The specific address information is cycle dependent. This field is provided for debug purposes. Functionally, no assumption should be made on whether the base or current address is provided. The specifics of the currently active channel are available through STATUS. Note while reading the STATUS, STATUS_SRC_ADDR and STATUS_DST_ADDR registers, the transfer engine may have moved from one active channel to another.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS_CH_ACT</name>
          <description>Channel activation status register</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH</name>
              <description>Channel activation status. Bit i is associated to channel i, with i = 0, ..., CH_NR-1.

Software reads this field to get information on all actively pending channels (either in pending or in the data transfer engine).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>32</dim>
          <dimIncrement>4</dimIncrement>
          <name>CH_CTL[%s]</name>
          <description>Channel control register</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF0000000</resetMask>
          <fields>
            <field>
              <name>PRIO</name>
              <description>Channel priority, with '0' representing the highest priority and '3' representing the lowest priority. Priority decoding uses the channel priority to determine the highest priority activated channel. If multiple activated channels have the same highest priority, the channel with the lowest index i, is considered the highest priority activated channel.</description>
              <bitRange>[29:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PING_PONG</name>
              <description>Each channel has two descriptor structures for double buffering purposes. As the controller operates on one structure, the main CPU can operate on the other structure. The descriptor structures are identified as PING ('0') and PONG ('1'). This field identifies the descriptor structure that is currently in use by the controller.

Software sets this field to the desired descriptor structure.

Hardware inverts the field value on the completion of a descriptor structure when CONTROL.FLIPPING of the current descriptor structure is set to '1'.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>'0': channel disabled. The channel's trigger is ignored and the channel cannot be activated. If the activated channel is disabled, the data transfer(s) are aborted. 
'1': channel enabled.

Software sets this field to '1' to enable a specific channel.

Hardware sets this field to '0' on erroneous channel behavior (the specific error is specified by STATUS.RESP in the channel's descriptor structure).</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>Interrupt register</description>
          <addressOffset>0x7F0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH</name>
              <description>Set to '1', when event is detected. Write INTR field with '1', to clear bit. Write INTR_SET field with '1', to set bit.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>Interrupt set register</description>
          <addressOffset>0x7F4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH</name>
              <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>Interrupt mask register</description>
          <addressOffset>0x7F8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH</name>
              <description>Mask for corresponding field in INTR register.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>Interrupt masked register</description>
          <addressOffset>0x7FC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CH</name>
              <description>Logical BITWISE AND of corresponding request and mask fields.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>8</dim>
          <dimIncrement>32</dimIncrement>
          <name>DESCR[%s]</name>
          <description>Descriptors</description>
          <addressOffset>0x00000800</addressOffset>
          <register>
            <name>PING_SRC</name>
            <description>Ping source address</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>ADDR</name>
                <description>Base address of source location. The effective source location is calculated by adding on offset (derived from PING.STATUS.CURR_DATA_NR) to this base address.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PING_DST</name>
            <description>Ping destination address</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>ADDR</name>
                <description>Base address of destination location. The effective destination location is calculated by adding on offset (derived from PING.STATUS.CURR_DATA_NR) to this base address.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PING_CTL</name>
            <description>Ping control word</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA_NR</name>
                <description>Number of data elements that are transferred by a single descriptor.
In DW mode (OPCODE is '0') each trigger initiates the transfer of a single data element. This field specifies the source and/or destination buffer size in data elements: buffer size = DATA_NR+1. The buffer is typically associated to a memory structure.
In DMA mode (OPCODE is '1' or '2') each trigger initiates the transfer of DATA_NR+1 data elements.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_SIZE</name>
                <description>Specifies the data element size:
'0': Byte (8 bits).
'1': Halfword (16 bits).
'2': Word (32 bits).
DATA_SIZE, SRC_TRANSFER_SIZE and DST_TRANSFER_SIZE together determine how data elements are transferred. The following are the 9 legal settings:
- DATA is 8 bit, SRC is 8 bit, DST is 8 bit
- DATA is 8 bit, SRC is 32 bit (higher 24 bits are dropped), DST is 8 bit
- DATA is 8 bit, SRC is 8 bit, DST is 32 bit (higher 24 bits are made '0')
- DATA is 8 bit, SRC is 32 bit (higher 24 bits are dropped), DST is 32 bit (higher 24 bits are made '0')
- DATA is 16 bit, SRC is 16 bit, DST is 16 bit
- DATA is 16 bit, SRC is 32 bit (higher 16 bits are dropped), DST is 16 bit
- DATA is 16 bit, SRC is 16 bit, DST is 32 bit (higher 16 bits are made '0')
- DATA is 16 bit, SRC is 32 bit (higher 16 bits are dropped), DST is 32 bit (higher 16 bits are made '0')
- DATA is 32 bit, SRC is 32 bit, DST is 32 bit</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DST_TRANSFER_SIZE</name>
                <description>Specifies the bus transfer size to the destination location:
'0': As specified by DATA_SIZE.
'1': Word (32 bits).
Distinguishing bus transfer size from data element size allows for destination components with data elements that are smaller than their 32-bit bus interface width. E.g., a DAC destination has a 32-bit bus transfer size, but only requires a 16-bit data element.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DST_ADDR_INCR</name>
                <description>Specifies whether the destination location address is incremented by the DST_TRANSFER_SIZE after each single data element transfer or not.
'0' : No increment, typically used for transmit (TX) FIFO structures.
'1': Increment, typically used for memory structures.</description>
                <bitRange>[21:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SRC_TRANSFER_SIZE</name>
                <description>Specifies the bus transfer size to the source location:
'0': As specified by DATA_SIZE.
'1': Word (32 bits).
Distinguishing bus transfer size from data element size allows for source components with data elements that are smaller than their 32-bit bus interface width. E.g., an ADC source has a 32-bit bus transfer size, but only provides a 16-bit data element.</description>
                <bitRange>[22:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SRC_ADDR_INCR</name>
                <description>Specifies whether the source location address is incremented by the SRC_TRANSFER_SIZE after each single data element transfer or not.
'0': No increment, typically used for receive (RX) FIFO structures.
'1': Increment, typically used for memory structures.</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WAIT_FOR_DEACT</name>
                <description>Specifies whether the data transfer engine should wait for the channel to be deactivated; i.e. the selected system trigger is not active. This field is used to synchronize the controller's data transfer(s) with the agent that generated the trigger. This field is ONLY used at the completion of an opcode. E.g., a FIFO indicates that it is empty and it needs a new data sample. The agent removes the trigger ONLY when the data sample has been written by the transfer engine AND received by the agent.  Furthermore, the agent's trigger may be delayed by a few cycles before it reaches the DW/DMA controller. This field is used for level sensitive trigger, which reflect state (pulse sensitive triggers should have this field set to '0'). The wait cycles incurred by this field reduce DW/DMA controller performance.
'0': Do not wait for de-activation (for pulse sensitive triggers).
'1': Wait for up to 4 cycles.
'2': Wait for up to 8 cycles.
'3': Wait indefinitely. This option may result in DW/DMA controller lockup if the system trigger is not de-activated by the source agent.</description>
                <bitRange>[25:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INV_DESCR</name>
                <description>'1': On completion of the current descriptor structure, the VALID bit of the descriptor's STATUS word is set to '0'.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SET_CAUSE</name>
                <description>'1': On completion of the current descriptor structure, the interrupt cause field of the channel is set to '1' (INTR.CH[i]).</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PREEMPTABLE</name>
                <description>'1': Transfer is preemptable. In DMA mode (OPCODE is '1' or '2'), multi data element transfers are constructed out of multiple single data element load (from the source location) and store (to the destination location) sequences. This field allows higher priority activated channels to preempt the current transfer in between these atomic (load, store) sequences. Preemption will NOT deactivate the current channel. As a result, after completion of a higher priority activated channel, the current channel is rescheduled.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FLIPPING</name>
                <description>'1': On completion of the current descriptor structure, the current descriptor identifier CH_CTLi.PING_PONG is flipped/inverted. In DMA mode, descriptor list transfer, flipping of the current descriptor identifier can be used to construct a linked list of descriptor structures.</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OPCODE</name>
                <description>Specifies the specific data transfer (only when the VALID bit of the descriptor's STATUS word is '1'):

'0': A single trigger initiates a single data element transfer (DW mode). This opcode specifies a transfer of a single data element. The current descriptor is completed when the amount of transferred single data elements equals the programmed buffer size (DATA_NR+1).

'1': A single trigger initiates a single descriptor transfer (DMA mode). This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure. The current descriptor is completed when its data transfer is completed.

'2': A single trigger initiates a descriptor list transfer (DMA mode). This opcode specifies a transfer of DATA_NR+1 data elements as specified by the current descriptor structure and by successive valid descriptors. The current descriptor is completed when its data transfer is completed. This OPCODE relies on FLIPPING to be set to '1', such that the CH_CTLi.PING_PONG field is flipped/inverted and the successive descriptor is used. This continues for as long as the successive descriptor is valid. Note that as the HW is using the PING/PONG descriptor, the SW can prepare the alternate PONG/PING descriptor. The interrupt mechanism is used by HW to convey to the SW that the current descriptor is completed (and can be prepared for a successive transfer).

After completion of the opcode (and waiting for de-activation, the channel's output trigger is activated).</description>
                <bitRange>[31:30]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PING_STATUS</name>
            <description>Ping status word</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>CURR_DATA_NR</name>
                <description>Specifies the index of the current data transfer. This value increases from 0 to CONTROL.DATA_NR. HW sets this field:
- When a descriptor is done (RESPONSE is DONE), the field is set to '0' when PING_CTL.INV_DESCR is '0' and the field is set to PING_CTL.DATA_NR when PING_CTL.INV_DESCR is '1'.
- When a descriptor is not done (RESPONSE is NO_ERROR), the field reflects the progress of a data transfer.
- In case of erroneous behavior (RESPONSE is neither DONE or NO_ERROR), the field is not updated, but keeps its value to ease debugging.
HW only modifies this field for an active descriptor (STATUS.VALID to be '1'). At descriptor initialization, SW should set this field to '0'. 

This field allows software to read the progress of the data transfer. Note that SRC.ADDR and DST.ADDR represent base addresses and are not modified during data transfer. However, STATUS.CURR_DATA_NR is modified during data transfer and provides an offset wrt. the base addresses.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RESPONSE</name>
                <description>Response code (the first two codes NO_ERROR and DONE are the result of normal behavior, the other codes are the result of erroneous behavior).
'0'/NO_ERROR: No error. Setting this response does NOT set the interrupt cause bit to '1'. STATUS.VALID is NOT affected. CH_CTLi.ENABLED is NOT affected. CH_CTLi.PING_PONG is not updated. This response is used for an unused or not completed descriptor. Software should set the RESPONSE field to '0'/NO_ERROR during descriptor initialization.
'1'/DONE: Descriptor is done (without errors). Setting this response sets the interrupt cause bit to '1' if CONTROL.SET_CAUSE is '1'. STATUS.VALID is set to '0' if CONTROL.INV_DESCR is '1'. CH_CTLi.ENABLED is NOT affected. CH_CTLi.PING_PONG is updated if CONTROL.FLIPPING is '1'.
'2'/SRC_BUS_ERROR: Bus error while loading data from the source location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CH_CTLi.ENABLED is set to '0'. CH_CTLi.PING_PONG is not updated (it identifies the descriptor that caused the error).
'3'/DST_BUS_ERROR: Bus error while storing data to the destination location. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CH_CTLi.ENABLED is set to '0'. CH_CTLi.PING_PONG is not updated (it identifies the descriptor that caused the error).
'4'/SRC_MISAL: Misalignment of source address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CH_CTLi.ENABLED is set to '0'. CH_CTLi.PING_PONG is not updated (it identifies the descriptor that caused the error).
'5'/DST_MISAL: Misalignment of destination address. This occurs on a 16-bit bus transfer that is not 2-byte aligned or on a 32-bit bus transfer that is not 4-byte aligned. Setting this response sets the interrupt cause bit to '1'. STATUS.VALID is set '0'. CH_CTLi.ENABLED is set to '0'. CH_CTLi.PING_PONG is not updated (it identifies the descriptor that caused the error).
'6'/INVALID_DESCR: Invalid descriptor (STATUS.VALID is '0'). This occurs when an activated channel has an invalid descriptor. CH_CTLi.ENABLED is set to '0'. CH_CTLi.PING_PONG is not updated (it identifies the descriptor that caused the error).</description>
                <bitRange>[18:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VALID</name>
                <description>'0': Invalid, cannot be used for a data transfer. An attempt to use this descriptor for a data transfer will result in an INVALID_DESCR response code (and the interrupt cause bit is set to '1').
'1': Valid.

Hardware set this field to '0' when a descriptor is done, but only if CONTROL.INV_DESCR is '1'.

Software sets this field to '1' when a descriptor is initialized.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PONG_SRC</name>
            <description>Pong source address</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>ADDR</name>
                <description>See description of PING_SRC.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PONG_DST</name>
            <description>Pong destination address</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>ADDR</name>
                <description>See description of PING_DST.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PONG_CTL</name>
            <description>Pong control word</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA_NR</name>
                <description>See description of PING_CTL.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA_SIZE</name>
                <description>See description of PING_CTL.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DST_TRANSFER_SIZE</name>
                <description>See description of PING_CTL.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DST_ADDR_INCR</name>
                <description>See description of PING_CTL.</description>
                <bitRange>[21:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SRC_TRANSFER_SIZE</name>
                <description>See description of PING_CTL.</description>
                <bitRange>[22:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SRC_ADDR_INCR</name>
                <description>See description of PING_CTL.</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WAIT_FOR_DEACT</name>
                <description>See description of PING_CTL.</description>
                <bitRange>[25:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>INV_DESCR</name>
                <description>See description of PING_CTL.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SET_CAUSE</name>
                <description>See description of PING_CTL.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PREEMPTABLE</name>
                <description>See description of PING_CTL.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FLIPPING</name>
                <description>See description of PING_CTL.</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OPCODE</name>
                <description>See description of PING_CTL.</description>
                <bitRange>[31:30]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PONG_STATUS</name>
            <description>Pong status word</description>
            <addressOffset>0x1C</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>CURR_DATA_NR</name>
                <description>See description of PING_STATUS.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RESPONSE</name>
                <description>See description of PING_STATUS.</description>
                <bitRange>[18:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VALID</name>
                <description>See description of PING_STATUS.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>SPCIF</name>
      <description>Flash Control Interface</description>
      <baseAddress>0x40110000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>GEOMETRY</name>
          <description>Flash/NVL geometry information</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>FLASH</name>
              <description>Regular flash capacity in 256 Byte multiples (chip dependent). If multiple flash macros are present, this field provides the flash capacity of all flash macros together:
'0': 256 Bytes.
'1': 2*256 Bytes.
...
'16383': 16384*256 Bytes.</description>
              <bitRange>[13:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SFLASH</name>
              <description>Supervisory flash capacity in 256 Byte multiples (chip dependent). If multiple flash macros are present, this field provides the supervisory flash capacity of all flash macros together:
'0': 256 Bytes.
'1': 2*256 Bytes.
...
'63': 64*256 Bytes.</description>
              <bitRange>[19:14]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NUM_FLASH</name>
              <description>Number of flash macros (chip dependent):
'0': 1 flash macro
'1': 2 flash macros
'2': 3 flash macros
'3': 4 flash macros</description>
              <bitRange>[21:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FLASH_ROW</name>
              <description>Page size in 64 Byte multiples (chip dependent):
'0': 64 byte
'1': 128 byte
'2': 192 byte
'3': 256 byte

The page size is used to determine the number of Bytes in a page for Flash page based operations (e.g. PGM_PAGE).

Note: the field name FLASH_ROW is misleading, as this field specifies the number of Bytes in a page, rather than the number of Bytes in a row. In a single plane flash macro architecture, a page consists of a single row. However, in a multi plane flash macro architecture, a page consists of multiple rows from different planes.</description>
              <bitRange>[23:22]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NVL</name>
              <description>NVLatch size in Byte multiples (chip dependent):
'0': 0 Bytes
'1': 1 Byte
...
'127': 127 Bytes</description>
              <bitRange>[30:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DE_CPD_LP</name>
              <description>0': SRAM busy wait loop has not been copied.
'1': Busy wait loop has been written into SRAM.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>NVL_WR_DATA</name>
          <description>NVL write data register</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data to be written to NVLatch array</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_LOCK</name>
          <description>Flash Lock Register</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>KEY</name>
              <description>Write Only register that locks/unlocks access to the  FLASH MACRO_WE register by writing a key value to the register. The Key is the 32 bit value '0xF56B3A81'. When this specific bit pattern is written to the register, write access to FLASH_MACRO_WE is toggled between locked and unlocked. The bit FLASH_MACRO_WE.LOCKED toggles upon receipt of the required key value.</description>
              <bitRange>[31:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FLASH_MACRO_WE</name>
          <description>Flash Macro Write Enable</description>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xF</resetValue>
          <resetMask>0x8000000F</resetMask>
          <fields>
            <field>
              <name>MAC_WRITE_EN</name>
              <description>Access control to Flash Macros Write Access. This is a bit mask where each bit controls Program/Erase Access to the corresponding Macro. When the bit is set to '1' then the Macro may be programmed/erased, when the bit is set to '0', the Macro content is locked. The content of this register may only be changed when FLASH_MACRO_WE.LOCKED is '0'.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOCKED</name>
              <description>When set indicates that write access to FLASH_MACRO_WE.MAC_WRITE_EN is blocked. The value of this bit toggles when the key value is written into FLASH_LOCK.KEY.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>SPCIF interrupt request register</description>
          <addressOffset>0x7F0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>TIMER</name>
              <description>Timer counter value reaches '0'. Set to '1', when event is detected. Write INTR field with '1', to clear bit. Write INTR_SET field with '1', to set bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>SPCIF interrupt set request register</description>
          <addressOffset>0x7F4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>TIMER</name>
              <description>Write INTR_SET field with '1' to set corresponding INTR field.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>SPCIF interrupt mask register</description>
          <addressOffset>0x7F8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>TIMER</name>
              <description>Mask for corresponding field in INTR register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>SPCIF interrupt masked request register</description>
          <addressOffset>0x7FC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>TIMER</name>
              <description>Logical and of corresponding request and mask fields.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>FAULT</name>
      <description>Fault structures</description>
      <baseAddress>0x40130000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <cluster>
          <dim>2</dim>
          <dimIncrement>256</dimIncrement>
          <name>STRUCT[%s]</name>
          <description>Fault structure</description>
          <addressOffset>0x00000000</addressOffset>
          <register>
            <name>CTL</name>
            <description>Fault control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7</resetMask>
            <fields>
              <field>
                <name>TR_EN</name>
                <description>Trigger output enable:
'0': Disabled. The trigger output 'tr_fault' is '0'.
'1': Enabled. The trigger output 'tr_fault' reflects STATUS.VALID. The trigger can be used to initiate a Datawire transfer of the FAULT data (FAULT_DATA0 through FAULT_DATA1).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>OUT_EN</name>
                <description>IO output signal enable:
'0': Disabled. The IO output signal 'fault_out' is '0'. The IO output enable signal 'fault_out_en' is '0'.
'1': Enabled. The IO output signal 'fault_out' reflects STATUS.VALID. The IO output enable signal 'fault_out_en' is '1'.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RESET_REQ_EN</name>
                <description>Reset request enable:
'0': Disabled.
'1': Enabled. The output reset request signal 'fault_reset_req' reflects STATUS.VALID. This reset causes a warm/soft/core reset. This warm/soft/core reset does not affect the fault logic STATUS, DATA0, ..., DATA1 registers (allowing for post soft reset failure analysis).

The 'fault_reset_req' signals of the individual fault report structures are combined (logically OR'd) into a single SRSS 'fault_reset_req' signal.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>STATUS</name>
            <description>Fault status</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80000000</resetMask>
            <fields>
              <field>
                <name>IDX</name>
                <description>The fault source index for which fault information is captured in DATA0 through DATA1. The fault information is fault source specific and differs per product. The encoding will align with the definition in the Product Srpeadsheet.

Note: this register field (and associated fault source data in DATA0 through DATA1) should only be considered valid, when VALID is '1'.</description>
                <bitRange>[6:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>VALID</name>
                <description>Valid indication:
'0': Invalid.
'1': Valid. STATUS.IDX, DATA0, ..., DATA1 specify the fault.

Note: Typically, HW sets this field to '1' (on an activated HW fault source that is 'enabled' by the MASK registers) and SW clears this field to '0' (typically by boot code SW (after a warm system reset, when the fault is handled). In this typical use case scenario, the HW source fault data is simultaneously captured into DATA0, ..., DATA1 when the VALID field is set to '1'. 

An exceptional SW use case scenario is identified as well. In this scenario, SW sets this field to '1' with a fault source index different to one of the defined HW fault sources. SW update is not restricted by the MASK registers). In both use case scenarios, the following holds:
- STATUS.IDX, DATA0, ..., DATA1 can only be written when STATUS.VALID is '0'; the fault structure is not in use yet. Writing STATUS.VALID to '1' effectively locks the fault structure (until SW clears STATUS.VALID to '0'). This restriction requires a SW update to sequentially update the DATA registers followed by an update of the STATUS register.

Note: For the exceptional SW use case, sequential updates to the DATA and STATUS registers may be 'interrupted' by a HW fault capture. In this case, the SW DATA register updates are overwritten by the HW update (and the STATUS.IDX field will reflect the HW capture)</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <dim>2</dim>
            <dimIncrement>4</dimIncrement>
            <name>DATA[%s]</name>
            <description>Fault data</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>Captured fault source data. 

Note: the DATA registers can only be written when STATUS.VALID is '0'.

Note: the fault source index STATUS.IDX specifies the format of the DATA registers.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PENDING0</name>
            <description>Fault pending 0</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>SOURCE</name>
                <description>Bit mask of source causing the Fault. See the Product Spreadsheet Fault tab to determine the bit ordering.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>MASK0</name>
            <description>Fault mask 0</description>
            <addressOffset>0x50</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFFFFFF</resetMask>
            <fields>
              <field>
                <name>SOURCE</name>
                <description>Fault source enables:
Bits 31-0: Fault sources 31 to 0.</description>
                <bitRange>[31:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Interrupt</description>
            <addressOffset>0xC0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>FAULT</name>
                <description>This interrupt cause field is activated (HW sets the field to '1') when an enabled (MASK0 pending fault source is captured:
- STATUS.VALID is set to '1'.
- STATUS.IDX specifies the fault source index.
- DATA0 through DATA1 captures the fault source data.

SW writes a '1' to this field to clear the interrupt cause to '0'. SW clear STATUS.VALID to '0' to enable capture of the next fault. Note that when there is an enabled pending fault source, the pending fault source is captured immediately and INTR.FAULT is immediately activated (set to '1').</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt set</description>
            <addressOffset>0xC4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>FAULT</name>
                <description>SW writes a '1' to this field to set the corresponding field in the INTR register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt mask</description>
            <addressOffset>0xC8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>FAULT</name>
                <description>Mask bit for corresponding field in the INTR register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt masked</description>
            <addressOffset>0xCC</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1</resetMask>
            <fields>
              <field>
                <name>FAULT</name>
                <description>Logical and of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>TCPWM</name>
      <description>Timer/Counter/PWM</description>
      <baseAddress>0x40200000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTRL</name>
          <description>TCPWM control register 0.</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>COUNTER_ENABLED</name>
              <description>Counter enables for counters 0 up to CNT_NR-1.
'0': counter disabled.
'1': counter enabled.
Counter static configuration information (e.g. CTRL.MODE, all TR_CTRL0, TR_CTRL1, and TR_CTRL2 register fields) should only be modified when the counter is disabled. When a counter is disabled, command and status information associated to the counter is cleared by HW, this includes:
- the associated counter triggers in the CMD register are set to '0'.
- the counter's interrupt cause fields in counter's INTR register.
- the counter's status fields in counter's STATUS register..
- the counter's trigger outputs ('tr_overflow', 'tr_underflow' and 'tr_compare_match').
- the counter's line outputs ('line_out' and 'line_compl_out').</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD</name>
          <description>TCPWM command register.</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>COUNTER_CAPTURE</name>
              <description>Counters SW capture trigger. When written with '1', a capture trigger is generated and the HW sets the field to '0' when the SW trigger has taken effect. It should be noted that the HW operates on the counter frequency. If the counter is disabled through CTRL.COUNTER_ENABLED, the field is immediately set to '0'.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COUNTER_RELOAD</name>
              <description>Counters SW reload trigger. For HW behavior, see COUNTER_CAPTURE field.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COUNTER_STOP</name>
              <description>Counters SW stop trigger. For HW behavior, see COUNTER_CAPTURE field.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COUNTER_START</name>
              <description>Counters SW start trigger. For HW behavior, see COUNTER_CAPTURE field.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_CAUSE</name>
          <description>TCPWM Counter interrupt cause register.</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>COUNTER_INT</name>
              <description>Counters interrupt signal active. If the counter is disabled through CTRL.COUNTER_ENABLED, the associated interrupt field is immediately set to '0'.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>8</dim>
          <dimIncrement>64</dimIncrement>
          <name>CNT[%s]</name>
          <description>Timer/Counter/PWM Counter Module</description>
          <addressOffset>0x00000100</addressOffset>
          <register>
            <name>CTRL</name>
            <description>Counter control register</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x737FF0F</resetMask>
            <fields>
              <field>
                <name>AUTO_RELOAD_CC</name>
                <description>Specifies switching of the CC and buffered CC values. This field has a function in TIMER, PWM, PWM_DT and PWM_PR modes.
Timer mode:
'0': never switch.
'1': switch on a compare match event.
PWM, PWM_DT, PWM_PR modes: 
'0: never switch.
'1': switch on a terminal count event with an actively pending switch event.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AUTO_RELOAD_PERIOD</name>
                <description>Specifies switching of the PERIOD and buffered PERIOD values. This field has a function in PWM, PWM_DT and PWM_PR modes.
'0': never switch.
'1': switch on a terminal count event with an actively pending switch event.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PWM_SYNC_KILL</name>
                <description>Specifies asynchronous/synchronous kill behavior:
'1': synchronous kill mode: the kill event disables the 'dt_line_out' and 'dt_line_compl_out' signals till the next terminal count event (synchronous kill). In synchronous kill mode, STOP_EDGE should  be RISING_EDGE.
'0': asynchronous kill mode: the kill event only disables the 'dt_line_out' and 'dt_line_compl_out' signals when present. In asynchronous kill mode, STOP_EDGE should be NO_EDGE_DET. 

This field has a function in PWM and PWM_DT modes only. This field is only used when PWM_STOP_ON_KILL is '0'.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PWM_STOP_ON_KILL</name>
                <description>Specifies whether the counter stops on a kill events:
'0': kill event does NOT stop counter.
'1': kill event stops counter.

This field has a function in PWM, PWM_DT and PWM_PR modes only.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>GENERIC</name>
                <description>Generic 8-bit control field. In PWM_DT mode, this field is used to determine the dead time: amount of dead time cycles in the counter clock domain. In all other modes, the lower 3 bits of this field determine pre-scaling of the selected counter clock.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>UP_DOWN_MODE</name>
                <description>Determines counter direction.</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>COUNT_UP</name>
                    <description>Count up (to PERIOD). An overflow event is generated when the counter reaches PERIOD, and is changed to a different value. A terminal count event is generated when the counter reaches PERIOD, and is changed to a different value.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>COUNT_DOWN</name>
                    <description>Count down (to '0'). An underflow event is generated when the counter reaches '0', and is changed to a different value. A terminal count event is generated when the counter reaches '0', and is changed to a different value.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>COUNT_UPDN1</name>
                    <description>Count up (to PERIOD), then count down (to '0'). An overflow event is generated when the counter reaches PERIOD, and is changed to a different value. An underflow event is generated when the counter reaches '0', and is changed to a different value. A terminal count event is generated when the counter reaches '0', and is changed to a different value.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>COUNT_UPDN2</name>
                    <description>Count up (to PERIOD), then count down (to '0'). An overflow event is generated when the counter reaches PERIOD, and is changed to a different value. An underflow event is generated when the counter reaches '0', and is changed to a different value. A terminal count event is generated when the counter reaches '0', and is changed to a different value AND when the counter reaches PERIOD, and is changed to a different value. (this counter direction can be used for PWM functionality with asymmetrical updates).</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ONE_SHOT</name>
                <description>When '0', counter runs continuous. When '1', counter is turned off by hardware when a terminal count event is generated.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>QUADRATURE_MODE</name>
                <description>In QUAD mode selects quadrature encoding mode (X1/X2/X4).
In PWM, PWM_DT and PWM_PR modes, these two bits can be used to invert 'dt_line_out' and 'dt_line_compl_out'.  Inversion is the last step in generation of 'dt_line_out' and 'dt_line_compl_out'; i.e. a disabled output line 'dt_line_out' has the value QUADRATURE_MODE[0] and a disabled output line 'dt_line_compl_out' has the value QUADRATURE_MODE[1].</description>
                <bitRange>[21:20]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>X1</name>
                    <description>X1 encoding (QUAD mode)</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>X2</name>
                    <description>X2 encoding (QUAD mode)</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>X4</name>
                    <description>X4 encoding (QUAD mode)</description>
                    <value>2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MODE</name>
                <description>Counter mode.</description>
                <bitRange>[26:24]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>TIMER</name>
                    <description>Timer mode</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CAPTURE</name>
                    <description>Capture mode</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>QUAD</name>
                    <description>Quadrature encoding mode</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PWM</name>
                    <description>Pulse width modulation (PWM) mode</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PWM_DT</name>
                    <description>PWM with deadtime insertion mode</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PWM_PR</name>
                    <description>Pseudo random pulse width modulation</description>
                    <value>6</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>STATUS</name>
            <description>Counter status register</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x8000FF01</resetMask>
            <fields>
              <field>
                <name>DOWN</name>
                <description>When '0', counter is counting up. When '1', counter is counting down. In QUAD mode, this field indicates the direction of the latest counter change: '0' when last incremented and '1' when last decremented.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>GENERIC</name>
                <description>Generic 8-bit counter field. In PWM_DT mode, this counter is used for dead time insertion. In all other modes, this counter is used for pre-scaling the selected counter clock. PWM_DT mode can NOT use prescaled clock functionality.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RUNNING</name>
                <description>When '0', the counter is NOT running. When '1', the counter is running.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>COUNTER</name>
            <description>Counter count register</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>COUNTER</name>
                <description>16-bit counter value. It is advised to not write to this field when the counter is running.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CC</name>
            <description>Counter compare/capture register</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xFFFF</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>CC</name>
                <description>In CAPTURE mode, captures the counter value. In other modes, compared to counter value.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CC_BUFF</name>
            <description>Counter buffered compare/capture register</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xFFFF</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>CC</name>
                <description>Additional buffer for counter CC register.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PERIOD</name>
            <description>Counter period register</description>
            <addressOffset>0x14</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xFFFF</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>PERIOD</name>
                <description>Period value: upper value of the counter. When the counter should count for n cycles, this field should be set to n-1.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PERIOD_BUFF</name>
            <description>Counter buffered period register</description>
            <addressOffset>0x18</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0xFFFF</resetValue>
            <resetMask>0xFFFF</resetMask>
            <fields>
              <field>
                <name>PERIOD</name>
                <description>Additional buffer for counter PERIOD register.</description>
                <bitRange>[15:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TR_CTRL0</name>
            <description>Counter trigger control register 0</description>
            <addressOffset>0x20</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x10</resetValue>
            <resetMask>0xFFFFF</resetMask>
            <fields>
              <field>
                <name>CAPTURE_SEL</name>
                <description>Selects one of the 16 input triggers as a capture trigger. Input trigger 0 is always '0' and input trigger 1 is always '1'. Input trigger 2 is the first external trigger line (tcpwm.tr_in[0]).

In the PWM, PWM_DT and PWM_PR modes this trigger is used to switch the values if the compare and period registers with their buffer counterparts.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>COUNT_SEL</name>
                <description>Selects one of the 16 input triggers as a count trigger. In QUAD mode, this is the first phase (phi A). Default setting selects input trigger 1, which is always '1'.</description>
                <bitRange>[7:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RELOAD_SEL</name>
                <description>Selects one of the 16 input triggers as a reload trigger. In QUAD mode, this is the index or revolution pulse. In this mode, it will update the counter with the value in the TCPWM_CNTn_PERIOD register.</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>STOP_SEL</name>
                <description>Selects one of the 16 input triggers as a stop trigger. In PWM, PWM_DT and PWM_PR modes, this is the kill trigger. In these modes, the kill trigger is used to either temporarily block the PWM outputs (PWM_STOP_ON_KILL is '0') or stop the functionality (PWM_STOP_ON_KILL is '1'). For the PWM and PWM_DT modes, the blocking of the output signals can be  asynchronous (STOP_EDGE should be NO_EDGE_DET) in which case the blocking is as long as the trigger is '1' or synchronous (STOP_EDGE should be RISING_EDGE) in which case it extends till the next terminal count event.</description>
                <bitRange>[15:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>START_SEL</name>
                <description>Selects one of the 16 input triggers as a start trigger. In QUAD mode, this is the second phase (phi B).</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TR_CTRL1</name>
            <description>Counter trigger control register 1</description>
            <addressOffset>0x24</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x3FF</resetValue>
            <resetMask>0x3FF</resetMask>
            <fields>
              <field>
                <name>CAPTURE_EDGE</name>
                <description>A capture event will copy the counter value into the CC register.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <description>Rising edge. Any rising edge generates an event.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <description>Falling edge. Any falling edge generates an event.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <description>No edge detection, use trigger as is.</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>COUNT_EDGE</name>
                <description>A counter event will increase or decrease the counter by '1'.</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <description>Rising edge. Any rising edge generates an event.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <description>Falling edge. Any falling edge generates an event.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <description>No edge detection, use trigger as is.</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RELOAD_EDGE</name>
                <description>A reload event will initialize the counter. When counting up, the counter is initialized to '0'. When counting down, the counter is initialized with PERIOD.</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <description>Rising edge. Any rising edge generates an event.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <description>Falling edge. Any falling edge generates an event.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <description>No edge detection, use trigger as is.</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>STOP_EDGE</name>
                <description>A stop event, will stop the counter; i.e. it will no longer be running. Stopping will NOT disable the counter.</description>
                <bitRange>[7:6]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <description>Rising edge. Any rising edge generates an event.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <description>Falling edge. Any falling edge generates an event.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <description>No edge detection, use trigger as is.</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>START_EDGE</name>
                <description>A start event will start the counter; i.e. the counter will become running. Starting does NOT enable the counter. A start event will not initialize the counter whereas the reload event does.</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>RISING_EDGE</name>
                    <description>Rising edge. Any rising edge generates an event.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>FALLING_EDGE</name>
                    <description>Falling edge. Any falling edge generates an event.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>BOTH_EDGES</name>
                    <description>Rising AND falling edge. Any odd amount of edges generates an event.</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_EDGE_DET</name>
                    <description>No edge detection, use trigger as is.</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>TR_CTRL2</name>
            <description>Counter trigger control register 2</description>
            <addressOffset>0x28</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x3F</resetValue>
            <resetMask>0x3F</resetMask>
            <fields>
              <field>
                <name>CC_MATCH_MODE</name>
                <description>Determines the effect of a compare match event (COUNTER equals CC register) on the 'line_out' output signals.  Note that INVERT is especially useful for center aligned pulse width modulation.
To generate a duty cycle of 0 percent, the counter CC register should be set to '0'. For a 100 percent duty cycle, the counter CC register should be set to larger than the counter PERIOD register.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>SET</name>
                    <description>Set to '1'</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLEAR</name>
                    <description>Set to '0'</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INVERT</name>
                    <description>Invert</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_CHANGE</name>
                    <description>No Change</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>OVERFLOW_MODE</name>
                <description>Determines the effect of a counter overflow event (COUNTER reaches PERIOD) on the 'line_out' output signals.</description>
                <bitRange>[3:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>SET</name>
                    <description>Set to '1'</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLEAR</name>
                    <description>Set to '0'</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INVERT</name>
                    <description>Invert</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_CHANGE</name>
                    <description>No Change</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>UNDERFLOW_MODE</name>
                <description>Determines the effect of a counter underflow event (COUNTER reaches '0') on the 'line_out' output signals.</description>
                <bitRange>[5:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>SET</name>
                    <description>Set to '1'</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLEAR</name>
                    <description>Set to '0'</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>INVERT</name>
                    <description>Invert</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>NO_CHANGE</name>
                    <description>No Change</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Interrupt request register.</description>
            <addressOffset>0x30</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>TC</name>
                <description>Terminal count event. Set to '1', when event is detected. Write with '1' to clear bit.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CC_MATCH</name>
                <description>Counter matches CC register event. Set to '1', when event is detected. Write with '1' to clear bit.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt set request register.</description>
            <addressOffset>0x34</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>TC</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CC_MATCH</name>
                <description>Write with '1' to set corresponding bit in interrupt request register.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt mask register.</description>
            <addressOffset>0x38</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>TC</name>
                <description>Mask bit for corresponding bit in interrupt request register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CC_MATCH</name>
                <description>Mask bit for corresponding bit in interrupt request register.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt masked request register</description>
            <addressOffset>0x3C</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3</resetMask>
            <fields>
              <field>
                <name>TC</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>CC_MATCH</name>
                <description>Logical and of corresponding request and mask bits.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>SCB0</name>
      <description>Serial Communications Block (SPI/UART/I2C)</description>
      <headerStructName>SCB</headerStructName>
      <baseAddress>0x40240000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTRL</name>
          <description>Generic control register.</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x300000F</resetValue>
          <resetMask>0x83031F0F</resetMask>
          <fields>
            <field>
              <name>OVS</name>
              <description>N/A</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EC_AM_MODE</name>
              <description>This field specifies the clocking for the address matching (I2C) or slave selection detection logic (SPI)
'0': Internally clocked mode 
'1': Externally clocked mode 

In internally clocked mode, the serial interface protocols run off the SCB clock. In externally clocked mode, the serial interface protocols run off the clock as provided by the serial interface.

The clocking for the rest of the logic is determined by CTRL.EC_OP_MODE.

Externally clocked mode is only used for synchronous serial interface protocols (SPI and I2C) in slave mode. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported.

In UART mode this field should be '0'.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EC_OP_MODE</name>
              <description>This field specifies the clocking for the SCB block
'0': Internally clocked mode 
'1': externally clocked mode
 In internally clocked mode, the serial interface protocols run off the SCB clock. In externally clocked mode, the serial interface protocols run off the clock as provided by the serial interface. 

Externally clocked operation mode is only used for synchronous serial interface protocols (SPI and I2C) in slave mode AND EZ mode. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported. The maximum SPI slave, EZ mode bitrate is 48 Mbps (transmission and IO delays outside the IP will degrade the effective bitrate).

In UART mode this field should be '0'.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_MODE</name>
              <description>Non EZ mode ('0') or EZ mode ('1').
In EZ mode, a meta protocol is applied to the serial interface protocol. This meta protocol adds meaning to the data frames transferred by the serial interface protocol: a data frame can represent a memory address, a write memory data element or a read memory data element. EZ mode is only used for synchronous serial interface protocols: SPI and I2C. In SPI mode, only Motorola submode (all Motorola modes: 0, 1, 2, 3) is supported and the transmitter should use continuous data frames; i.e. data frames not separated by slave deselection. This mode is only applicable to slave functionality. In EZ mode, the slave can read from and write to an addressable memory structure of 32 bytes. In EZ mode, data frames should 8-bit in size and should be transmitted and received with the Most Significant Bit (MSB) first.

In UART mode this field should be '0'.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BYTE_MODE</name>
              <description>N/A</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMD_RESP_MODE</name>
              <description>N/A</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADDR_ACCEPT</name>
              <description>Determines whether a received matching address is accepted in the RX FIFO ('1') or not ('0').

In I2C mode, this field is used to allow the slave to put the received slave address or general call address in the RX FIFO. Note that a received matching address is put in the RX FIFO when this bit is '1' for both I2C read and write transfers.

In multi-processor UART receiver mode, this field is used to allow the receiver to put the received address in the RX FIFO. Note: non-matching addresses are never put in the RX FIFO.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCK</name>
              <description>Only used in externally clocked mode. If the externally clocked logic and the internal CPU accesses to EZ memory coincide/collide, this bit determines whether the CPU access should block and result in bus wait states ('BLOCK is 1') or not (BLOCK is '0'). IF BLOCK is '0' and the accesses collide, CPU read operations return 0xffff:ffff and CPU write operations are ignored. Colliding accesses are registered as interrupt causes: INTR_TX.BLOCKED and INTR_RX.BLOCKED.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>N/A</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>I2C</name>
                  <description>Inter-Integrated Circuits (I2C) mode.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SPI</name>
                  <description>Serial Peripheral Interface (SPI) mode.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART</name>
                  <description>Universal Asynchronous Receiver/Transmitter (UART) mode.</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENABLED</name>
              <description>SCB block is enabled ('1') or not ('0'). The proper order in which to initialize SCB is as follows:
- Program protocol specific information using SPI_CTRL, UART_CTRL (and UART_TX_CTRL and UART_RX_CTRL) or I2C_CTRL registers. This includes selection of a submode, master/slave functionality and transmitter/receiver functionality when applicable.
- Program generic transmitter (TX_CTRL) and receiver (RX_CTRL) information. This includes enabling of the transmitter and receiver functionality.
- Program transmitter FIFO (TX_FIFO_CTRL) and receiver FIFO (RX_FIFO_CTRL) information.
- Program CTRL register to enable SCB, select the specific operation mode and oversampling factor.
When this block is enabled, no control information should be changed. Changes should be made AFTER disabling this block, e.g. to modify the operation mode (from I2C to SPI) or to go from externally to internally clocked. The change takes effect after the block is re-enabled. Note that disabling the block will cause re-initialization of the design and associated state is lost (e.g. FIFO content).</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Generic status register.</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>EC_BUSY</name>
              <description>Indicates whether the externally clocked logic is potentially accessing the EZ memory (this is only possible in EZ mode). This bit can be used by SW to determine whether it is safe to issue a SW access to the EZ memory (without bus wait states (a blocked SW access) or bus errors being generated). Note that the INTR_TX.BLOCKED and INTR_RX.BLOCKED interrupt causes are used to indicate whether a SW access was actually blocked by externally clocked logic.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD_RESP_CTRL</name>
          <description>Command/response control register.</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1FF01FF</resetMask>
          <fields>
            <field>
              <name>BASE_RD_ADDR</name>
              <description>I2C/SPI read base address for CMD_RESP mode. At the start of a read transfer this BASE_RD_ADDR is copied to CMD_RESP_STATUS.CURR_RD_ADDR. This field should not be modified during ongoing bus transfers.</description>
              <bitRange>[8:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BASE_WR_ADDR</name>
              <description>I2C/SPI write base address for CMD_RESP mode. At the start of a write transfer this BASE_WR_ADDR is copied to CMD_RESP_STATUS.CURR_WR_ADDR. This field should not be modified during ongoing bus transfers.</description>
              <bitRange>[24:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CMD_RESP_STATUS</name>
          <description>Command/response status register.</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>CURR_RD_ADDR</name>
              <description>I2C/SPI read current address for CMD_RESP mode. HW increments the field after a read access to the memory buffer. However, when the last memory buffer address is reached, the address is NOT incremented (but remains at the maximum memory buffer address). 

The field is used to determine how many bytes have been read (# bytes = CURR_RD_ADDR - CMD_RESP_CTRL.BASE_RD_ADDR). 

This field is reliable when there is no bus transfer. This field is potentially unreliable when there is a ongoing bus transfer, i.e. when CMD_RESP_EC_BUSY is '0', the field is reliable.</description>
              <bitRange>[8:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CURR_WR_ADDR</name>
              <description>I2C/SPI write current address for CMD_RESP mode. HW increments the field after a write access to the memory buffer. However, when the last memory buffer address is reached, the address is NOT incremented (but remains at the maximum memory buffer address).

The field is used to determine how many bytes have been written (# bytes = CURR_WR_ADDR - CMD_RESP_CTRL.BASE_WR_ADDR).

This field is reliable when there is no bus transfer. This field is potentially unreliable when there is a ongoing bus transfer, i.e. when CMD_RESP_EC_BUSY is '0', the field is reliable.</description>
              <bitRange>[24:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CMD_RESP_EC_BUS_BUSY</name>
              <description>Indicates whether there is an ongoing bus transfer to the IP.
'0': no ongoing bus transfer.
'1': ongoing bus transfer.

For SPI, the field is '1' when slave mode is selected.

For I2C, the field is set to '1' at a I2C START/RESTART. In case of an address match, the  field is set to '0' on a I2C STOP. In case of NO address match, the field is set to '0' after the failing address match.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CMD_RESP_EC_BUSY</name>
              <description>N/A</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_CTRL</name>
          <description>SPI control register.</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3000000</resetValue>
          <resetMask>0x8F010F3F</resetMask>
          <fields>
            <field>
              <name>CONTINUOUS</name>
              <description>Continuous SPI data transfers enabled ('1') or not ('0'). This field is used in master mode. In slave mode, both continuous and non-continuous SPI data transfers are supported independent of this field.

When continuous transfers are enabled individual data frame transfers are not necessarily separated by slave deselection (as indicated by the level or pulse on the SELECT line): if the TX FIFO has multiple data frames, data frames are send out without slave deselection.

When continuous transfers are not enabled individual data frame transfers are always separated by slave deselection: independent of the availability of TX FIFO data frames, data frames are sent out with slave deselection.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SELECT_PRECEDE</name>
              <description>Only used in SPI Texas Instruments' submode.

When '1', the data frame start indication is a pulse on the Slave SELECT line that precedes the transfer of the first data frame bit.

When '0', the data frame start indication is a pulse on the Slave SELECT line that coincides with the transfer of the first data frame bit.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPHA</name>
              <description>N/A</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CPOL</name>
              <description>N/A</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LATE_MISO_SAMPLE</name>
              <description>Changes the SCLK edge on which MISO is captured. Only used in master mode.

When '0', the default applies (
for Motorola as determined by CPOL and CPHA, 
for Texas Instruments on the falling edge of SCLK and 
for National Semiconductors on the rising edge of SCLK). 

When '1', the alternate clock edge is used (which comes half a SPI SCLK period later). Late sampling addresses the round trip delay associated with transmitting SCLK from the master to the slave and transmitting MISO from the slave to the master.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCLK_CONTINUOUS</name>
              <description>N/A</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY0</name>
              <description>N/A</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY1</name>
              <description>N/A</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY2</name>
              <description>N/A</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SSEL_POLARITY3</name>
              <description>N/A</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOOPBACK</name>
              <description>Local loopback control (does NOT affect the information on the pins). Only used in master mode. Not used in National Semiconductors submode.
'0': No local loopback
'1': the SPI master MISO line is connected to the SPI master MOSI line. In other words, in loopback mode the SPI master receives on MISO what it transmits on MOSI.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>N/A</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SPI_MOTOROLA</name>
                  <description>SPI Motorola submode. In master mode, when not transmitting data (SELECT is inactive), SCLK is stable at CPOL. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), SELECT is inactive.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SPI_TI</name>
                  <description>SPI Texas Instruments submode. In master mode, when not transmitting data, SCLK is stable at '0'. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), SELECT is inactive; i.e. no pulse is generated.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SPI_NS</name>
                  <description>SPI National Semiconductors submode. In master mode, when not transmitting data, SCLK is stable at '0'. In slave mode, when not selected, SCLK is ignored; i.e. it can be either stable or clocking. In master mode, when there is no data to transmit (TX FIFO is empty), SELECT is inactive.</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SLAVE_SELECT</name>
              <description>Selects one of the four outgoing SPI slave select signals:
- 0: Slave 0, SPI_SELECT[0].
- 1: Slave 1, SPI_SELECT[1].
- 2: Slave 2, SPI_SELECT[2].
- 3: Slave 3, SPI_SELECT[3].
Only used in master mode. SCB block should be disabled when changes are made to this field.</description>
              <bitRange>[27:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASTER_MODE</name>
              <description>N/A</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SPI_STATUS</name>
          <description>SPI status register.</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>BUS_BUSY</name>
              <description>SPI bus is busy. The bus is considered busy ('1') during an ongoing transaction. For Motorola and National submodes, the busy bit is '1', when the slave selection (low active) is activated. For TI submode, the busy bit is '1' from the time the preceding/coinciding slave select (high active) is activated for the first transmitted data frame, till the last MOSI/MISO bit of the last data frame is transmitted.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_EC_BUSY</name>
              <description>Indicates whether the externally clocked logic is potentially accessing the EZ memory and/or updating BASE_ADDR or CURR_ADDR (this is only possible in EZ mode). This bit can be used by SW to determine whether BASE_ADDR and CURR_ADDR are reliable.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CURR_EZ_ADDR</name>
              <description>SPI current EZ address. Current address pointer. This field is only reliable in internally clocked mode. In externally clocked mode the field may be unreliable (during an ongoing transfer when SPI_EC_BUSY is '1'), as clock domain synchronization is not performed in the design.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BASE_EZ_ADDR</name>
              <description>SPI base EZ address. Address as provided by a SPI write transfer. This field is only reliable in internally clocked mode. In externally clocked mode the field may be unreliable, as clock domain synchronization is not performed in the design.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_CTRL</name>
          <description>UART control register.</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x3000000</resetValue>
          <resetMask>0x3010000</resetMask>
          <fields>
            <field>
              <name>LOOPBACK</name>
              <description>Local loopback control (does NOT affect the information on the pins). 
0: Loopback is not enabled
1: UART_TX is connected to UART_RX. UART_RTS is connected to UART_CTS.
This allows a SCB UART transmitter to communicate with its receiver counterpart.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>N/A</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>UART_STD</name>
                  <description>Standard UART submode.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART_SMARTCARD</name>
                  <description>SmartCard (ISO7816) submode. Support for negative acknowledgement (NACK) on the receiver side and retransmission on the transmitter side.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UART_IRDA</name>
                  <description>Infrared Data Association (IrDA) submode. Return to Zero modulation scheme. In this mode, the oversampling factor should be 16, that is OVS is 15.</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_TX_CTRL</name>
          <description>UART transmitter control register.</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2</resetValue>
          <resetMask>0x137</resetMask>
          <fields>
            <field>
              <name>STOP_BITS</name>
              <description>Stop bits. STOP_BITS + 1 is the duration of the stop period in terms of halve bit periods. Valid range is [1, 7]; i.e. a stop period should last at least one bit period.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>Parity bit. When '0', the transmitter generates an even parity. When '1', the transmitter generates an odd parity. Only applicable in standard UART and SmartCard submodes.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ENABLED</name>
              <description>Parity generation enabled ('1') or not ('0'). Only applicable in standard UART submodes. In SmartCard submode, parity generation is always enabled through hardware. In IrDA submode, parity generation is always disabled through hardware</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RETRY_ON_NACK</name>
              <description>When '1', a data frame is retransmitted when a negative acknowledgement is received. Only applicable to the SmartCard submode.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_RX_CTRL</name>
          <description>UART receiver control register.</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xA0002</resetValue>
          <resetMask>0xF3777</resetMask>
          <fields>
            <field>
              <name>STOP_BITS</name>
              <description>N/A</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY</name>
              <description>N/A</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ENABLED</name>
              <description>N/A</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POLARITY</name>
              <description>Inverts incoming RX line signal. Inversion is after local loopback. This functionality is intended for IrDA receiver functionality.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DROP_ON_PARITY_ERROR</name>
              <description>Behavior when a parity check fails. 
When '0', received data is sent to the RX FIFO. 
When '1', received data is dropped and lost. 
Only applicable in standard UART and SmartCard submodes (negatively acknowledged SmartCard data frames may be dropped with this field).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DROP_ON_FRAME_ERROR</name>
              <description>Behavior when an error is detected in a start or stop period. 
When '0', received data is sent to the RX FIFO.
 When '1', received data is dropped and lost.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MP_MODE</name>
              <description>N/A</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LIN_MODE</name>
              <description>Only applicable in standard UART submode. When '1', the receiver performs break detection and baud rate detection on the incoming data. First, break detection counts the amount of bit periods that have a line value of '0'. BREAK_WIDTH specifies the minimum required amount of bit periods. Successful break detection sets the INTR_RX.BREAK_DETECT interrupt cause to '1'. Second, baud rate detection counts the amount of peripheral clock periods that are use to receive the synchronization byte (0x55; least significant bit first). The count is available through UART_RX_STATUS.BR_COUNTER. Successful baud rate detection sets the INTR_RX.BAUD_DETECT interrupt cause to '1' (BR_COUNTER is reliable). This functionality is used to synchronize/refine the receiver clock to the transmitter clock. The receiver software can use the BR_COUNTER value to set the right IP clock (from the programmable clock IP) to guarantee successful receipt of the first LIN data frame (Protected Identifier Field) after the synchronization byte.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SKIP_START</name>
              <description>N/A</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_WIDTH</name>
              <description>N/A</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_RX_STATUS</name>
          <description>UART receiver status register.</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>BR_COUNTER</name>
              <description>Amount of SCB clock periods that constitute the transmission of a 0x55 data frame (sent least significant bit first) as determined by the receiver. BR_COUNTER / 8 is the amount of SCB clock periods that constitute a bit period. This field has valid data when INTR_RX.BAUD_DETECT is set to '1'.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>UART_FLOW_CTRL</name>
          <description>UART flow control register</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x30100FF</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>Trigger level. When the receiver FIFO has less entries than the amount of this field, a Ready To Send (RTS) output signal is activated. By setting this field to '0', flow control is effectively disabled (may be useful for debug purposes).</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RTS_POLARITY</name>
              <description>Polarity of the RTS output signal:
'0': RTS is active low; 
'1': RTS is active high; 

During SCB reset (Hibernate system power mode), RTS output signal is '1'. This represents an inactive state assuming an active low polarity.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTS_POLARITY</name>
              <description>Polarity of the CTS input signal
'0': CTS is active low ; 
'1': CTS is active high;</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CTS_ENABLED</name>
              <description>Enable use of CTS input signal by the UART transmitter:
'0': Disabled. The UART transmitter ignores the CTS input signal and transmits when a data frame is available for transmission in the TX FIFO or the TX shift register.
'1': Enabled. The UART transmitter uses CTS input signal to qualify the transmission of data. It transmits when CTS input signal is active and a data frame is available for transmission in the TX FIFO or the TX shift register.

If UART_CTRL.LOOPBACK is '1', the CTS input signal is driven by the RTS output signal locally in SCB (both signals are subjected to signal polarity changes as indicated by RTS_POLARITY and CTS_POLARITY).</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_CTRL</name>
          <description>I2C control register.</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xFB88</resetValue>
          <resetMask>0xC001FBFF</resetMask>
          <fields>
            <field>
              <name>HIGH_PHASE_OVS</name>
              <description>Serial I2C interface high phase oversampling factor. HIGH_PHASE_OVS + 1 SCB clock periods constitute the high phase of a bit period. The valid range is [5, 15] with input signal median filtering and [4, 15] without input signal median filtering.

The field is only used in master mode. In slave mode, the field is NOT used. However, there is a frequency requirement for the SCB clock wrt. the regular interface (IF) high time to guarantee functional correct behavior. With input signal median filtering, the IF high time should be &gt;= 6 SCB clock cycles and &lt;= 16 SCB clock cycles. Without input signal median filtering, the IF high time should be &gt;= 5 SCB clock cycles and &lt;= 16 SCB clock cycles.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOW_PHASE_OVS</name>
              <description>Serial I2C interface low phase oversampling factor. LOW_PHASE_OVS + 1 SCB clock periods constitute the low phase of a bit period. The valid range is [7, 15] with input signal median filtering and [6, 15] without input signal median filtering. 

The field is only used in master mode. In slave mode, the field is NOT used. However, there is a frequency requirement for the SCB clock wrt. the regular (no stretching) interface (IF) low time to guarantee functionally correct behavior. With input signal median filtering, the IF low time should be &gt;= 8 SCB clock cycles and &lt;= 16 IP clock cycles. Without input signal median filtering, the IF low time should be &gt;= 7 SCB clock cycles and &lt;= 16 SCB clock cycles.</description>
              <bitRange>[7:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_READY_DATA_ACK</name>
              <description>N/A</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_NOT_READY_DATA_NACK</name>
              <description>N/A</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_GENERAL_IGNORE</name>
              <description>N/A</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_READY_ADDR_ACK</name>
              <description>N/A</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_READY_DATA_ACK</name>
              <description>N/A</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_NOT_READY_ADDR_NACK</name>
              <description>This field is used during an address match or general call address in internally clocked mode 
Only used when:
 - EC_AM_MODE is '0', EC_OP_MODE is '0', S_GENERAL_IGNORE is '0] and non EZ mode.
Functionality is as follows:
- 1: a received (matching) slave address is immediately NACK'd when the receiver FIFO is full.
- 0: clock stretching is performed (till the receiver FIFO is no longer full). 

For externally clocked logic (EC_AM is '1') on an address match or general call address (and S_GENERAL_IGNORE is '0'). Only used when (NOT used when EC_AM is '1' and EC_OP is '1' and address match and EZ mode):
- EC_AM is '1' and EC_OP is '0'.
- EC_AM is '1' and general call address match.
- EC_AM is '1' and non EZ mode.
Functionality is as follows:
- 1: a received (matching or general) slave address is always immediately NACK'd. There are two possibilities:
       1). the SCB clock is available (in Active system power mode) and it handles the rest of the current transfer. In this case the I2C master will not observe the NACK. 
       2).SCB clock is not present (in DeepSleep system power mode). In this case the I2C master will observe the NACK and may retry the transfer in the future (which gives the internally clocked logic the time to wake up from DeepSleep system power mode). 
- 0: clock stretching is performed (till the SCB clock is available). The logic will handle the ongoing transfer as soon as the clock is enabled.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_NOT_READY_DATA_NACK</name>
              <description>Only used when:
- non EZ mode
Functionality is as follows:
- 1: a received data element byte the slave is immediately NACK'd when the receiver FIFO is full.
- 0: clock stretching is performed (till the receiver FIFO is no longer full).</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LOOPBACK</name>
              <description>Local loopback control (does NOT affect the information on the pins). Only applicable in master/slave mode. 
When '0', no loopback
When '1', loopback is enabled internally in the peripheral, and as a result unaffected by other I2C devices. This allows a SCB I2C peripheral to address itself.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SLAVE_MODE</name>
              <description>N/A</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASTER_MODE</name>
              <description>N/A</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_STATUS</name>
          <description>I2C status register.</description>
          <addressOffset>0x64</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x31</resetMask>
          <fields>
            <field>
              <name>BUS_BUSY</name>
              <description>I2C bus is busy. The bus is considered busy ('1'), from the time a START is detected or from the time the SCL line is '0'. The bus is considered idle ('0'), from the time a STOP is detected. If SCB block is disabled, BUS_BUSY is '0'. After enabling the block, it takes time for the BUS_BUSY to detect a busy bus. This time is the maximum high time of the SCL line. For a 100 kHz interface frequency, this maximum high time may last roughly 5 us (half a bit period).

For single master systems, BUS_BUSY does not have to be used to detect an idle bus before a master starts a transfer using I2C_M_CMD.M_START (no bus collisions).

For multi-master systems, BUS_BUSY can be used to detect an idle bus before a master starts a transfer using I2C_M_CMD.M_START_ON_IDLE (to prevent bus collisions).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_EC_BUSY</name>
              <description>N/A</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>S_READ</name>
              <description>N/A</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>M_READ</name>
              <description>N/A</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CURR_EZ_ADDR</name>
              <description>N/A</description>
              <bitRange>[15:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BASE_EZ_ADDR</name>
              <description>N/A</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_M_CMD</name>
          <description>I2C master command register.</description>
          <addressOffset>0x68</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>M_START</name>
              <description>When '1', transmit a START or REPEATED START. Whether a START or REPEATED START is transmitted depends on the state of the master state machine. A START is only transmitted when the master state machine is in the default state. A REPEATED START is transmitted when the master state machine is not in the default state, but is working on an ongoing transaction. The REPEATED START can only be transmitted after a NACK or ACK has been received for a transmitted data element or after a NACK has been transmitted for a received data element. When this action is performed, the hardware sets this field to '0'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_START_ON_IDLE</name>
              <description>When '1', transmit a START as soon as the bus is idle (I2C_STATUS.BUS_BUSY is '0', note that BUSY has a default value of '0'). For bus idle detection the hardware relies on STOP detection. As a result, bus idle detection is only functional after at least one I2C bus transfer has been detected on the bus (default/reset value of BUSY is '0') . A START is only transmitted when the master state machine is in the default state. When this action is performed, the hardware sets this field to '0'.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_ACK</name>
              <description>When '1', attempt to transmit an acknowledgement (ACK). When this action is performed, the hardware sets this field to '0'.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_NACK</name>
              <description>When '1', attempt to transmit a negative acknowledgement (NACK). When this action is performed, the hardware sets this field to '0'.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>M_STOP</name>
              <description>When '1', attempt to transmit a STOP. When this action is performed, the hardware sets this field to '0'. 
 I2C_M_CMD.M_START has a higher priority than this command: in situations where both a STOP and a REPEATED START could be transmitted, M_START takes precedence over M_STOP.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_S_CMD</name>
          <description>I2C slave command register.</description>
          <addressOffset>0x6C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>S_ACK</name>
              <description>When '1', attempt to transmit an acknowledgement (ACK). When this action is performed, the hardware sets this field to '0'. In EZ mode, this field should be set to '0' (it is only to be used in non EZ mode).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>S_NACK</name>
              <description>When '1', attempt to transmit a negative acknowledgement (NACK). When this action is performed, the hardware sets this field to '0'.  In EZ mode, this field should be set to '0' (it is only to be used in non EZ mode). This command has a higher priority than I2C_S_CMD.S_ACK, I2C_CTRL.S_READY_ADDR_ACK or I2C_CTRL.S_READY_DATA_ACK.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>I2C_CFG</name>
          <description>I2C configuration register.</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2A1013</resetValue>
          <resetMask>0x303F1313</resetMask>
          <fields>
            <field>
              <name>SDA_IN_FILT_TRIM</name>
              <description>Trim settings for the 50ns glitch filter on the SDA input. Default setting meets the I2C glitch rejections specs. Programmability available if required</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_IN_FILT_SEL</name>
              <description>Enable for 50ns glitch filter on SDA input
'0': 0 ns.
'1: 50 ns (filter enabled).</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCL_IN_FILT_TRIM</name>
              <description>Trim settings for the 50ns glitch filter on the SCL input. Default setting meets the I2C glitch rejections specs. Programmability available if required</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCL_IN_FILT_SEL</name>
              <description>Enable for 50ns glitch filter on SCL input
'0': 0 ns.
'1: 50 ns (filter enabled).</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT0_TRIM</name>
              <description>Trim settings for the 50ns delay filter on SDA output used to guarantee tHD_DAT I2C parameter. Default setting meets the I2C spec. Programmability available if required</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT1_TRIM</name>
              <description>Trim settings for the 50ns delay filter on SDA output used to guarantee tHD_DAT I2C parameter. Default setting meets the I2C spec. Programmability available if required</description>
              <bitRange>[19:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT2_TRIM</name>
              <description>Trim settings for the 50ns delay filter on SDA output used to guarantee tHD_DAT I2C parameter. Default setting meets the I2C spec. Programmability available if required</description>
              <bitRange>[21:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SDA_OUT_FILT_SEL</name>
              <description>Selection of cumulative filter delay on SDA output to meet tHD_DAT parameter
'0': 0 ns.
'1': 50 ns (filter 0 enabled).
'2': 100 ns (filters 0 and 1 enabled).
'3': 150 ns (filters 0, 1 and 2 enabled).</description>
              <bitRange>[29:28]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_CTRL</name>
          <description>Transmitter control register.</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x107</resetValue>
          <resetMask>0x10F</resetMask>
          <fields>
            <field>
              <name>DATA_WIDTH</name>
              <description>Dataframe width. DATA_WIDTH + 1 is the amount of bits in a transmitted data frame. This number does not include start, parity and stop bits. For UART mode, the valid range is [3, 8]. For SPI, the valid range is [3, 15]. For I2C the only valid value is 7.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MSB_FIRST</name>
              <description>Least significant bit first ('0') or most significant bit first ('1'). For I2C, this field should be '1'.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_FIFO_CTRL</name>
          <description>Transmitter FIFO control register.</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x300FF</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>Trigger level. When the transmitter FIFO has less entries than the number of this field, a transmitter trigger event INTR_TX.TRIGGER is generated.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLEAR</name>
              <description>When '1', the transmitter FIFO and transmitter shift register are cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FREEZE</name>
              <description>When '1', hardware reads from the transmitter FIFO do not remove FIFO entries. Freeze will not advance the TX FIFO read pointer.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_FIFO_STATUS</name>
          <description>Transmitter FIFO status register.</description>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF81FF</resetMask>
          <fields>
            <field>
              <name>USED</name>
              <description>Amount of entries in the transmitter FIFO. The value of this field ranges from 0 to FF_DATA_NR (EZ_DATA_NR/2).</description>
              <bitRange>[8:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SR_VALID</name>
              <description>Indicates whether the TX shift registers holds a valid data frame ('1') or not ('0'). The shift register can be considered the top of the TX FIFO (the data frame is not included in the USED field of the TX FIFO). The shift register is a working register and holds the data frame that is currently transmitted (when the protocol state machine is transmitting a data frame) or the data frame that is transmitted next (when the protocol state machine is not transmitting a data frame).</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_PTR</name>
              <description>FIFO read pointer: FIFO location from which a data frame is read by the hardware.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PTR</name>
              <description>FIFO write pointer: FIFO location at which a new data frame is written.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TX_FIFO_WR</name>
          <description>Transmitter FIFO write register.</description>
          <addressOffset>0x240</addressOffset>
          <size>32</size>
          <access>write-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data frame written into the transmitter FIFO. Behavior is similar to that of a PUSH operation. Note that when CTRL.BYTE_MODE is '1', only DATA[7:0] are used.

A write to a full TX FIFO sets INTR_TX.OVERFLOW to '1'.</description>
              <bitRange>[15:0]</bitRange>
              <access>write-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_CTRL</name>
          <description>Receiver control register.</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x107</resetValue>
          <resetMask>0x30F</resetMask>
          <fields>
            <field>
              <name>DATA_WIDTH</name>
              <description>Dataframe width. DATA_WIDTH + 1 is the expected amount of bits in received data frame. This number does not include start, parity and stop bits. For UART mode, the valid range is [3, 8]. For SPI, the valid range is [3, 15]. For I2C the only valid value is 7. In EZ mode (for both SPI and I2C), the only valid value is 7.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MSB_FIRST</name>
              <description>Least significant bit first ('0') or most significant bit first ('1'). For I2C, this field should be '1'.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MEDIAN</name>
              <description>Median filter. When '1', a digital 3 taps median filter is performed on input interface lines. This filter should reduce the susceptibility to errors. However, its requires higher oversampling values. For UART IrDA submode, this field should always be '1'.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_CTRL</name>
          <description>Receiver FIFO control register.</description>
          <addressOffset>0x304</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x300FF</resetMask>
          <fields>
            <field>
              <name>TRIGGER_LEVEL</name>
              <description>Trigger level. When the receiver FIFO has more entries than the number of this field, a receiver trigger event INTR_RX.TRIGGER is generated.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CLEAR</name>
              <description>When '1', the receiver FIFO and receiver shift register are cleared/invalidated. Invalidation will last for as long as this field is '1'. If a quick clear/invalidation is required, the field should be set to '1' and be followed by a set to '0'. If a clear/invalidation is required for an extended time period, the field should be set to '1' during the complete time period.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FREEZE</name>
              <description>When '1', hardware writes to the receiver FIFO have no effect. Freeze will not advance the RX FIFO write pointer.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_STATUS</name>
          <description>Receiver FIFO status register.</description>
          <addressOffset>0x308</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF81FF</resetMask>
          <fields>
            <field>
              <name>USED</name>
              <description>Amount of entries in the receiver FIFO. The value of this field ranges from 0 to FF_DATA_NR (EZ_DATA_NR/2).</description>
              <bitRange>[8:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SR_VALID</name>
              <description>Indicates whether the RX shift registers holds a (partial) valid data frame ('1') or not ('0'). The shift register can be considered the bottom of the RX FIFO (the data frame is not included in the USED field of the RX FIFO). The shift register is a working register and holds the data frame that is currently being received (when the protocol state machine is receiving a data frame).</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_PTR</name>
              <description>FIFO read pointer: FIFO location from which a data frame is read.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PTR</name>
              <description>FIFO write pointer: FIFO location at which a new data frame is written by the hardware.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_MATCH</name>
          <description>Slave address and mask register.</description>
          <addressOffset>0x310</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF00FF</resetMask>
          <fields>
            <field>
              <name>ADDR</name>
              <description>N/A</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MASK</name>
              <description>Slave device address mask. This field is a mask that specifies which of the slave address bits take part in the matching. MATCH = ((ADDR &amp; MASK) == ('slave address' &amp; MASK)).</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_RD</name>
          <description>Receiver FIFO read register.</description>
          <addressOffset>0x340</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data read from the receiver FIFO. Reading a data frame will remove the data frame from the FIFO; i.e. behavior is similar to that of a POP operation. Note that when CTRL.BYTE_MODE is '1', only DATA[7:0] are used.

A read from an empty RX FIFO sets INTR_RX.UNDERFLOW to '1'.

When this register is read through the debugger, the data frame will not be removed from the FIFO. Similar in operation to RX_FIFO_RD_SILENT</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RX_FIFO_RD_SILENT</name>
          <description>Receiver FIFO read register.</description>
          <addressOffset>0x344</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x0</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Data read from the receiver FIFO. Reading a data frame will NOT remove the data frame from the FIFO; i.e. behavior is similar to that of a PEEK operation. Note that when CTRL.BYTE_MODE is '1', only DATA[7:0] are used.

A read from an empty RX FIFO sets INTR_RX.UNDERFLOW to '1'.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_CAUSE</name>
          <description>Active clocked interrupt signal register</description>
          <addressOffset>0xE00</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>M</name>
              <description>Master interrupt active ('interrupt_master'): INTR_M_MASKED != 0.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>S</name>
              <description>Slave interrupt active ('interrupt_slave'): INTR_S_MASKED != 0.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>TX</name>
              <description>Transmitter interrupt active ('interrupt_tx'): INTR_TX_MASKED != 0.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RX</name>
              <description>Receiver interrupt active ('interrupt_rx'): INTR_RX_MASKED != 0.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_EC</name>
              <description>Externally clock I2C interrupt active ('interrupt_i2c_ec'): INTR_I2C_EC_MASKED != 0.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_EC</name>
              <description>Externally clocked SPI interrupt active ('interrupt_spi_ec'): INTR_SPI_EC_MASKED != 0.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_I2C_EC</name>
          <description>Externally clocked I2C interrupt request register</description>
          <addressOffset>0xE80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Wake up request. Active on incoming slave request (with address match).

Only used when CTRL.EC_AM_MODE is '1'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>STOP detection. Activated on the end of a every transfer (I2C STOP).

Only available for a slave request with an address match, in EZ and CMD_RESP modes, when CTRL.EC_OP_MODE is '1'.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>STOP detection after a write transfer occurred. Activated on the end of a write transfer (I2C STOP). This event is an indication that a buffer memory location has been written to. For EZ mode: a  transfer that only writes the base address does NOT activate this event. 

Only available for a slave request with an address match, in EZ and CMD_RESP modes, when CTRL.EC_OP_MODE is '1'.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>STOP detection after a read transfer occurred. Activated on the end of a read transfer (I2C STOP). This event is an indication that a buffer memory location has been read from.

Only available for a slave request with an address match, in EZ and CMD_RESP modes, when CTRL.EC_OP_MODE is '1'.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_I2C_EC_MASK</name>
          <description>Externally clocked I2C interrupt mask register</description>
          <addressOffset>0xE88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_I2C_EC_MASKED</name>
          <description>Externally clocked I2C interrupt masked register</description>
          <addressOffset>0xE8C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SPI_EC</name>
          <description>Externally clocked SPI interrupt request register</description>
          <addressOffset>0xEC0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Wake up request. Active on incoming slave request when externally clocked selection is '1'.

Only used when CTRL.EC_AM_MODE is '1'.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>STOP detection. Activated on the end of a every transfer (SPI deselection).

Only available in EZ and CMD_RESP mode and when CTRL.EC_OP_MODE is '1'.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>STOP detection after a write transfer occurred. Activated on the end of a write transfer (SPI deselection). This event is an indication that a buffer memory location has been written to. For EZ mode: a  transfer that only writes the base address does NOT activate this event. 

Only used in EZ and CMD_RESP modes and when CTRL.EC_OP_MODE is '1'.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>STOP detection after a read transfer occurred. Activated on the end of a read transfer (SPI deselection). This event is an indication that a buffer memory location has been read from.

Only used in EZ and CMD_RESP modes and when CTRL.EC_OP_MODE is '1'.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SPI_EC_MASK</name>
          <description>Externally clocked SPI interrupt mask register</description>
          <addressOffset>0xEC8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SPI_EC_MASKED</name>
          <description>Externally clocked SPI interrupt masked register</description>
          <addressOffset>0xECC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>WAKE_UP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_WRITE_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EZ_READ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_M</name>
          <description>Master interrupt request register.</description>
          <addressOffset>0xF00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x317</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>I2C master lost arbitration: the value driven by the master on the SDA line is not the same as the value observed on the SDA line.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>I2C master negative acknowledgement. Set to '1', when the master receives a NACK (typically after the master transmitted the slave address or TX data).</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>I2C master acknowledgement. Set to '1', when the master receives a ACK (typically after the master transmitted the slave address or TX data).</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>I2C master STOP. Set to '1', when the master has transmitted a STOP.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>I2C master bus error (unexpected detection of START or STOP condition).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>SPI master transfer done event: all data frames in the transmit FIFO are sent and the transmit FIFO and shift register are empty.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_M_SET</name>
          <description>Master interrupt set request register</description>
          <addressOffset>0xF04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x317</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_M_MASK</name>
          <description>Master interrupt mask register.</description>
          <addressOffset>0xF08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x317</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_M_MASKED</name>
          <description>Master interrupt masked request register</description>
          <addressOffset>0xF0C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x317</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_DONE</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_S</name>
          <description>Slave interrupt request register.</description>
          <addressOffset>0xF40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>I2C slave lost arbitration: the value driven on the SDA line is not the same as the value observed on the SDA line (while the SCL line is '1'). This should not occur, it represents erroneous I2C bus behavior. In case of lost arbitration, the I2C slave state machine aborts the ongoing transfer. The Firmware may decide to clear the TX and RX FIFOs in case of this error.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>N/A</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>N/A</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>N/A</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>N/A</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_START</name>
              <description>I2C slave START received. Set to '1', when START or REPEATED START event is detected.

In the case of externally clocked address matching (CTRL.EC_AM_MODE is '1') AND clock stretching is performed (I2C_CTRL.S_NOT_READY_ADDR_NACK is '0'), this field is NOT set. The Firmware should use INTR_S_EC.WAKE_UP, INTR_S.I2C_ADDR_MATCH and INTR_S.I2C_GENERAL.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>N/A</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>N/A</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>N/A</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_WRITE_STOP</name>
              <description>N/A</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_STOP</name>
              <description>N/A</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_BUS_ERROR</name>
              <description>N/A</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_S_SET</name>
          <description>Slave interrupt set request register.</description>
          <addressOffset>0xF44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_START</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_WRITE_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_STOP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_BUS_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_S_MASK</name>
          <description>Slave interrupt mask register.</description>
          <addressOffset>0xF48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_START</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_WRITE_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_EZ_STOP</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SPI_BUS_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_S_MASKED</name>
          <description>Slave interrupt masked request register</description>
          <addressOffset>0xF4C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF</resetMask>
          <fields>
            <field>
              <name>I2C_ARB_LOST</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_NACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_ACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_WRITE_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_START</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_ADDR_MATCH</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_GENERAL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>I2C_BUS_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_EZ_WRITE_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_EZ_STOP</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SPI_BUS_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TX</name>
          <description>Transmitter interrupt request register.</description>
          <addressOffset>0xF80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7F3</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>N/A</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>N/A</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>N/A</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>N/A</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Attempt to read from an empty TX FIFO. This happens when SCB is ready to transfer data and EMPTY is '1'.

Only used in FIFO mode.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>SW cannot get access to the EZ memory (EZ data access), due to an externally clocked EZ access. This may happen when STATUS.EC_BUSY is '1'.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>N/A</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>N/A</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>N/A</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TX_SET</name>
          <description>Transmitter interrupt set request register</description>
          <addressOffset>0xF84</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7F3</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TX_MASK</name>
          <description>Transmitter interrupt mask register.</description>
          <addressOffset>0xF88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7F3</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_TX_MASKED</name>
          <description>Transmitter interrupt masked request register</description>
          <addressOffset>0xF8C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7F3</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NOT_FULL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>EMPTY</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_NACK</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_DONE</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UART_ARB_LOST</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_RX</name>
          <description>Receiver interrupt request register.</description>
          <addressOffset>0xFC0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFED</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>N/A</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>N/A</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FULL</name>
              <description>N/A</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>N/A</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>N/A</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>SW cannot get access to the EZ memory (EZ_DATA accesses), due to an externally clocked EZ access. This may happen when STATUS.EC_BUSY is '1'.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAME_ERROR</name>
              <description>N/A</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ERROR</name>
              <description>N/A</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>N/A</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>N/A</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_RX_SET</name>
          <description>Receiver interrupt set request register.</description>
          <addressOffset>0xFC4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFED</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FULL</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAME_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>Write with '1' to set corresponding bit in interrupt status register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_RX_MASK</name>
          <description>Receiver interrupt mask register.</description>
          <addressOffset>0xFC8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFED</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FULL</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAME_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PARITY_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_RX_MASKED</name>
          <description>Receiver interrupt masked request register</description>
          <addressOffset>0xFCC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFED</resetMask>
          <fields>
            <field>
              <name>TRIGGER</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>NOT_EMPTY</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FULL</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>UNDERFLOW</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BLOCKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FRAME_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>PARITY_ERROR</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BAUD_DETECT</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BREAK_DETECT</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB1</name>
      <baseAddress>0x40250000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB2</name>
      <baseAddress>0x40260000</baseAddress>
    </peripheral>
    <peripheral derivedFrom="SCB0">
      <name>SCB3</name>
      <baseAddress>0x40270000</baseAddress>
    </peripheral>
    <peripheral>
      <name>MSC0</name>
      <description>MultiSense Controller</description>
      <headerStructName>MSC</headerStructName>
      <baseAddress>0x40290000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTL</name>
          <description>Configuration and Control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x100000</resetValue>
          <resetMask>0x81131111</resetMask>
          <fields>
            <field>
              <name>SENSE_EN</name>
              <description>Enables the sense modulator output. 
'0': All switches, static or dynamic, are open.
'1': Switches can be closed/open as per MMIO setting and Sequencer FSM.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>MSCCMP_EN</name>
              <description>MSC Comparator Enable.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK_SYNC_EN</name>
              <description>Control bit to create external channel sync clock.
'0': msc_ext_sync_clk_out (and _out_en) tied 0.
'1': Generate msc_ext_sync_clk_out using clock_sync_pos_en and set msc_ext_sync_clk_out_en = 1.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>EXT_FRAME_START_EN</name>
              <description>Control bit to enable external frame start of Sequencer FSM via GPIO. 
'0': FSM is only sensitive to START_FRAME bit.
'1': FSM sensitive to external frame start (and not sensitive to START_FRAME). This external start can be a new or pending external frame start event or an indication from the LP-AoC FSM.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OPERATING_MODE</name>
              <description>Sequencer FSM Operating Mode
'0': CPU Mode.
'1': Chained-Scan DMA Mode. 
'2': Autonomous Scan Multi Sensor Mode.
'3': Low Power Always-On-Capsense Mode.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CPU</name>
                  <description>Frame scan configurations are stored in system RAM. 
Start of frame initiated by CPU via AHB. 
After each scan in frame, the end of scan interrupt is raised. The CPU extracts results and programs and starts the next scan. ...</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CS_DMA</name>
                  <description>Frame scan configurations are stored in system RAM. 
CPU writes into DMA registers to start a DMA transfer. i.e. CPU/firmware initiates a DMA transfer to write first scan configuration.
The rest of the scans in the frame are chained via trigger to DMA....</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>AS_MS</name>
                  <description>Frame scan configurations are stored in IP RAM. 
Start of frame initiated by CPU via AHB.
The rest of the scans are chained autonomously by Sequencer FSM. ...</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LP_AOC</name>
                  <description>Frame scan configurations are stored in IP RAM. 
Start of frame initiated by LP-AOC timer expire.
Rest of the scans are chained autonomously by Sequencer FSM. No end of frame interrupt, no data processing by CPU. ...</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>BUF_MODE</name>
              <description>Shield buffer operating mode select.
'0': High bandwidth mode.
'1': Shield mode.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>HIGH_BW_MODE</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SHIELD_MODE</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLK_MSC_RATIO</name>
              <description>Control bit for logic that creates clk_msc from clk_hf.
'0': Divided. clk_hf :: clk_msc is at least 2:1 divide ratio. Ratio controlled by clock_msc_pos_en and clock_msc_neg_en provided by PERI.
'1': Pass-through. clk_hf :: clk_msc is 1:1.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIVIDED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PASSTHROUGH</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENABLED</name>
              <description>Master enable of the MSCv3 IP.  Must be set to '1' for any operation to function.
When '0' all analog components are off and all switches are open.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SPARE</name>
          <description>Spare MMIO</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>SPARE</name>
              <description>Spare MMIO (Hard IP).</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SCAN_CTL1</name>
          <description>Scan Control 1</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF713F</resetMask>
          <fields>
            <field>
              <name>NUM_AUTO_RESAMPLE</name>
              <description>If Sequencer detects a bad conversion and NUM_AUTO_RESAMPLE != 0, it will not store the bad result. Instead, it will automatically re-sample using current configuration without firmware intervention. This process repeats until a good conversion is produced or until the programmed maximum. If bad samples are produces for each programmed re-sample attempt, the final bad sample is stored.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESCAN_DEBUG_MODE</name>
              <description>If this bit is set all results (good and bad) generated by NUM_AUTO_RESAMPLE are stored. Debug feature.

Firmware Rule: Usable setting for NUM_AUTO_RESAMPLE is limited depending on the size of the result FIFO. Size of this FIFO determined by CONFIG_NR and SAMPLE_NR. If CONFIG_NR = 0, FIFO size is SAMPLE_NR. If CONFIG_NR &gt; 0, FIFO size is SAMPLE_NR * CONFIG_NR. NUM_AUTO_RESAMPLE must be less than or equal to the FIFO size in debug mode.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NUM_SAMPLES</name>
              <description>Number of samples (minus 1) to be scanned. NUM_SAMPLES &gt; 1 results in autonomous scan same sensor (AS-SS) behaviour.

Firmware Rule: Usable setting for NUM_SAMPLES is limited depending on the size of the result FIFO. Size of this FIFO determined by CONFIG_NR and SAMPLE_NR. If CONFIG_NR = 0, FIFO size is SAMPLE_NR. If CONFIG_NR &gt; 0, FIFO size is SAMPLE_NR * CONFIG_NR. NUM_SAMPLES must be less than or equal to the FIFO size in debug mode.</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RAW_COUNT_MODE</name>
              <description>Control bit to handle behaviour when RAW_COUNT exceeds 0xFFFF.
'0': Saturate. In this scenario, RAW_COUNT is clamped at 0xFFFF and RESULT_FIFO_RD.OVERFLOW is set.
'1': Overflow. In this scenario, RAW_COUNT rolls over and RESULT_FIFO_RD.OVERFLOW is set. This mode allows more sensitive tuning if measuring baseline capacitance is a don't care (e.g. SAR use case).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SATURATE</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OVERFLOW</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DEBUG_CONV_PH_SEL</name>
              <description>Debug counter conversion chop phase select for DEBUG_CONV_COUNT. Must be between 0 and NUM_CONV.

The number of conversions (or chop phases) for a given scan is controlled by NUM_CONV. Although only discrete values are possible for NUM_CONV, any conversion index up to this number may be selected up to NUM_CONV. For example if NUM_CONV = 7 (number of conversions is 8), then DEBUG_CONG_PH_SEL can be any value between 0 and 7 to select the particular conversion that the count is required for.</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAME_START_PTR</name>
              <description>Pointer to first sensor configuration of a frame. Hardware increments a local pointer from this start point. In LP-AoC mode, hardware returns to this pointer after the frame is complete prior to starting the next frame (after a timeout).</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SCAN_CTL2</name>
          <description>Scan Control 2</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x1</resetValue>
          <resetMask>0x10103FF</resetMask>
          <fields>
            <field>
              <name>NUM_EPI_CYCLES</name>
              <description>Number of clk_mod cycles to be run during EPILOGUE. Note that setting this register to 0 is an illegal configuration. This guarantees at least 1 clk_mod cycle during EPILOGUE (required to help timing closure in Sequencer FSM).</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CHOP_POL</name>
              <description>Polarity of first chop phase. Hardware updates chop control locally from this point (via inversion and following CHOP_EVEN_HOLD_EN programming also).</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CHOP_EVEN_HOLD_EN</name>
              <description>Use this bit to hold the chop value at the end of every even chop phase of NUM_CONV.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>INIT_CTL1</name>
          <description>Initialisation Control 1</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1FFF0FFF</resetMask>
          <fields>
            <field>
              <name>NUM_INIT_CMOD_12_RAIL_CYCLES</name>
              <description>Duration of the coarse initialisation phase (e.g. connecting Cmod1 to vdda and Cmod2 to vssa in full-wave mode). Programmed in terms of clk_mod cycles.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NUM_INIT_CMOD_12_SHORT_CYCLES</name>
              <description>Duration of the coarse short phase (shorting Cmod1 and Cmod2 in full-wave mode). Programmed in terms of clk_mod cycles. Should be set to zero in the case of half-wave mode.</description>
              <bitRange>[27:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PER_SAMPLE</name>
              <description>Decides if coarse initialisation is done per sample when NUM_SAMPLES &gt; 0 (i.e. more than one sample per scan). Applies to CMOD_SEL selected Cmod.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>INIT_CTL2</name>
          <description>Initialisation Control 2</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFF0FFF</resetMask>
          <fields>
            <field>
              <name>NUM_INIT_CMOD_34_RAIL_CYCLES</name>
              <description>Duration of the coarse initialisation phase (e.g. connecting Cmod3 to vdda and Cmod4 to vssa in full-wave mode). Programmed in terms of clk_mod cycles.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NUM_INIT_CMOD_34_SHORT_CYCLES</name>
              <description>Duration of the coarse short phase (shorting Cmod3 and Cmod4 in full-wave mode). Programmed in terms of clk_mod cycles. Should be set to zero in the case of half-wave mode.</description>
              <bitRange>[27:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INIT_CTL3</name>
          <description>Initialisation Control 3</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8FFF</resetMask>
          <fields>
            <field>
              <name>NUM_PRO_OFFSET_CYCLES</name>
              <description>Maximum number of clk_mod cycles to be assigned for the PRO_OFFSET state. If NUM_PRO_OFFSET_TRIPS are observed before this timeout, exit at that point.

Programming combinations:
a) OFFSET_CYCLES == 0 &amp;&amp; OFFSET_TRIPS == 0 -&gt; Skip PRO_OFFSET
b) OFFSET_CYCLES == 0 &amp;&amp; OFFSET_TRIPS &gt; 0 -&gt; wait in PRO_OFFSET for OFFSET_TRIPS
c) OFFSET_CYCLES &gt; 0 &amp;&amp; OFFSET_TRIPS == 0 -&gt; wait in PRO_OFFSET for OFFSET_CYCLES
d) OFFSET_CYCLES &gt; 0 &amp;&amp; OFFSET_TRIPS &gt; 0 -&gt; wait in PRO_OFFSET for the first of OFFSET_CYCLES and OFFSET_TRIPS.

Note that if OFFSET_TRIPS &gt; 0:
i) SW_COTCA and SW_COCB autonomously adjust as per their description after each comparator trip apart from the last trip. Expect OFFSET_TRIPS-1 adjustments in PRO_OFFSET.
ii) If FINE_MODE == COMPENSATION SW_CFTCA and SW_CFTCB autonomously swap settings after each comparator trip apart from the last trip. Expect OFFSET_TRIPS-1 adjustments in PRO_OFFSET.
iii) For both sets of switches above, after the last trip the switches revert to their programmed MMIO setting when exiting PRO_OFFSET.

If OFFSET_TRIPS == 0 and OFFSET_CYCLES &gt; 0:
Intention is that PRO_OFFSET be a fixed duration. The autonomous behaviour for this case is the same as the OFFSET_TRIPS &gt; 0 case, except that the number of trips (and hence the number of adjustments for (i) and (ii) above) are unknown in advance. At the end of OFFSET_CYCLES, the switches revert to their programmed MMIO setting when exiting PRO_OFFSET.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NUM_PRO_OFFSET_TRIPS</name>
              <description>Number of comparator trips required to be observed in PRO_OFFSET before proceeding to dummy cycles.

Note that a 'trip' is defined as a change of state of the comparator (either a 0 to 1 or a 1 to 0 transition). A trip at the very start of PRO_OFFSET is considered a trip with respect to this count.</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CMOD_SEL</name>
              <description>Select which Cmod are used and the cycle thresholds to be used for coarse initialisation. Note this field affects which Cmod switches are autonomously initialised by hardware as well as influencing the cycle counters as per INIT_MODE.
'0' || '2': Use NUM_INIT_CMOD_12_RAIL_CYCLES and NUM_INIT_CMOD_12_SHORT_CYCLES
'1' || '3': Use NUM_INIT_CMOD_34_RAIL_CYCLES and NUM_INIT_CMOD_34_SHORT_CYCLES

Firmware Rule: Firmware must program the appropriate SNS_SW_SEL_CMODx.ENABLED bits to match the Cmod selected with CMOD_SEL. Firmware must also set a valid INIT_MODE with CMOD_SEL.</description>
              <bitRange>[11:10]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CMOD_12</name>
                  <description>Used for full-wave</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CMOD_34</name>
                  <description>Used for full-wave</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CMOD_1</name>
                  <description>Used for half-wave</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CMOD_3</name>
                  <description>Used for half-wave</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INIT_MODE</name>
              <description>Determines autonomous initialisation behaviour during INIT_CMOD.
0: Decode CMOD_SEL.
    CMOD_12: S1CV = 1, S2CG = 1
    CMOD_34: S3CV = 1, S4CG = 1
    CMOD_1: S1CV = 1
    CMOD_3: S3CV = 1
1: Decode CMOD_SEL. Should be CMOD_1 or CMOD_3. Firmware Rule: Firmware should also close CBSO, FSP and one of BGRF/RMF/MBF to select type of reference.
    CMOD_1: C1CB = 1
    CMOD_3: C3CB = 1</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>REFERENCE_VDDA</name>
                  <description>Used for full and half wave when Vdda is reference.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>REFERENCE_VREF</name>
                  <description>Used for half-wave when Vref is reference.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>INIT_CTL4</name>
          <description>Initialisation Control 4</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FF00FF</resetMask>
          <fields>
            <field>
              <name>NUM_PRO_DUMMY_SUB_CONVS</name>
              <description>Number of sub-conversions (dummy cycles) to be run during PRO_DUMMY.

Firmware Rule:
If chopping is enabled (NUM_CONV &gt; ONE), then NUM_PRO_DUMMY_SUB_CONVS must be &gt;=1.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NUM_PRO_WAIT_CYCLES</name>
              <description>Number of clk_mod cycles to be run during PRO_WAIT.

Firmware Rule:
If chopping is enabled (NUM_CONV &gt; ONE), then NUM_PRO_WAIT_CYCLES must be &gt;=1.</description>
              <bitRange>[25:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SENSE_DUTY_CTL</name>
          <description>Sense Clock Duty Cycle Control</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xBFF0FFF</resetMask>
          <fields>
            <field>
              <name>PHASE_WIDTH</name>
              <description>Control width (clk_mod cycles) of ph0 and ph2 OR ph1 and ph3. If set to zero, Fs is divided equally between all phases. This field is only applicable when LFSR_MODE = DIRECT_CLOCK.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PHASE_SHIFT_CYCLES</name>
              <description>Phase shift cycle control for ph0X and ph1X. 

Must be &gt; 0 if PHASE_SHIFT_EN = 1.</description>
              <bitRange>[25:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PHASE_WIDTH_SEL</name>
              <description>Select which phases the PHASE_WIDTH applies to:
'0': PHASE_WIDTH corresponds to width of ph0 and ph2.
'1': PHASE_WIDTH corresponds to width of ph1 and ph3.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PH0_AND_PH2</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1_AND_PH3</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SENSE_PERIOD_CTL</name>
          <description>Sense Clock Period Control</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x84C</resetValue>
          <resetMask>0xF0FFF</resetMask>
          <fields>
            <field>
              <name>LFSR_POLY</name>
              <description>Programmable polynomial to be used for the sense LFSR. For example (default):
G(x) = X^12 + X^7 + X^4 + X^3 + 1
LFSR_POLY = 0x84C (1000_0100_1100).
Note that LFSR_POLY[i] = 1 if X^(i+1) is included in the polynomial. The +1 feedback term is implied and doesn't need a programmable bit.</description>
              <bitRange>[11:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LFSR_SCALE</name>
              <description>Shift the LFSR output left by LSFR_SCALE bits before adding to SENSE_DIV. This scaling is only applicable in spread spectrum mode.
Note that the clock divider including the dithering term must fit in 12 bits, otherwise the result is undefined.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FILTER_CTL</name>
          <description>Filter Control</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1010000</resetMask>
          <fields>
            <field>
              <name>BIT_FORMAT</name>
              <description>Determines how the synchronised comparator output is interpreted by the filter pipeline.

Firmware Rule: When FILTER_MODE = CIC1, BIT_FORMAT should be UNSIGNED.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>UNSIGNED</name>
                  <description>Input values [0,+1]</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SIGNED</name>
                  <description>Input values [-1,+1]. In this scenario a value of 0 is interpreted as -1.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FILTER_MODE</name>
              <description>N/A</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CIC1</name>
                  <description>Use the standard first order counter low pass filter (equivalent to CIC1).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CIC2</name>
                  <description>Use CIC2 Filter. Advantage of CIC2 over CIC1 is a higher resolution result for an equivalent scan time. All valid sub-samples are averaged to achieve an overall sample result for the scan. Interrupt is fired for every valid sub-sample to facilitate debug of the individual sub-samples.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CCOMP_CDAC_CTL</name>
          <description>Compensation CAPDAC Control</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8000FF00</resetMask>
          <fields>
            <field>
              <name>SEL_CO_PRO_OFFSET</name>
              <description>Select value for Compensation CAPDAC size during PRO_OFFSET until the first comparator trip is observed. Otherwise SEL_CO applies.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EPILOGUE_EN</name>
              <description>Control on whether Ccomp is active during EPILOGUE for final balancing in a conversion.

Note that for this bit to enable Ccomp during EPILOGUE, need SEL_CO &gt; 0 or FINE_MODE = COMPENSATION.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>DITHER_CDAC_CTL</name>
          <description>Flatspot/Dither CAPDAC Switch Control</description>
          <addressOffset>0x34</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x8E0000</resetValue>
          <resetMask>0xFF00FF</resetMask>
          <fields>
            <field>
              <name>SEL_FL</name>
              <description>Select value for  Dither/Flatspot CAPDAC size.

If dithering is enabled (FL_EN = 1), this is the seed value for the LFSR. If dithering is disabled, this value is presented directly to the hard IP as the CAPDAC code.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LFSR_POLY_FL</name>
              <description>Dither/Flatspot CAPDAC LFSR polynomial. Uses same encoding as the spread spectrum polynomial LFSR_POLY. For example (default):
G(x) = X^8 + X^4 + X^3 + X^2 + 1
LFSR_POLY_FL = 0x8E (1000_1110).
Note that LFSR_POLY_FL[i] = 1 if X^(i+1) is included in the polynomial. The +1 feedback term is implied and doesn't need a programmable bit.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CSW_CTL</name>
          <description>Control Mux Switch Control</description>
          <addressOffset>0x40</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CSW_FUNC_MODE</name>
              <description>Select between SW_SEL_CSW[x] and SW_SEL_CSW_FUNC.

CSW_FUNC_MODE[x] = 0: Use SW_CSW_CTL for control MUX x.
CSW_FUNC_MODE[x] = 1: Use SW_SEL_CSW_FUNC[y] for control MUX x as selected by y = {SW_SEL_CSW_MASK2[x],SW_SEL_CSW_MASK1[x],SW_SEL_CSW_MASK0[x]}.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SW_SEL_GPIO</name>
          <description>GPIO Switch Control</description>
          <addressOffset>0x44</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x7713177</resetMask>
          <fields>
            <field>
              <name>SW_CSD_SENSE</name>
              <description>MUX select for csd_sense waveform.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LOGIC_0</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LOGIC_1</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0_OR_PH3</name>
                  <description>N/A</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0X</name>
                  <description>N/A</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1X</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_CSD_SHIELD</name>
              <description>MUX select for csd_shield waveform.</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LOGIC_0</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LOGIC_1</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0_OR_PH3</name>
                  <description>N/A</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0_OR_FS2PH1_AND_PH1_OR_PH3</name>
                  <description>ph0 || [Fs2_ph1 &amp;&amp; (ph1 || ph3)]</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1X</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_CSD_MUTUAL</name>
              <description>MUX select for csd_mutual waveform.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LOGIC_0</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LOGIC_1</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_CSD_POLARITY</name>
              <description>MUX select for csd_polarity waveform.</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LOGIC_0</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LOGIC_1</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0_OR_PH1</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_CSD_CHARGE</name>
              <description>MUX select for csd_charge waveform.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LOGIC_0</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LOGIC_1</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_DSI_CMOD</name>
              <description>MUX select for dsi_cmod waveform.

if CMOD_SEL = CMOD_12 | CMOD_1
  dsi_cmod[0] = Decode SW_DSI_CMOD to select appropriate dsi_cmod waveform.
  dsi_cmod[1] = 0.
if CMOD_SEL = CMOD_34 | CMOD_3
  dsi_cmod[0] = 0.
  dsi_cmod[1] = Decode SW_DSI_CMOD to select appropriate dsi_cmod waveform.

This is assuming that:
dsi_cmod[0] is routed to cmod1
dsi_cmod[1] is routed to cmod3

Note that hardware overrides MMIO setting for dsi_cmod and sets it 1 during the INIT_SHORT state if using GPIO sensors (SW_DSI_CMOD != OPEN || SW_DSI_CSHTANK != OPEN).</description>
              <bitRange>[22:20]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LOGIC_0</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LOGIC_1</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_PH1_PH0</name>
                  <description>chop == 1 ? ph1 : ph0</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_PH3_PH1</name>
                  <description>chop == 1 ? ph3 : ph1</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>N/A</description>
                  <value>4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_DSI_CSH_TANK</name>
              <description>MUX select for dsi_csh_tank waveform.

if CMOD_SEL = CMOD_12 | CMOD_1
  dsi_csh_tank[0] = Decode SW_DSI_CSH_TANK to select appropriate dsi_csh_tank waveform.
  dsi_csh_tank[1] = 0.
if CMOD_SEL = CMOD_34 | CMOD_3
  dsi_csh_tank[0] = 0.
  dsi_csh_tank[1] = Decode SW_DSI_CSH_TANK to select appropriate dsi_csh_tank waveform.

This is assuming that:
dsi_csh_tank[0] is routed to cmod2
dsi_csh_tank[1] is routed to cmod4

Note that hardware overrides MMIO setting for dsi_csh_tank and sets it 1 during the INIT_SHORT state if using GPIO sensors (SW_DSI_CMOD != OPEN || SW_DSI_CSHTANK != OPEN).</description>
              <bitRange>[26:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>LOGIC_0</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LOGIC_1</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_PH0_PH1</name>
                  <description>chop == 1 ? ph0 : ph1</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_PH1_PH3</name>
                  <description>chop == 1 ? ph1 : ph3</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>N/A</description>
                  <value>4</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SW_SEL_CDAC_RE</name>
          <description>Reference CAPDAC Switch Control</description>
          <addressOffset>0x48</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x337777</resetMask>
          <fields>
            <field>
              <name>SW_RETCA</name>
              <description>Reference CAPDAC top plate to CSD Bus A Switch</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>sel = 00</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>sel = 01</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK_BAR</name>
                  <description>chop == 0 ? sel = 10 (clk_reffb) : sel = 11 (!clk_reffb)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK</name>
                  <description>chop == 1 ? sel = 10 (clk_reffb) : sel = 11 (!clk_reffb)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>DFT mode (ph1 ? sel = 01 : sel = 00)</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH3</name>
                  <description>DFT mode (ph3 ? sel = 01 : sel = 00)</description>
                  <value>5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_RECB</name>
              <description>Reference CAPDAC to CSD Bus B Switch</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>sel = 00</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>sel = 01</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK_BAR</name>
                  <description>chop == 0 ? sel = 10 (clk_reffb) : sel = 11 (!clk_reffb)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK</name>
                  <description>chop == 1 ? sel = 10 (clk_reffb) : sel = 11 (!clk_reffb)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>DFT mode (ph1 ? sel = 01 : sel = 00)</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH3</name>
                  <description>DFT mode (ph3 ? sel = 01 : sel = 00)</description>
                  <value>5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_RETV</name>
              <description>Reference CAPDAC top plate to vdda_q Switch.

Firmware Rule: Do not program RETV and RETG such that they are closed simultaneously.</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>sel = 00</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>sel = 01</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK</name>
                  <description>sel = 10 (clk_reffb)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK_BAR</name>
                  <description>sel = 11 (!clk_reffb)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>DFT mode</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>DFT mode</description>
                  <value>5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_RETG</name>
              <description>Reference CAPDAC top plate to vssa_q Switch.

Firmware Rule: Do not program RETV and RETG such that they are closed simultaneously.</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>sel = 00</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>sel = 01</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK</name>
                  <description>sel = 10 (clk_reffb)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK_BAR</name>
                  <description>sel = 11 (!clk_reffb)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>DFT mode</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>DFT mode</description>
                  <value>5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_REBV</name>
              <description>Reference CAPDAC bottom plate to vdda_q Switch.

Firmware Rule: Do not program REBV and REBG such that they are closed simultaneously.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>sel = 00</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>sel = 01</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK</name>
                  <description>sel = 10 (clk_reffb)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK_BAR</name>
                  <description>sel = 11 (!clk_reffb)</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_REBG</name>
              <description>Reference CAPDAC bottom plate to vssa_q Switch.

Firmware Rule: Do not program REBV and REBG such that they are closed simultaneously.</description>
              <bitRange>[21:20]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>sel = 00</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>sel = 01</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK</name>
                  <description>sel = 10 (clk_reffb)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK_BAR</name>
                  <description>sel = 11 (!clk_reffb)</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SW_SEL_CDAC_CO</name>
          <description>Compensation CAPDAC Switch Control</description>
          <addressOffset>0x4C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x337777</resetMask>
          <fields>
            <field>
              <name>SW_COTCA</name>
              <description>Compensation CAPDAC top plate to CSD Bus A Switch.
Note during the PRO_OFFSET state the following autonomous overriding occurs:
(compout_sync ^ CHOP_POL) ? [sel = 11 (!clk_comp) ] : [sel = 10 (clk_comp)].
Note that the CHOP_POL above is the hardware copy of the current chop polarity.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>sel = 00</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>sel = 01</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK_BAR</name>
                  <description>chop == 0 ? sel = 10 (clk_comp) : sel = 11 (!clk_comp)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK</name>
                  <description>chop == 1 ? sel = 10 (clk_comp) : sel = 11 (!clk_comp)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>DFT mode (ph1 ? sel = 01 : sel = 00)</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH3</name>
                  <description>DFT mode (ph3 ? sel = 01 : sel = 00)</description>
                  <value>5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_COCB</name>
              <description>Compensation CAPDAC to CSD Bus B Switch.
Note during the PRO_OFFSET state the following autonomous overriding occurs:
(compout_sync ^ CHOP_POL) ? [sel = 10 (clk_comp) ] : [sel = 11 (!clk_comp)].
Note that the CHOP_POL above is the hardware copy of the current chop polarity.</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>sel = 00</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>sel = 01</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK_BAR</name>
                  <description>chop == 0 ? sel = 10 (clk_comp) : sel = 11 (!clk_comp)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK</name>
                  <description>chop == 1 ? sel = 10 (clk_comp) : sel = 11 (!clk_comp)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>DFT mode (ph1 ? sel = 01 : sel = 00)</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH3</name>
                  <description>DFT mode (ph3 ? sel = 01 : sel = 00)</description>
                  <value>5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_COTV</name>
              <description>Compensation CAPDAC top plate to vdda_q Switch.

Firmware Rule: Do not program COTV and COTG such that they are closed simultaneously.</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>sel = 00</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>sel = 01</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK</name>
                  <description>sel = 10 (clk_reffb)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK_BAR</name>
                  <description>sel = 11 (!clk_reffb)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>DFT mode</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>DFT mode</description>
                  <value>5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_COTG</name>
              <description>Compensation CAPDAC top plate to vssa_q Switch.

Firmware Rule: Do not program COTV and COTG such that they are closed simultaneously.</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>sel = 00</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>sel = 01</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK</name>
                  <description>sel = 10 (clk_reffb)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK_BAR</name>
                  <description>sel = 11 (!clk_reffb)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>DFT mode</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>DFT mode</description>
                  <value>5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_COBV</name>
              <description>Compensation CAPDAC bottom plate to vdda_q Switch.

Firmware Rule: Do not program COBV and COBG such that they are closed simultaneously.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>sel = 00</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>sel = 01</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK</name>
                  <description>sel = 10 (clk_comp)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK_BAR</name>
                  <description>sel = 11 (!clk_comp)</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_COBG</name>
              <description>Compensation CAPDAC bottom plate to vssa_q Switch.

Firmware Rule: Do not program COBV and COBG such that they are closed simultaneously.</description>
              <bitRange>[21:20]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>sel = 00</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>sel = 01</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK</name>
                  <description>sel = 10 (clk_comp)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK_BAR</name>
                  <description>sel = 11 (!clk_comp)</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SW_SEL_CDAC_CF</name>
          <description>Fine CAPDAC Switch Control</description>
          <addressOffset>0x50</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x337777</resetMask>
          <fields>
            <field>
              <name>SW_CFTCA</name>
              <description>Fine CAPDAC top plate to CSD Bus A Switch.
Note during the PRO_OFFSET state the following autonomous overriding occurs if FINE_MODE = COMPENSATION:
(compout_sync ^ CHOP_POL) ? [sel = 11 (!clk_comp) ] : [sel = 10 (clk_comp)].
Note that the CHOP_POL above is the hardware copy of the current chop polarity.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>sel = 00</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>sel = 01</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK_BAR</name>
                  <description>case({chop,FINE_MODE})
{1,REFERENCE} : sel = 11 (!clk_reffb)
{1,COMPENSATION} : sel = 11 (!clk_comp)...</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK</name>
                  <description>case({chop,FINE_MODE})
{1,REFERENCE} : sel = 10 (clk_reffb)
{1,COMPENSATION} : sel = 10 (clk_comp)...</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>DFT mode (ph1 ? sel = 01 : sel = 00)</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH3</name>
                  <description>DFT mode (ph3 ? sel = 01 : sel = 00)</description>
                  <value>5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_CFTCB</name>
              <description>Fine CAPDAC top plate to CSD Bus B Switch.
Note during the PRO_OFFSET state the following autonomous overriding occurs if FINE_MODE = COMPENSATION:
(compout_sync ^ CHOP_POL) ? [sel = 10 (clk_comp) ] : [sel = 11 (!clk_comp)].
Note that the CHOP_POL above is the hardware copy of the current chop polarity.</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>sel = 00</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>sel = 01</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK_BAR</name>
                  <description>case({chop,FINE_MODE})
{1,REFERENCE} : sel = 11 (!clk_reffb)
{1,COMPENSATION} : sel = 11 (!clk_comp)...</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK</name>
                  <description>case({chop,FINE_MODE})
{1,REFERENCE} : sel = 10 (clk_reffb)
{1,COMPENSATION} : sel = 10 (clk_comp)...</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>DFT mode (ph1 ? sel = 01 : sel = 00)</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH3</name>
                  <description>DFT mode (ph3 ? sel = 01 : sel = 00)</description>
                  <value>5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_CFTV</name>
              <description>Fine CAPDAC top plate to vdda_q Switch.

Firmware Rule: Do not program CFTV and CFTG such that they are closed simultaneously.</description>
              <bitRange>[10:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>sel = 00</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>sel = 01</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK</name>
                  <description>sel = 10 [(FINE_MODE == REFERENCE) ? clk_reffb : clk_comp]</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK_BAR</name>
                  <description>sel = 11 [(FINE_MODE == REFERENCE) ? !clk_reffb : !clk_comp]</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>DFT mode (ph0 ? sel = 01 : sel = 00)</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>DFT mode (ph2 ? sel = 01 : sel = 00)</description>
                  <value>5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_CFTG</name>
              <description>Fine CAPDAC top plate to vssa_q Switch.

Firmware Rule: Do not program CFTV and CFTG such that they are closed simultaneously.</description>
              <bitRange>[14:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>sel = 00</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>sel = 01</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK</name>
                  <description>sel = 10 [(FINE_MODE == REFERENCE) ? clk_reffb : clk_comp]</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK_BAR</name>
                  <description>sel = 11 [(FINE_MODE == REFERENCE) ? !clk_reffb : !clk_comp]</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>DFT mode (ph0 ? sel = 01 : sel = 00)</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>DFT mode (ph2 ? sel = 01 : sel = 00)</description>
                  <value>5</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_CFBV</name>
              <description>Fine CAPDAC bottom plate to vdda_q Switch.

Firmware Rule: Do not program CFBV and CFBG such that they are closed simultaneously.</description>
              <bitRange>[17:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>sel = 00</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>sel = 01</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK</name>
                  <description>FINE_MODE == REFERENCE ? sel = 10 (clk_reffb) : sel = 10 (clk_comp)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK_BAR</name>
                  <description>FINE_MODE == REFERENCE ? sel = 11 (!clk_reffb) : sel = 11 (!clk_comp)</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_CFBG</name>
              <description>Fine CAPDAC bottom plate to vssa_q Switch.

Firmware Rule: Do not program CFBV and CFBG such that they are closed simultaneously.</description>
              <bitRange>[21:20]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>sel = 00</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>sel = 01</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK</name>
                  <description>FINE_MODE == REFERENCE ? sel = 10 (clk_reffb) : sel = 10 (clk_comp)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK_BAR</name>
                  <description>FINE_MODE == REFERENCE ? sel = 11 (!clk_reffb) : sel = 11 (!clk_comp)</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SW_SEL_CMOD1</name>
          <description>CMOD Switch Control 1</description>
          <addressOffset>0x54</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xCF0F3F0F</resetMask>
          <fields>
            <field>
              <name>SW_C1CA</name>
              <description>CMOD1 to CSD Bus A Switch.

During INIT_SHORT (used for full-wave scanning) if CMOD_SEL = CMOD_12, hardware sets C1CA = CLOSED.

Firmware Rule: See rule for ENABLED.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_TWO_PHASE</name>
                  <description>chop == 0 ? ph0 : ph1</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_FOUR_PHASE</name>
                  <description>chop == 0 ? ph1 : ph3</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_MPSC_D</name>
                  <description>chop == 0 ? ph3 : ph1</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_MPRX</name>
                  <description>chop == 0 ? ph1 : ph0</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH3</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK_BAR</name>
                  <description>chop == 0 ? clk_extfb : clk_extfb_bar</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK</name>
                  <description>chop == 1 ? clk_extfb : clk_extfb_bar</description>
                  <value>9</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_C1CB</name>
              <description>CMOD1 to CSD Bus B Switch.

Firmware Rule: See rule for ENABLED.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_TWO_PHASE</name>
                  <description>chop == 0 ? ph1 : ph0</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_FOUR_PHASE</name>
                  <description>chop == 0 ? ph3 : ph1</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_MPSC_D</name>
                  <description>chop == 0 ? ph1 : ph3</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_MPRX</name>
                  <description>chop == 0 ? ph0 : ph1</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK_BAR</name>
                  <description>chop == 0 ? clk_extfb : clk_extfb_bar</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK</name>
                  <description>chop == 1 ? clk_extfb : clk_extfb_bar</description>
                  <value>9</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_C1CC</name>
              <description>CMOD1 to CSD Bus C Switch.

Firmware Rule: See rule for ENABLED.</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1_OR_PH3</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_C1CV</name>
              <description>CMOD1 to vdda_q Switch.

Firmware Rule: Do not program C1CV and C1CG such that they are closed simultaneously.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>N/A</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0_OR_PH1</name>
                  <description>N/A</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0X</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1X</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0_OR_FS2PH0_AND_PH1_OR_PH3</name>
                  <description>ph0 || [Fs2_ph0 &amp;&amp; (ph1 || ph3)]</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK</name>
                  <description>clk_extfb</description>
                  <value>9</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_C1CG</name>
              <description>CMOD1 to vssa_q Switch.

Firmware Rule: Do not program C1CV and C1CG such that they are closed simultaneously.</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>N/A</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1_OR_PH3</name>
                  <description>N/A</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2_OR_PH3</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0X</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1X</name>
                  <description>N/A</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2_OR_FS2PH1_AND_PH1_OR_PH3</name>
                  <description>ph2 || [Fs2_ph1 &amp;&amp; (ph1 || ph3)]</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK_BAR</name>
                  <description>clk_extfb_bar</description>
                  <value>10</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>REF_MODE</name>
              <description>CMOD1 is used as a reference in scenario where CMOD can be re-purposed when not used as a CMOD.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENABLED</name>
              <description>CMOD1 enable.

Firmware Rule:
1) If any of C1CA/C1CB/C1CC can be 1 (statically or dynamically), ENABLED must be 1.
2) If statically closing (using CLOSED setting) any of C1CA/C1CB/C2CC, ENABLE must be set to 1 in a previous bus access to ensure break-before-make. When re-opening from static CLOSED, C1CA/C1CB/C1CC must be opened in a previous bus access before clearing ENABLE to 0. This is not required for dynamic programming options since e.g. PH0 is not active when these registers are programmed.
3) In any use case where C1CA/C1CB/C1CC are required to be set CLOSED via autonomous scanning, rule (2) cannot be observed. Example use case below**. In this scenario to get the desired effect, the options are to either:
a) Dedicate a specific CSW sensor for this purpose, follow rule (2) and do not change the settings autonomously for this sensor.
b) Use unused Cmod switches (e.g. if Cmod1/2 are being used, use the switches for Cmod3/4).

** Any use case where a csdbusa/b/c is not used. For example FW CSX wherein csdbusc not used; then csdbusc is statically connected to vssa_sc (C1CG=CLOSED, ENABLED=1 and C1CC=CLOSED).</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SW_SEL_CMOD2</name>
          <description>CMOD Switch Control 2</description>
          <addressOffset>0x58</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xCF0F3F0F</resetMask>
          <fields>
            <field>
              <name>SW_C2CA</name>
              <description>CMOD2 to CSD Bus A Switch.

During INIT_SHORT (used for full-wave scanning) if CMOD_SEL = CMOD_12, hardware sets C2CA = CLOSED.

Firmware Rule: See rule for ENABLED.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_TWO_PHASE</name>
                  <description>chop == 0 ? ph0 : ph1</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_FOUR_PHASE</name>
                  <description>chop == 0 ? ph1 : ph3</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_MPSC_D</name>
                  <description>chop == 0 ? ph3 : ph1</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_MPRX</name>
                  <description>chop == 0 ? ph1 : ph0</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH3</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK_BAR</name>
                  <description>chop == 0 ? clk_extfb : clk_extfb_bar</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK</name>
                  <description>chop == 1 ? clk_extfb : clk_extfb_bar</description>
                  <value>9</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_C2CB</name>
              <description>CMOD2 to CSD Bus B Switch.

Firmware Rule: See rule for ENABLED.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_TWO_PHASE</name>
                  <description>chop == 0 ? ph1 : ph0</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_FOUR_PHASE</name>
                  <description>chop == 0 ? ph3 : ph1</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_MPSC_D</name>
                  <description>chop == 0 ? ph1 : ph3</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_MPRX</name>
                  <description>chop == 0 ? ph0 : ph1</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK_BAR</name>
                  <description>chop == 0 ? clk_extfb : clk_extfb_bar</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK</name>
                  <description>chop == 1 ? clk_extfb : clk_extfb_bar</description>
                  <value>9</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_C2CC</name>
              <description>CMOD2 to CSD Bus C Switch.

Firmware Rule: See rule for ENABLED.</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1_OR_PH3</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_C2CV</name>
              <description>CMOD2 to vdda_q Switch.

Firmware Rule: Do not program C2CV and C2CG such that they are closed simultaneously.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>N/A</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0_OR_PH1</name>
                  <description>N/A</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0X</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1X</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0_OR_FS2PH0_AND_PH1_OR_PH3</name>
                  <description>ph0 || [Fs2_ph0 &amp;&amp; (ph1 || ph3)]</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK</name>
                  <description>clk_extfb</description>
                  <value>9</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_C2CG</name>
              <description>CMOD2 to vssa_q Switch.

Firmware Rule: Do not program C2CV and C2CG such that they are closed simultaneously.</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>N/A</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1_OR_PH3</name>
                  <description>N/A</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2_OR_PH3</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0X</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1X</name>
                  <description>N/A</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2_OR_FS2PH1_AND_PH1_OR_PH3</name>
                  <description>ph2 || [Fs2_ph1 &amp;&amp; (ph1 || ph3)]</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK_BAR</name>
                  <description>clk_extfb_bar</description>
                  <value>10</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>REF_MODE</name>
              <description>CMOD2 is used as a reference in scenario where CMOD can be re-purposed when not used as a CMOD.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENABLED</name>
              <description>CMOD2 enable.

Firmware Rule:
1) If any of C2CA/C2CB/C2CC can be 1 (statically or dynamically), ENABLED must be 1.
2) If statically closing (using CLOSED setting) any of C2CA/C2CB/C2CC, ENABLE must be set to 1 in a previous bus access to ensure break-before-make. When re-opening from static CLOSED, C2CA/C2CB/C2CC must be opened in a previous bus access before clearing ENABLE to 0. This is not required for dynamic programming options since e.g. PH0 is not active when these registers are programmed.
3) In any use case where C2CA/C2CB/C2CC are required to be set CLOSED via autonomous scanning, rule (2) cannot be observed. Example use case below**. In this scenario to get the desired effect, the options are to either:
a) Dedicate a specific CSW sensor for this purpose, follow rule (2) and do not change the settings autonomously for this sensor.
b) Use unused Cmod switches (e.g. if Cmod1/2 are being used, use the switches for Cmod3/4).

** Any use case where a csdbusa/b/c is not used. For example FW CSX wherein csdbusc not used; then csdbusc is statically connected to vssa_sc (C2CG=CLOSED, ENABLED=1 and C2CC=CLOSED).</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SW_SEL_CMOD3</name>
          <description>CMOD Switch Control 3</description>
          <addressOffset>0x5C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xCF0F3F0F</resetMask>
          <fields>
            <field>
              <name>SW_C3CA</name>
              <description>CMOD3 to CSD Bus A Switch.

Firmware Rule: See rule for ENABLED.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_TWO_PHASE</name>
                  <description>chop == 0 ? ph0 : ph1</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_FOUR_PHASE</name>
                  <description>chop == 0 ? ph1 : ph3</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_MPSC_D</name>
                  <description>chop == 0 ? ph3 : ph1</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_MPRX</name>
                  <description>chop == 0 ? ph1 : ph0</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH3</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK_BAR</name>
                  <description>chop == 0 ? clk_extfb : clk_extfb_bar</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK</name>
                  <description>chop == 1 ? clk_extfb : clk_extfb_bar</description>
                  <value>9</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_C3CB</name>
              <description>CMOD3 to CSD Bus B Switch.

During INIT_SHORT (used for full-wave scanning) if CMOD_SEL = CMOD_34, hardware sets C3CB = CLOSED.

Firmware Rule: See rule for ENABLED.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_TWO_PHASE</name>
                  <description>chop == 0 ? ph1 : ph0</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_FOUR_PHASE</name>
                  <description>chop == 0 ? ph3 : ph1</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_MPSC_D</name>
                  <description>chop == 0 ? ph1 : ph3</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_MPRX</name>
                  <description>chop == 0 ? ph0 : ph1</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK_BAR</name>
                  <description>chop == 0 ? clk_extfb : clk_extfb_bar</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK</name>
                  <description>chop == 1 ? clk_extfb : clk_extfb_bar</description>
                  <value>9</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_C3CC</name>
              <description>CMOD3 to CSD Bus C Switch.

Firmware Rule: See rule for ENABLED.</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1_OR_PH3</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_C3CV</name>
              <description>CMOD3 to vdda_q Switch.

Firmware Rule: Do not program C3CV and C3CG such that they are closed simultaneously.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>N/A</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0_OR_PH1</name>
                  <description>N/A</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0X</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1X</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0_OR_FS2PH0_AND_PH1_OR_PH3</name>
                  <description>ph0 || [Fs2_ph0 &amp;&amp; (ph1 || ph3)]</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK</name>
                  <description>clk_extfb</description>
                  <value>9</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_C3CG</name>
              <description>CMOD3 to vssa_q Switch.

Firmware Rule: Do not program C3CV and C3CG such that they are closed simultaneously.</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>N/A</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1_OR_PH3</name>
                  <description>N/A</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2_OR_PH3</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0X</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1X</name>
                  <description>N/A</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2_OR_FS2PH1_AND_PH1_OR_PH3</name>
                  <description>ph2 || [Fs2_ph1 &amp;&amp; (ph1 || ph3)]</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK_BAR</name>
                  <description>clk_extfb_bar</description>
                  <value>10</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>REF_MODE</name>
              <description>CMOD3 is used as a reference in scenario where CMOD can be re-purposed when not used as a CMOD.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENABLED</name>
              <description>CMOD3 enable.

Firmware Rule:
1) If any of C3CA/C3CB/C3CC can be 1 (statically or dynamically), ENABLED must be 1.
2) If statically closing (using CLOSED setting) any of C3CA/C3CB/C3CC, ENABLE must be set to 1 in a previous bus access to ensure break-before-make. When re-opening from static CLOSED, C3CA/C3CB/C3CC must be opened in a previous bus access before clearing ENABLE to 0. This is not required for dynamic programming options since e.g. PH0 is not active when these registers are programmed.
3) In any use case where C3CA/C3CB/C3CC are required to be set CLOSED via autonomous scanning, rule (2) cannot be observed. Example use case below**. In this scenario to get the desired effect, the options are to either:
a) Dedicate a specific CSW sensor for this purpose, follow rule (2) and do not change the settings autonomously for this sensor.
b) Use unused Cmod switches (e.g. if Cmod1/2 are being used, use the switches for Cmod3/4).

** Any use case where a csdbusa/b/c is not used. For example FW CSX wherein csdbusc not used; then csdbusc is statically connected to vssa_sc (C3CG=CLOSED, ENABLED=1 and C3CC=CLOSED).</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SW_SEL_CMOD4</name>
          <description>CMOD Switch Control 4</description>
          <addressOffset>0x60</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xCF0F3F0F</resetMask>
          <fields>
            <field>
              <name>SW_C4CA</name>
              <description>CMOD4 to CSD Bus A Switch.

Firmware Rule: See rule for ENABLED.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_TWO_PHASE</name>
                  <description>chop == 0 ? ph0 : ph1</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_FOUR_PHASE</name>
                  <description>chop == 0 ? ph1 : ph3</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_MPSC_D</name>
                  <description>chop == 0 ? ph3 : ph1</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_MPRX</name>
                  <description>chop == 0 ? ph1 : ph0</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH3</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK_BAR</name>
                  <description>chop == 0 ? clk_extfb : clk_extfb_bar</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK</name>
                  <description>chop == 1 ? clk_extfb : clk_extfb_bar</description>
                  <value>9</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_C4CB</name>
              <description>CMOD4 to CSD Bus B Switch.

During INIT_SHORT (used for full-wave scanning) if CMOD_SEL = CMOD_34, hardware sets C4CB = CLOSED.

Firmware Rule: See rule for ENABLED.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_TWO_PHASE</name>
                  <description>chop == 0 ? ph1 : ph0</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_FOUR_PHASE</name>
                  <description>chop == 0 ? ph3 : ph1</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_MPSC_D</name>
                  <description>chop == 0 ? ph1 : ph3</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_MPRX</name>
                  <description>chop == 0 ? ph0 : ph1</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK_BAR</name>
                  <description>chop == 0 ? clk_extfb : clk_extfb_bar</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK</name>
                  <description>chop == 1 ? clk_extfb : clk_extfb_bar</description>
                  <value>9</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_C4CC</name>
              <description>CMOD4 to CSD Bus C Switch.

Firmware Rule: See rule for ENABLED.</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1_OR_PH3</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_C4CV</name>
              <description>CMOD4 to vdda_q Switch.

Firmware Rule: Do not program C4CV and C4CG such that they are closed simultaneously.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>N/A</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0_OR_PH1</name>
                  <description>N/A</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0X</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1X</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0_OR_FS2PH0_AND_PH1_OR_PH3</name>
                  <description>ph0 || [Fs2_ph0 &amp;&amp; (ph1 || ph3)]</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK</name>
                  <description>clk_extfb</description>
                  <value>9</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_C4CG</name>
              <description>CMOD4 to vssa_q Switch.

Firmware Rule: Do not program C4CV and C4CG such that they are closed simultaneously.</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>N/A</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1_OR_PH3</name>
                  <description>N/A</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2_OR_PH3</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0X</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1X</name>
                  <description>N/A</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2_OR_FS2PH1_AND_PH1_OR_PH3</name>
                  <description>ph2 || [Fs2_ph1 &amp;&amp; (ph1 || ph3)]</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK_BAR</name>
                  <description>clk_extfb_bar</description>
                  <value>10</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>REF_MODE</name>
              <description>CMOD4 is used as a reference in scenario where CMOD can be re-purposed when not used as a CMOD.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENABLED</name>
              <description>CMOD4 enable.

Firmware Rule:
1) If any of C4CA/C4CB/C4CC can be 1 (statically or dynamically), ENABLED must be 1.
2) If statically closing (using CLOSED setting) any of C4CA/C4CB/C4CC, ENABLE must be set to 1 in a previous bus access to ensure break-before-make. When re-opening from static CLOSED, C4CA/C4CB/C4CC must be opened in a previous bus access before clearing ENABLE to 0. This is not required for dynamic programming options since e.g. PH0 is not active when these registers are programmed.
3) In any use case where C4CA/C4CB/C4CC are required to be set CLOSED via autonomous scanning, rule (2) cannot be observed. Example use case below**. In this scenario to get the desired effect, the options are to either:
a) Dedicate a specific CSW sensor for this purpose, follow rule (2) and do not change the settings autonomously for this sensor.
b) Use unused Cmod switches (e.g. if Cmod1/2 are being used, use the switches for Cmod3/4).

** Any use case where a csdbusa/b/c is not used. For example FW CSX wherein csdbusc not used; then csdbusc is statically connected to vssa_sc (C4CG=CLOSED, ENABLED=1 and C4CC=CLOSED).</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>OBS_CTL</name>
          <description>Observability Control</description>
          <addressOffset>0x70</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF0F0F0F</resetMask>
          <fields>
            <field>
              <name>OBSERVE0</name>
              <description>Selects the source for observe output signal 0:
0: Fs
1: Comparator Output (direct from hard IP).
2: Comparator Output captured on clk_hf_adv.
3: Comparator Output captured on clk_mod.
4: Current raw counter LSB.
5: Scan Done (hardware set signal for INTR.SCAN)
6: ph0.
7: ph1.
8: ph2.
9: ph3.
10: ph0X
11: ph1X
12-14: Unused (0).
15: Sequencer FSM state bit 0.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>FS</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>COMP_OUT</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>COMP_OUT_ADV</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>COMP_OUT_SYNC</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>COUNTER_LSB</name>
                  <description>N/A</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SCAN_DONE</name>
                  <description>N/A</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>N/A</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH3</name>
                  <description>N/A</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0X</name>
                  <description>N/A</description>
                  <value>10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1X</name>
                  <description>N/A</description>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UNUSED_1</name>
                  <description>N/A</description>
                  <value>12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UNUSED_2</name>
                  <description>N/A</description>
                  <value>13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UNUSED_3</name>
                  <description>N/A</description>
                  <value>14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SM_STATE_0</name>
                  <description>N/A</description>
                  <value>15</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OBSERVE1</name>
              <description>Selects the source for observe output signal 1:
0-14: See OBSERVE0.
15: Sequencer FSM state bit 1.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>FS</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>COMP_OUT</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>COMP_OUT_ADV</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>COMP_OUT_SYNC</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>COUNTER_LSB</name>
                  <description>N/A</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SCAN_DONE</name>
                  <description>N/A</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>N/A</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH3</name>
                  <description>N/A</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0X</name>
                  <description>N/A</description>
                  <value>10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1X</name>
                  <description>N/A</description>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UNUSED_1</name>
                  <description>N/A</description>
                  <value>12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UNUSED_2</name>
                  <description>N/A</description>
                  <value>13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UNUSED_3</name>
                  <description>N/A</description>
                  <value>14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SM_STATE_1</name>
                  <description>N/A</description>
                  <value>15</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OBSERVE2</name>
              <description>Selects the source for observe output signal 2:
0-14: See OBSERVE0.
15: Sequencer FSM state bit 2.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>FS</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>COMP_OUT</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>COMP_OUT_ADV</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>COMP_OUT_SYNC</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>COUNTER_LSB</name>
                  <description>N/A</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SCAN_DONE</name>
                  <description>N/A</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>N/A</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH3</name>
                  <description>N/A</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0X</name>
                  <description>N/A</description>
                  <value>10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1X</name>
                  <description>N/A</description>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UNUSED_1</name>
                  <description>N/A</description>
                  <value>12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UNUSED_2</name>
                  <description>N/A</description>
                  <value>13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UNUSED_3</name>
                  <description>N/A</description>
                  <value>14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SM_STATE_2</name>
                  <description>N/A</description>
                  <value>15</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OBSERVE3</name>
              <description>Selects the source for observe output signal 3:
0-14: See OBSERVE0.
15: Sequencer FSM state bit 3.</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>FS</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>COMP_OUT</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>COMP_OUT_ADV</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>COMP_OUT_SYNC</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>COUNTER_LSB</name>
                  <description>N/A</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SCAN_DONE</name>
                  <description>N/A</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>N/A</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH3</name>
                  <description>N/A</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0X</name>
                  <description>N/A</description>
                  <value>10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1X</name>
                  <description>N/A</description>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UNUSED_1</name>
                  <description>N/A</description>
                  <value>12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UNUSED_2</name>
                  <description>N/A</description>
                  <value>13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>UNUSED_3</name>
                  <description>N/A</description>
                  <value>14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SM_STATE_3</name>
                  <description>N/A</description>
                  <value>15</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>WAKEUP_CTL</name>
          <description>Wakeup Control</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8000FFFF</resetMask>
          <fields>
            <field>
              <name>WAKEUP_TIMER</name>
              <description>Timer interval between wakeup scans in LP-AoC mode. Assumes a 32kHz operating clock (clk_lf). Desired range is 1-&gt;2000ms.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>If set, then LP AoC FSM will operate when in DEEP_SLEEP. This also switches clk_hf -&gt; clk_lf.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>LP_AOC_CTL</name>
          <description>LP-AoC Control</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFF</resetMask>
          <fields>
            <field>
              <name>BUCKET_THRESHOLD</name>
              <description>Global threshold to control the per sensor SENSOR_BASELINE updates.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BUCKET_STEP_SIZE</name>
              <description>Global step size for SENSOR_BASELINE adjustment.</description>
              <bitRange>[23:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DEBOUNCE_THRESHOLD</name>
              <description>Global threshold for successive TOUCH_THRESHOLD exceeds to warrant a full system wakeup.</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS1</name>
          <description>General Status Register 1</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RAW_COUNT</name>
              <description>Live current raw counter. For debug/test purposes. In normal operation, Firmware/DMA will typically read results from RESULT_FIFO_RD.

Note that in CIC2 mode, this value gets updated at the decimation rate. When the SUB_SAMPLE interrupt is asserted, firmware could read this value before the next SUB_SAMPLE interrupt fires to debug sub-samples if desired.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RAW_COUNT_POS</name>
              <description>Useful for determining component counts for positive and negative charge by subtracting from RAW_COUNT.

When PHASE_MODE_SEL = FOUR_PHASE
  RAW_COUNT_POS: Counts during ph1/ph2 of SUB_CONV.
When PHASE_MODE_SEL = TWO_PHASE
  RAW_COUNT_POS: Counts during ph0 of SUB_CONV.

This counter increments whenever the Cref CAPDAC is balancing during the corresponding phases above. Note that digital non-overlap is ignored for the purposes of this count since balancing occurs irrespective of these settings. Hence the 'raw' phases (pre application of any digital non-overlap) are considered as the measurement window for this counter.

Applicable for CIC1 and CIC2 mode. In CIC2 mode the count is determined by the value of the input to the first integrator stage (equivalent to CIC1 behaviour).</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS2</name>
          <description>General Status Register 2</description>
          <addressOffset>0x104</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFF</resetMask>
          <fields>
            <field>
              <name>DEBUG_CONV_COUNT</name>
              <description>Debug raw count for a particular conversion. Enabled only during a specified conversion of a sample (a specific chop phase).

Only applicable for CIC1 mode. In CIC2 mode this counter remains zero.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS3</name>
          <description>General Status Register 3</description>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x110FFFFF</resetMask>
          <fields>
            <field>
              <name>NUM_SUB_CONVS</name>
              <description>Number of sub-conversions remaining while in PRO_DUMMY and SUB_CONV.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SEQ_STATE</name>
              <description>MSC Sequencer FSM state.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-only</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>IDLE</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WAIT_DMA_WRITE</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LOAD_CONFIG</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WAIT_SCAN_START</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ASSERT_RDY</name>
                  <description>N/A</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WAIT_CONSENSUS</name>
                  <description>N/A</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INIT_CMOD</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INIT_SHORT</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PRO_OFFSET</name>
                  <description>N/A</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PRO_DUMMY</name>
                  <description>N/A</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PRO_WAIT</name>
                  <description>N/A</description>
                  <value>10</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SUB_CONV</name>
                  <description>N/A</description>
                  <value>11</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EPILOGUE</name>
                  <description>N/A</description>
                  <value>12</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WAIT_DMA_READ_NEW_SAMPLE</name>
                  <description>N/A</description>
                  <value>13</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>WAIT_DMA_READ_EOF</name>
                  <description>N/A</description>
                  <value>14</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>POST_SCAN</name>
                  <description>N/A</description>
                  <value>15</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FS_CLOCK</name>
              <description>Sense clock Fs control waveform. For debug/test purposes.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MSC_CMP_OUT</name>
              <description>Output of main sensing comparator (synchronized). For debug/test purposes.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RESULT_FIFO_STATUS</name>
          <description>Result FIFO Status</description>
          <addressOffset>0x10C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>USED</name>
              <description>Number of used/occupied entries in the result FIFO. When '0', the FIFO is empty.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>WR_PTR</name>
              <description>Result FIFO write pointer: FIFO location at which a new data is written by the hardware.

Note: This functionality is intended for debugging purposes.</description>
              <bitRange>[19:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RD_PTR</name>
              <description>Result FIFO read pointer: FIFO location from which data is read via AHB.

Note: This functionality is intended for debugging purposes.</description>
              <bitRange>[29:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FIFO_UNDERFLOW</name>
              <description>Hardware sets this field to '1', when reading from an empty FIFO (RESULT_FIFO_STATUS.USED is '0').</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FIFO_OVERFLOW</name>
              <description>Set if hardware attempts to write a RAW_COUNT (and associated metrics) to an already full result FIFO.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RESULT_FIFO_RD</name>
          <description>Result FIFO Pointer</description>
          <addressOffset>0x110</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF71FFFF</resetMask>
          <fields>
            <field>
              <name>RAW_COUNT</name>
              <description>FILTER_MODE = CIC1: Accumulated raw count for a sample. 
FILTER_MODE = CIC2: Average value of all valid sub-samples over all conversions in a sample. Note that the hardware averaging capabilities are limited. See INTR.CIC2_ERROR - if this interrupt asserts it *may* be possible to firmware back calculate the correct average.

See SCAN_CTL1.RAW_COUNT_MODE for overflow behaviour of RAW_COUNT.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERFLOW</name>
              <description>RAW_COUNT overflow.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RESAMPLE_COUNT</name>
              <description>Counter indicating number of attempted re-samples (via NUM_AUTO_RESAMPLE) for this raw count.

If RESAMPLE_COUNT = 0 and NUM_AUTO_RESAMPLE &gt; 0, this raw count was obtained from the first sample attempt.</description>
              <bitRange>[22:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BAD_CONV_COUNT</name>
              <description>Counter to indicate whether conversion of a sample is bad at the end of each chop phase. This is true if the comparator has not tripped by the end of EPILOGUE in a chop phase. 

BAD_CONV_COUNT can have a maximum value of 8 (based on largest legal NUM_CONV).

If RESAMPLE_COUNT &gt; 0 and BAD_CONV_COUNT = 0, this indicates that RESAMPLE_COUNT bad samples were encountered before this good sample was obtained.

If RESAMPLE_COUNT &gt; 0 and BAD_CONV_COUNT &gt; 0, this indicates that all NUM_AUTO_RESAMPLE attempts have been executed and the final attempt had BAD_CONV_COUNT bad conversions. In this situation RESAMPLE_COUNT should equal NUM_AUTO_RESAMPLE.</description>
              <bitRange>[27:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>MSCv3 Interrupt Cause Register</description>
          <addressOffset>0x170</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC1111111</resetMask>
          <fields>
            <field>
              <name>SUB_SAMPLE</name>
              <description>A valid CIC2 sub-sample is complete. To facilitate firmware averaging of sub-samples. For debug purposes.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE</name>
              <description>A single sample is complete. For debug purposes.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCAN</name>
              <description>A single scan is complete.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INIT</name>
              <description>Coarse initialisation complete. For debug purposes.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAME</name>
              <description>A single frame is complete.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CIC2_ERROR</name>
              <description>CIC2 error detected. This bit is set at the end of a sample if the number of valid CIC2 sub-samples is not one of [1,2,4,8,16]. At the end of a CIC2 sample, RESULT_FIFO_RD.RAW_COUNT contains the average of the valid sub-samples observed during that sample. The average is computed by a power of 2 shift as per below for the number of valid CIC2 samples observed:
0,1 -&gt; no division (not a typical use case since an average of multiple sub-samples is desired)
2 -&gt; divide by 2
3,4 -&gt; divide by 4
5,6,7,8 -&gt; divide by 8
9+ -&gt; divide by 16
The RESULT_FIFO_RD.RAW_COUNT value is only the true average if the number of valid CIC2 sub-samples is [1,2,4,8,16]. However, in the cases of [3.4.5.6.9.10,11,12,13,14,15] firmware can back-calculate the real average from the computed average (RAW_COUNT) and the divisor used to compute that average (1,2,4,8,16 above) as follows assuming the number of valid sub-samples is known:

Real_Average = Computed_Average*(Computed_Divider/NumSubSamples)

If the number of sub-samples exceeds 16, this cannot be reliably computed due to internal hardware overflows.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CONFIG_REQ</name>
              <description>Request for scan configuration and scan start. The Sequencer FSM is entering WAIT_SCAN_START when this interrupt is raised. This interrupt can be used in CPU mode in a multi-channel scenario with external frame start to indicate to firmware that it is required to configure the channel and start a scan.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFO_UNDERFLOW</name>
              <description>Result FIFO underflow condition.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFO_OVERFLOW</name>
              <description>Result FIFO overflow condition.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>MSCv3 Interrupt Set Register</description>
          <addressOffset>0x174</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC1111111</resetMask>
          <fields>
            <field>
              <name>SUB_SAMPLE</name>
              <description>Write with '1' to set corresponding bit in interrupt request register (a write of '0' has no effect).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE</name>
              <description>Write with '1' to set corresponding bit in interrupt request register (a write of '0' has no effect).</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCAN</name>
              <description>Write with '1' to set corresponding bit in interrupt request register (a write of '0' has no effect).</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INIT</name>
              <description>Write with '1' to set corresponding bit in interrupt request register (a write of '0' has no effect).</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAME</name>
              <description>Write with '1' to set corresponding bit in interrupt request register (a write of '0' has no effect).</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CIC2_ERROR</name>
              <description>Write with '1' to set corresponding bit in interrupt request register (a write of '0' has no effect).</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CONFIG_REQ</name>
              <description>Write with '1' to set corresponding bit in interrupt request register (a write of '0' has no effect).</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFO_UNDERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register (a write of '0' has no effect).</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFO_OVERFLOW</name>
              <description>Write with '1' to set corresponding bit in interrupt request register (a write of '0' has no effect).</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>MSCv3 Interrupt Mask Register</description>
          <addressOffset>0x178</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC1111111</resetMask>
          <fields>
            <field>
              <name>SUB_SAMPLE</name>
              <description>Mask bit for corresponding bit in interrupt cause register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE</name>
              <description>Mask bit for corresponding bit in interrupt cause register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SCAN</name>
              <description>Mask bit for corresponding bit in interrupt cause register.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INIT</name>
              <description>Mask bit for corresponding bit in interrupt cause register.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FRAME</name>
              <description>Mask bit for corresponding bit in interrupt cause register.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CIC2_ERROR</name>
              <description>Mask bit for corresponding bit in interrupt cause register.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>CONFIG_REQ</name>
              <description>Mask bit for corresponding bit in interrupt cause register.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFO_UNDERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt cause register.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FIFO_OVERFLOW</name>
              <description>Mask bit for corresponding bit in interrupt cause register.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>MSCv3 Interrupt Masked Register</description>
          <addressOffset>0x17C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC1111111</resetMask>
          <fields>
            <field>
              <name>SUB_SAMPLE</name>
              <description>Logical AND of corresponding INTR and INTR_MASK bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SAMPLE</name>
              <description>Logical AND of corresponding INTR and INTR_MASK bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SCAN</name>
              <description>Logical AND of corresponding INTR and INTR_MASK bits.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INIT</name>
              <description>Logical AND of corresponding INTR and INTR_MASK bits.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FRAME</name>
              <description>Logical AND of corresponding INTR and INTR_MASK bits.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CIC2_ERROR</name>
              <description>Logical AND of corresponding INTR and INTR_MASK bits.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CONFIG_REQ</name>
              <description>Logical AND of corresponding INTR and INTR_MASK bits.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FIFO_UNDERFLOW</name>
              <description>Logical AND of corresponding INTR and INTR_MASK bits.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FIFO_OVERFLOW</name>
              <description>Logical AND of corresponding INTR and INTR_MASK bits.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_LP</name>
          <description>Low Power Interrupt Cause Register</description>
          <addressOffset>0x180</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>WAKEUP</name>
              <description>LP-AoC has detected wakeup.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_LP_SET</name>
          <description>Low Power Interrupt Set Register</description>
          <addressOffset>0x184</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>WAKEUP</name>
              <description>Write with '1' to set corresponding bit in interrupt request register (a write of '0' has no effect).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_LP_MASK</name>
          <description>Low Power Interrupt Mask Register</description>
          <addressOffset>0x188</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>WAKEUP</name>
              <description>Mask bit for corresponding bit in interrupt cause register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_LP_MASKED</name>
          <description>Low Power Interrupt Masked Register</description>
          <addressOffset>0x18C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>WAKEUP</name>
              <description>Logical AND of corresponding INTR_LP and INTR_LP_MASK bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>FRAME_CMD</name>
          <description>Frame Command Register</description>
          <addressOffset>0x190</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>START_FRAME</name>
              <description>Start the MSCv3 sequencer frame process. Note that a rising edge on this bit also creates a 2x cycle clk_msc pulse on the msc_ext_frm_start_out signal. The corresponding msc_ext_frm_start_out_en is controlled by CTL.ENABLED.

Sequencer FSM clears this bit on egress from IDLE. If START_FRAME is set by firmware when FSM is not in IDLE, the hardware must hold the bit set to allow for 'pending' frame behaviour.

Firmware Rule:
Note if FRAME_CMD is used in a multi-channel scenario care must be taken by firmware not to excessively delay FRAME_CMD to each individual channel. If not, a window exists where the first channel that sees FRAME_CMD can reach the WAIT_CONSENSUS state and mistakenly believe all channels are ready for lockstep scanning when the reality is the other channels are still in IDLE and indicating ready because they haven't been initiated yet.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WAKEUP_CMD</name>
          <description>Wakeup Command Register</description>
          <addressOffset>0x198</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x10001</resetMask>
          <fields>
            <field>
              <name>WAIT_FOR_DS</name>
              <description>Set by firmware to prime the LP-AoC FSM to be ready to detect entry to DEEP_SLEEP. When detected, hardware clears the bit down and the LP-AoC FSM periodically scans all valid sensor configurations programmed in the sensor configuration storage starting from FRAME_START_PTR.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ABORT</name>
              <description>Abort the LP-AoC when in WAIT_FOR_DS state.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SNS_STRUCT_CTL</name>
          <description>Sensor Struct Control</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF0F</resetMask>
          <fields>
            <field>
              <name>OFFSET</name>
              <description>Starting offset into SNS_* registers of current sensor configuration in local IP storage. Used by LOAD_CONFIG state in Sequencer FSM. Applicable only when CONFIG_NR &gt; 0.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LENGTH</name>
              <description>Number of SNS_* registers from OFFSET for current sensor configuration in local IP storage. Used by LOAD_CONFIG state in Sequencer FSM. Applicable only when CONFIG_NR &gt; 0.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SNS_LP_AOC_SENSOR_CTL1</name>
          <description>LP-AoC Sensor Control 1</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>P_BUCKET</name>
              <description>Per sensor bucket for baseline greater than raw count adjustments.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>N_BUCKET</name>
              <description>Per sensor bucket for baseline &lt;= raw count adjustments.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SNS_LP_AOC_SENSOR_CTL2</name>
          <description>LP-AoC Sensor Control 2</description>
          <addressOffset>0x208</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SENSOR_BASELINE</name>
              <description>Per sensor baseline value.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TOUCH_THRESHOLD</name>
              <description>Per sensor threshold for |baseline - rawCount| to warrant a single touch detect.</description>
              <bitRange>[27:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SNS_SW_SEL_CSW_MASK2</name>
          <description>Control MUX Function Select Mask 2</description>
          <addressOffset>0x20C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FUNC_MASK</name>
              <description>{SNS_SW_SEL_CSW_MASK2.FUNC_MASK[x],
SNS_SW_SEL_CSW_MASK1.FUNC_MASK[x],
SNS_SW_SEL_CSW_MASK0.FUNC_MASK[x]} used to select appropriate SW_SEL_CSW_FUNC[x] when CSW_FUNC_MODE[x] = 1.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SNS_SW_SEL_CSW_MASK1</name>
          <description>Control MUX Function Select Mask 1</description>
          <addressOffset>0x210</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FUNC_MASK</name>
              <description>{SNS_SW_SEL_CSW_MASK2.FUNC_MASK[x],
SNS_SW_SEL_CSW_MASK1.FUNC_MASK[x],
SNS_SW_SEL_CSW_MASK0.FUNC_MASK[x]} used to select appropriate SW_SEL_CSW_FUNC[x] when CSW_FUNC_MODE[x] = 1.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SNS_SW_SEL_CSW_MASK0</name>
          <description>Control MUX Function Select Mask 0</description>
          <addressOffset>0x214</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>FUNC_MASK</name>
              <description>{SNS_SW_SEL_CSW_MASK2.FUNC_MASK[x],
SNS_SW_SEL_CSW_MASK1.FUNC_MASK[x],
SNS_SW_SEL_CSW_MASK0.FUNC_MASK[x]} used to select appropriate SW_SEL_CSW_FUNC[x] when CSW_FUNC_MODE[x] = 1.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SNS_SCAN_CTL</name>
          <description>Sensor Scan Control</description>
          <addressOffset>0x218</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>NUM_SUB_CONVS</name>
              <description>Number of sub-conversions (minus 1) in a conversion.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP_DIV</name>
              <description>The ratio (minus 1) of clk_comp::clk_mod.

Notes for tuning:
Fs = Fmod / Kref
Fcomp = Kcomp * Fs

MSCv3 MMIO provides:
Kref = (SENSE_DIV+1)
Fs = Fmod/(SENSE_DIV+1)
Fcomp = Fmod / (COMP_DIV+1)

Therefore:
Kcomp = Fmod/[Fs*(COMP_DIV+1)]

Kcomp = (SENSE_DIV+1)/(COMP_DIV+1)

It is expected that Kcomp be programmed as an integer. Anything else is considered a mis-programming.</description>
              <bitRange>[27:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NUM_CONV</name>
              <description>Number of conversions (minus 1) per scanned sample. This is required for chopping (chop polarity is updated per conversion).

Firmware Rule:
If chopping is enabled (NUM_CONV &gt; ONE), then NUM_PRO_WAIT_CYCLES must be &gt;=1 and NUM_PRO_DUMMY_SUB_CONVS must be &gt;=1.</description>
              <bitRange>[30:28]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ONE</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TWO</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FOUR</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EIGHT</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INIT_BYPASS</name>
              <description>Coarse initialisation bypass control. Applies to CMOD_SEL selected Cmod.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SNS_CDAC_CTL</name>
          <description>Sensor CAPDAC Control</description>
          <addressOffset>0x21C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x17FFFFFF</resetMask>
          <fields>
            <field>
              <name>SEL_RE</name>
              <description>Select value for Reference CAPDAC size.</description>
              <bitRange>[7:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEL_CO</name>
              <description>Select value for Compensation CAPDAC size.

Note if SEL_CO = 0 and FINE_MODE != COMPENSATION, then clk_comp is gated during PRO_DUMMY, SUB_CONV and EPILOGUE.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEL_CF</name>
              <description>Select value for Fine CAPDAC size.</description>
              <bitRange>[20:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FINE_MODE</name>
              <description>Operational mode for Fine CAPDAC</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>REFERENCE</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>COMPENSATION</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CLOCK_REF_RATE</name>
              <description>Used to select clk_mod or clk_mod/2 to as clk_ref. This clock is gated depending on the synchronised comparator to generate the gated feedback clock (clk_reffb) to the Reference CAPDAC.
'0': Use clk_mod.
'1': Use clk_mod/2.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>CLK_MOD</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALF_CLK_MOD</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>FL_EN</name>
              <description>Dither/Flatspot LFSR enable control.

'0': Dither/Flatspot LFSR is disabled. LFSR_SCALE_FL, LFSR_SCALE_TYPE_FL and ACTIVATION_MODE and MSB manipulation logic have no effect. The hard IP is presented with the code programmed into SEL_FL.

'1': The Dither/Flatspot LFSR is enabled.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LFSR_SCALE_FL</name>
              <description>Shift the magnitude portion of the Flatspot/Dither CAPDAC LFSR output code left or right by LSFR_SCALE_FL bits. Direction of shift controlled by LFSR_SCALE_TYPE_FL.

Note since the magnitude is 7-bits, the maximum shift is 6-bits. The sign bit does not form part of the shift.

Example: 6-bit polynomial (x^6 + x^4 + x^3 + x^2 + 1).

lfsr_fl_out[7] = lfsr_fl[5]; // Sign bit always connected in MSB to HardIP.
if(LFSR_SCALE_TYPE_FL == LEFT)
  lfsr_out[6:0] = {2'b00,lfsr[4:0]} &lt;&lt; LFSR_SCALE_FL; // Scaled 7-bit magnitude.
else
  lfsr_out[6:0] = {2'b00,lfsr[4:0]} &gt;&gt; LFSR_SCALE_FL; // Scaled 7-bit magnitude.</description>
              <bitRange>[26:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAX</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LFSR_SCALE_TYPE_FL</name>
              <description>Flatspot/Dither CAPDAC shift direction.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RIGHT</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LEFT</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>SNS_CTL</name>
          <description>Sense Control and Command Register</description>
          <addressOffset>0x220</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0xC000FE00</resetValue>
          <resetMask>0xFFFFFFF7</resetMask>
          <fields>
            <field>
              <name>START_SCAN</name>
              <description>Start the MSCv3 sequencer scan process. The sequencer will clear this bit when it is done. Depending on the mode the sequencer is done when all NUM_SAMPLES for this scan have been accumulated, or if the sequencer is reset.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>VALID</name>
              <description>Indicator of sensor configuration validity.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LAST</name>
              <description>Indicator that current sensor configuration is the last sensor in the frame.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MULTI_CH_MODE</name>
              <description>Multi channel mode configuration. Determines whether consensus mechanism is engaged to ensure channels scan in lockstep. 
'0': Single channel.
'1': Wait for external sync (off-chip). 
'2': Wait for internal sync (on-chip).</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXTERNAL</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INTERNAL</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SENSE_MODE_SEL</name>
              <description>Sense mode register structure selection. This field allows quick change between registers that influence sense mode. This register selects which structure is currently 'live' and used by the IP.

These registers are captured in MODE_STRUCT. The usable values in this register is determined by design time parameter SENSE_MODE_NR.</description>
              <bitRange>[7:6]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SENSE_MODE_0</name>
                  <description>Use MODE_STRUCT[0].</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SENSE_MODE_1</name>
                  <description>Use MODE_STRUCT[1].</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SENSE_MODE_2</name>
                  <description>Use MODE_STRUCT[2].</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SENSE_MODE_3</name>
                  <description>Use MODE_STRUCT[3].</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DECIM_RATE</name>
              <description>Sets the decimation rate for the sinc^2 filter (CIC2). Typically referred to as N. Note N = DECIM_RATE + 1. Only applies when FILTER_CTL.FILTER_MODE = CIC2, and irrelevant for CIC1 mode (no effect in this mode).

Maximum value out of CIC2 is N^2 (unsigned input) and +/- N^2 (signed input).

Since CIC2 uses a 16-bit pipeline, the maximum range is [0,2^16-1] (unsigned) and [-2^15,2^15-1] (signed). This implies a limitation on maximum usable DECIM_RATE depending on BIT_FORMAT signed/unsigned.

BIT_FORMAT = UNSIGNED -&gt; DECIM_RATE(max) = 254 (N = 255).
BIT_FORMAT = SIGNED -&gt; DECIM_RATE(max) = 180 (N = 181).

The scan time for M-bit scan is 2^M clk_mod cycles. This value is determined by (SENSE_DIV+1)*(NUM_SUB_CONVS+1).

Note that the CIC2 filter does not operate in the EPILOGUE state, so NUM_EPI_CYCLES does not feed into the above equation.</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SENSE_DIV</name>
              <description>The length (minus 1) of the sense modulation 'clock' period in clk_mod cycles (frequency = Fs). SENSE_DIV + 1 = sense_ratio.
Note this is the base divider, clock dithering may change the actual period length.

Firmware Rule: Firmware is responsible for programming a value in this register to ensure correct operation. When LFSR_MODE = DIRECT_CLOCK, in 2-phase mode sense_ratio needs to be &gt;=4 to allow for digital non-overlap. In 4-phase mode, sense_ratio needs to be &gt;=8. 

If spread spectrum is enabled (LFSR_MODE = SPREAD_SPECTRUM), SENSE_DIV must be programmed large enough to ensure that negative dithering does not cause sense_ratio to become too small.

It is possible for SENSE_DIV to be as low as zero though when LFSR_MODE = PRS (if digital non-overlap is disabled). This is because in PRS mode, SENSE_DIV defines the rate at which the LFSR is clocked and the MSB of the LFSR is used to create the phase signals.</description>
              <bitRange>[27:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>LFSR_MODE</name>
              <description>Mode for generating the sense clock.
'0': Direct Clocking.
'1': Spread Spectrum.
'2': PRS.</description>
              <bitRange>[29:28]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DIRECT_CLOCK</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SPREAD_SPECTRUM</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PRS</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LFSR_BITS</name>
              <description>Selects the number of LSB bits to use from the LSFR to provide the clock dithering variation on the base period (spread spectrum mode). 
Caveat make sure that SENSE_DIV &gt; the maximum absolute range (e.g. for 4B  SENSE_DIV &gt; 8), otherwise results are undefined.</description>
              <bitRange>[31:30]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>2B</name>
                  <description>Use 2 bits: range = [-2,1]</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>3B</name>
                  <description>Use 3 bits: range = [-4,3]</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>4B</name>
                  <description>Use 4 bits: range = [-8,7]</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>5B</name>
                  <description>Use 5 bits: range = [-16,15] (default)</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <dim>32</dim>
          <dimIncrement>4</dimIncrement>
          <name>SW_SEL_CSW[%s]</name>
          <description>Control Switch MUX Switch Control</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xCF0F3F0F</resetMask>
          <fields>
            <field>
              <name>SW_SNCA</name>
              <description>Control MUX Sensor N to CSD Bus A Switch.

Firmware Rule: See rule for ENABLED.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_TWO_PHASE</name>
                  <description>chop == 0 ? ph0 : ph1</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_FOUR_PHASE</name>
                  <description>chop == 0 ? ph1 : ph3</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_MPSC_D</name>
                  <description>chop == 0 ? ph3 : ph1</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_MPRX</name>
                  <description>chop == 0 ? ph1 : ph0</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH3</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK_BAR</name>
                  <description>chop == 0 ? clk_extfb : clk_extfb_bar</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK</name>
                  <description>chop == 1 ? clk_extfb : clk_extfb_bar</description>
                  <value>9</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_SNCB</name>
              <description>Control MUX Sensor N to CSD Bus B Switch.

Firmware Rule: See rule for ENABLED.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_TWO_PHASE</name>
                  <description>chop == 0 ? ph1 : ph0</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_FOUR_PHASE</name>
                  <description>chop == 0 ? ph3 : ph1</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_MPSC_D</name>
                  <description>chop == 0 ? ph1 : ph3</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_MPRX</name>
                  <description>chop == 0 ? ph0 : ph1</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK_BAR</name>
                  <description>chop == 0 ? clk_extfb : clk_extfb_bar</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK</name>
                  <description>chop == 1 ? clk_extfb : clk_extfb_bar</description>
                  <value>9</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_SNCC</name>
              <description>Control MUX Sensor N to CSD Bus C Switch.

Firmware Rule: See rule for ENABLED.</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1_OR_PH3</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_SNCV</name>
              <description>Control MUX Sensor N to vdda_q Switch.

Firmware Rule: Do not program SNCV and SNCG such that they are closed simultaneously.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>N/A</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0_OR_PH1</name>
                  <description>N/A</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0X</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1X</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0_OR_FS2PH0_AND_PH1_OR_PH3</name>
                  <description>ph0 || [Fs2_ph0 &amp;&amp; (ph1 || ph3)]</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK</name>
                  <description>clk_extfb</description>
                  <value>9</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_SNCG</name>
              <description>Control MUX Sensor N to vssa_q Switch.

Firmware Rule: Do not program SNCV and SNCG such that they are closed simultaneously.</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>N/A</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1_OR_PH3</name>
                  <description>N/A</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2_OR_PH3</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0X</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1X</name>
                  <description>N/A</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2_OR_FS2PH1_AND_PH1_OR_PH3</name>
                  <description>ph2 || [Fs2_ph1 &amp;&amp; (ph1 || ph3)]</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK_BAR</name>
                  <description>clk_extfb_bar</description>
                  <value>10</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>REF_MODE</name>
              <description>Control MUX Sensor N is used as a reference.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENABLED</name>
              <description>Control MUX Sensor N enable.

Firmware Rule:
1) If any of SNCA/SNCB/SNCC can be 1 (statically or dynamically), ENABLED must be 1.
2) If statically closing (using CLOSED setting) any of SNCA/SNCB/SNCC, ENABLE must be set to 1 in a previous bus access to ensure break-before-make. When re-opening from static CLOSED, SNCA/SNCB/SNCC must be opened in a previous bus access before clearing ENABLE to 0. This is not required for dynamic programming options since e.g. PH0 is not active when these registers are programmed.
3) In any use case where SNCA/SNCB/SNCC are required to be set CLOSED via autonomous scanning, rule (2) cannot be observed. Example use case below**. In this scenario to get the desired effect, the options are to either:
a) Dedicate a specific CSW sensor for this purpose, follow rule (2) and do not change the settings autonomously for this sensor.
b) Use unused Cmod switches (e.g. if Cmod1/2 are being used, use the switches for Cmod3/4).

** Any use case where a csdbusa/b/c is not used. For example FW CSX wherein csdbusc not used; then csdbusc is statically connected to vssa_sc (SNCG=CLOSED, ENABLED=1 and SNCC=CLOSED).</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <dim>8</dim>
          <dimIncrement>4</dimIncrement>
          <name>SW_SEL_CSW_FUNC[%s]</name>
          <description>Control Switch MUX Switch Control Global Functions</description>
          <addressOffset>0x400</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xCF0F3F0F</resetMask>
          <fields>
            <field>
              <name>SW_SNCA</name>
              <description>Control MUX Sensor to CSD Bus A Switch.

Firmware Rule: See corresponding rule in SW_SEL_CSW.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_TWO_PHASE</name>
                  <description>chop == 0 ? ph0 : ph1</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_FOUR_PHASE</name>
                  <description>chop == 0 ? ph1 : ph3</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_MPSC_D</name>
                  <description>chop == 0 ? ph3 : ph1</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_MPRX</name>
                  <description>chop == 0 ? ph1 : ph0</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH3</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK_BAR</name>
                  <description>chop == 0 ? clk_extfb : clk_extfb_bar</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK</name>
                  <description>chop == 1 ? clk_extfb : clk_extfb_bar</description>
                  <value>9</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_SNCB</name>
              <description>Control MUX Sensor to CSD Bus B Switch.

Firmware Rule: See corresponding rule in SW_SEL_CSW.</description>
              <bitRange>[11:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_TWO_PHASE</name>
                  <description>chop == 0 ? ph1 : ph0</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_FOUR_PHASE</name>
                  <description>chop == 0 ? ph3 : ph1</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_MPSC_D</name>
                  <description>chop == 0 ? ph1 : ph3</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_MPRX</name>
                  <description>chop == 0 ? ph0 : ph1</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK_BAR</name>
                  <description>chop == 0 ? clk_extfb : clk_extfb_bar</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CHOP_CLK</name>
                  <description>chop == 1 ? clk_extfb : clk_extfb_bar</description>
                  <value>9</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_SNCC</name>
              <description>Control MUX Sensor to CSD Bus C Switch.

Firmware Rule: See corresponding rule in SW_SEL_CSW.</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1_OR_PH3</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_SNCV</name>
              <description>Control MUX Sensor to vdda_q Switch.

Firmware Rule: Do not program SNCV and SNCG such that they are closed simultaneously.</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>N/A</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0_OR_PH1</name>
                  <description>N/A</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0X</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1X</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0_OR_FS2PH0_AND_PH1_OR_PH3</name>
                  <description>ph0 || [Fs2_ph0 &amp;&amp; (ph1 || ph3)]</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK</name>
                  <description>clk_extfb</description>
                  <value>9</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SW_SNCG</name>
              <description>Control MUX Sensor to vssa_q Switch.

Firmware Rule: Do not program SNCV and SNCG such that they are closed simultaneously.</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OPEN</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLOSED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1</name>
                  <description>N/A</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2</name>
                  <description>N/A</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1_OR_PH3</name>
                  <description>N/A</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2_OR_PH3</name>
                  <description>N/A</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH0X</name>
                  <description>N/A</description>
                  <value>7</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH1X</name>
                  <description>N/A</description>
                  <value>8</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>PH2_OR_FS2PH1_AND_PH1_OR_PH3</name>
                  <description>ph2 || [Fs2_ph1 &amp;&amp; (ph1 || ph3)]</description>
                  <value>9</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CLK_BAR</name>
                  <description>clk_extfb_bar</description>
                  <value>10</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>REF_MODE</name>
              <description>Control MUX Sensor is used as a reference.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENABLED</name>
              <description>Control MUX Sensor enable.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>3</dim>
          <dimIncrement>32</dimIncrement>
          <name>MODE[%s]</name>
          <description>Sense Mode Configuration Structure</description>
          <addressOffset>0x00000500</addressOffset>
          <register>
            <name>SENSE_DUTY_CTL</name>
            <description>Sense Clock Duty Cycle Control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1100077F</resetMask>
            <fields>
              <field>
                <name>PHASE_GAP_PH0_EN</name>
                <description>Decide whether clk_mod cycle non-overlap gap is applied at the end of ph0.

PHASE_GAP_PH0_EN = 0 -&gt; No gap.
PHASE_GAP_PH0_EN = 1 &amp;&amp; PH_GAP_2CYCLE_EN = 0 -&gt; 1x cycle gap.
PHASE_GAP_PH0_EN = 1 &amp;&amp; PH_GAP_2CYCLE_EN = 1 -&gt; 2x cycle gap.

Does not apply to signals controlled by SW_SEL_CSD and SW_SEL_DSI since GPIO has in-built non-overlap circuitry.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLED</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ENABLED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PHASE_GAP_PH1_EN</name>
                <description>Decide whether clk_mod cycle non-overlap gap is applied at the end of ph1.

PHASE_GAP_PH1_EN = 0 -&gt; No gap.
PHASE_GAP_PH1_EN = 1 &amp;&amp; PH_GAP_2CYCLE_EN = 0 -&gt; 1x cycle gap.
PHASE_GAP_PH1_EN = 1 &amp;&amp; PH_GAP_2CYCLE_EN = 1 -&gt; 2x cycle gap.

Does not apply to signals controlled by SW_SEL_CSD and SW_SEL_DSI since GPIO has in-built non-overlap circuitry.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLED</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ENABLED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PHASE_GAP_PH2_EN</name>
                <description>Decide whether clk_mod cycle non-overlap gap is applied at the end of ph2.

PHASE_GAP_PH2_EN = 0 -&gt; No gap.
PHASE_GAP_PH2_EN = 1 &amp;&amp; PH_GAP_2CYCLE_EN = 0 -&gt; 1x cycle gap.
PHASE_GAP_PH2_EN = 1 &amp;&amp; PH_GAP_2CYCLE_EN = 1 -&gt; 2x cycle gap.

Does not apply to signals controlled by SW_SEL_CSD and SW_SEL_DSI since GPIO has in-built non-overlap circuitry.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLED</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ENABLED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PHASE_GAP_PH3_EN</name>
                <description>Decide whether clk_mod cycle non-overlap gap is applied at the end of ph3.

PHASE_GAP_PH3_EN = 0 -&gt; No gap.
PHASE_GAP_PH3_EN = 1 &amp;&amp; PH_GAP_2CYCLE_EN = 0 -&gt; 1x cycle gap.
PHASE_GAP_PH3_EN = 1 &amp;&amp; PH_GAP_2CYCLE_EN = 1 -&gt; 2x cycle gap.

Does not apply to signals controlled by SW_SEL_CSD and SW_SEL_DSI since GPIO has in-built non-overlap circuitry.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLED</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ENABLED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PHASE_GAP_FS2_PH0_EN</name>
                <description>Decide whether clk_mod cycle non-overlap gap is applied at the end of Fs2_ph0.

PHASE_GAP_FS2_PH0_EN = 0 -&gt; No gap.
PHASE_GAP_FS2_PH0_EN = 1 &amp;&amp; PH_GAP_2CYCLE_EN = 0 -&gt; 1x cycle gap.
PHASE_GAP_FS2_PH0_EN = 1 &amp;&amp; PH_GAP_2CYCLE_EN = 1 -&gt; 2x cycle gap.

Does not apply to signals controlled by SW_SEL_CSD and SW_SEL_DSI since GPIO has in-built non-overlap circuitry.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLED</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ENABLED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PHASE_GAP_FS2_PH1_EN</name>
                <description>Decide whether clk_mod cycle non-overlap gap is applied at the end of Fs2_ph0.

PHASE_GAP_FS2_PH1_EN = 0 -&gt; No gap.
PHASE_GAP_FS2_PH1_EN = 1 &amp;&amp; PH_GAP_2CYCLE_EN = 0 -&gt; 1x cycle gap.
PHASE_GAP_FS2_PH1_EN = 1 &amp;&amp; PH_GAP_2CYCLE_EN = 1 -&gt; 2x cycle gap.

Does not apply to signals controlled by SW_SEL_CSD and SW_SEL_DSI since GPIO has in-built non-overlap circuitry.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLED</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ENABLED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PH_GAP_2CYCLE_EN</name>
                <description>If set, applies a two cycle gap on ph0/ph1/ph2/ph3/Fs2_ph0/Fs2_ph1 if the corresponding PHASE_GAP_*_EN is set.</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>ONE_CYCLE</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TWO_CYCLE</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PHASE_GAP_PH0X_EN</name>
                <description>Decide whether clk_mod cycle non-overlap gap is applied at the end of ph0x.

PHASE_GAP_PH0X_EN = 0 -&gt; No gap.
PHASE_GAP_PH0X_EN = 1 &amp;&amp; PHX_GAP_2CYCLE_EN = 0 -&gt; 1x cycle gap.
PHASE_GAP_PH0X_EN = 1 &amp;&amp; PHX_GAP_2CYCLE_EN = 1 -&gt; 2x cycle gap.

Does not apply to signals controlled by SW_SEL_CSD and SW_SEL_DSI since GPIO has in-built non-overlap circuitry.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLED</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ENABLED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PHASE_GAP_PH1X_EN</name>
                <description>Decide whether clk_mod cycle non-overlap gap is applied at the end of ph1x.

PHASE_GAP_PH1X_EN = 0 -&gt; No gap.
PHASE_GAP_PH1X_EN = 1 &amp;&amp; PHX_GAP_2CYCLE_EN = 0 -&gt; 1x cycle gap.
PHASE_GAP_PH1X_EN = 1 &amp;&amp; PHX_GAP_2CYCLE_EN = 1 -&gt; 2x cycle gap.

Does not apply to signals controlled by SW_SEL_CSD and SW_SEL_DSI since GPIO has in-built non-overlap circuitry.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLED</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ENABLED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PHX_GAP_2CYCLE_EN</name>
                <description>If set, applies a two cycle gap on ph0X/ph1X if the corresponding PHASE_GAP_*_EN is set.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>ONE_CYCLE</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TWO_CYCLE</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PHASE_SHIFT_EN</name>
                <description>Enable phase shift logic that generates the Ph0X and Ph1X waveforms. Used for inductive and impedance sensing.

If enabled, PHASE_SHIFT_CYCLES must be  &gt; 0.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLED</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ENABLED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>PHASE_MODE_SEL</name>
                <description>Select 4-phase or 2-phase mode.
'0': Four phase.
'1': Two phase.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>FOUR_PHASE</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TWO_PHASE</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>SW_SEL_CDAC_FL</name>
            <description>Flatspot/Dither CAPDAC Switch Control</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80777377</resetMask>
            <fields>
              <field>
                <name>SW_FLTCA</name>
                <description>Flatspot/Dither CAPDAC top plate to CSD Bus A Switch</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CHOP_PH1_4PHASE</name>
                    <description>chop == 1 ? ph1 : ph3</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CHOP_PH3</name>
                    <description>chop == 1 ? ph3 : ph1</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CHOP_PH0</name>
                    <description>chop == 1 ? ph0 : ph1</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CHOP_PH1_2PHASE</name>
                    <description>chop == 1 ? ph1 : ph0</description>
                    <value>5</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SW_FLCB</name>
                <description>Flatspot/Dither CAPDAC to CSD Bus B Switch</description>
                <bitRange>[6:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CHOP_PH1_4PHASE</name>
                    <description>chop == 1 ? ph1 : ph3</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CHOP_PH3</name>
                    <description>chop == 1 ? ph3 : ph1</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CHOP_PH0</name>
                    <description>chop == 1 ? ph0 : ph1</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CHOP_PH1_2PHASE</name>
                    <description>chop == 1 ? ph1 : ph0</description>
                    <value>5</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SW_FLTV</name>
                <description>Flatspot/Dither CAPDAC top plate to vdda_q Switch.

Firmware Rule: Do not program FLTV and FLTG such that they are closed simultaneously.</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH0</name>
                    <description>DFT mode</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH2</name>
                    <description>DFT mode</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SW_FLTG</name>
                <description>Flatspot/Dither CAPDAC top plate to vssa_q Switch.


Firmware Rule: Do not program FLTV and FLTG such that they are closed simultaneously.</description>
                <bitRange>[14:12]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH1</name>
                    <description>N/A</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH0_OR_PH2</name>
                    <description>N/A</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH0</name>
                    <description>DFT mode</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH2</name>
                    <description>DFT mode</description>
                    <value>5</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SW_FLBV</name>
                <description>Flatspot/Dither CAPDAC bottom plate to vdda_q Switch.

Firmware Rule: Do not program FLBV and FLBG such that they are closed simultaneously.

Notes: 
1) Equations below describe 'msb' term as raw LFSR output, and take into account overriding as defined by ACTIVATION_MODE.
2) Glitches on FLBV or FLBG during ph0 or ph2 are acceptable (if msb toggles at this time) as the FLTCA and FLCB switches are open during this phase so there is no connection into the comparator or the Cmod caps.</description>
                <bitRange>[18:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH0X</name>
                    <description>N/A</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH1X</name>
                    <description>N/A</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PRECHARGE_2_PH</name>
                    <description>[(msb^ph1)^(ph0||ph1)] &amp; [ph0||ph1]</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PRECHARGE_2_PH_BAR</name>
                    <description>(![(msb^ph1)^(ph0||ph1)]) &amp; [ph0||ph1]</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PRECHARGE_4_PH</name>
                    <description>[(msb^(ph2||ph3))^(ph0||ph2)] &amp; [ph0||ph1||ph2||ph3]</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PRECHARGE_4_PH_BAR</name>
                    <description>(![(msb^(ph2||ph3))^(ph0||ph2)]) &amp; [ph0||ph1||ph2||ph3]</description>
                    <value>7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SW_FLBG</name>
                <description>Flatspot/Dither CAPDAC bottom plate to vssa_q Switch.

Firmware Rule: Do not program FLBV and FLBG such that they are closed simultaneously.

Notes:
1) Equations below describe 'msb' term as raw LFSR output, and take into account overriding as defined by ACTIVATION_MODE.
2) Glitches on FLBV or FLBG during ph0 or ph2 are acceptable (if msb toggles at this time) as the FLTCA and FLCB switches are open during this phase so there is no connection into the comparator or the Cmod caps.</description>
                <bitRange>[22:20]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH0X</name>
                    <description>N/A</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH1X</name>
                    <description>N/A</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PRECHARGE_2_PH</name>
                    <description>[(msb^ph1)^(ph0||ph1)] &amp; [ph0||ph1]</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PRECHARGE_2_PH_BAR</name>
                    <description>(![(msb^ph1)^(ph0||ph1)]) &amp; [ph0||ph1]</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PRECHARGE_4_PH</name>
                    <description>[(msb^(ph2||ph3))^(ph0||ph2)] &amp; [ph0||ph1||ph2||ph3]</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PRECHARGE_4_PH_BAR</name>
                    <description>(![(msb^(ph2||ph3))^(ph0||ph2)]) &amp; [ph0||ph1||ph2||ph3]</description>
                    <value>7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ACTIVATION_MODE</name>
                <description>Activation event for Dither/Flatspot LFSR.
'0': Clock LFSR on ph0.
'1': Clock LFSR on ph0 or ph2.

Notes:
PH0 activation can be used in both 2 and 4 phase mode (PHASE_MODE_SEL).
PH0_OR_PH2 activation can be used in 4 phase mode only (PHASE_MODE_SEL).

In PH0 activation mode, the LFSR clocks on ph0 only. However hardware autonomously intervenes by processing the LFSR MSB before routing to the HardIP as follows during any given sense period:

PHASE_MODE_SEL = TWO_PHASE:
Invert LFSR MSB on ph1 rising edge.

PHASE_MODE_SEL = FOUR_PHASE:
Invert LFSR MSB on ph2 rising edge.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>PH0</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH0_OR_PH2</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>SW_SEL_TOP</name>
            <description>Top Level Switch Control</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xEFFFFF55</resetMask>
            <fields>
              <field>
                <name>CACB</name>
                <description>CSD Bus A to CSD Bus B Switch.

Note that hardware overrides MMIO setting for CACB and sets it CLOSED during the INIT_SHORT state if using GPIO sensors (SW_DSI_CMOD != OPEN || SW_DSI_CSHTANK != OPEN || AYA_EN == CLOSED || AYB_EN == CLOSED).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CACC</name>
                <description>CSD Bus A to CSD Bus C Switch</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CBCC</name>
                <description>CSD Bus B to CSD Bus C Switch</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MBCC</name>
                <description>AMUXBUSB to CSD Bus C Switch</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AYA_CTL</name>
                <description>AMUXBUS A to CSD Bus A Switch. Controls second part of AYA switch (AYA_EN&lt;1&gt; on hardIP).
Alternative to using dsi_cmod in GPIO mode.

Note that hardware overrides MMIO setting for AYA and sets it CLOSED during the INIT_SHORT state if using GPIO sensors (SW_DSI_CMOD != OPEN || SW_DSI_CSHTANK != OPEN || AYA_EN == CLOSED || AYB_EN == CLOSED). This register is wired to the hard IP directly (no MUX required in soft IP).</description>
                <bitRange>[10:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>Opens second part of AYA switch.
Enables isolation on AYA if AYA_EN is also OPEN_ISOLATED.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CHOP_TWO_PHASE</name>
                    <description>chop == 0 ? ph0 : ph1</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CHOP_FOUR_PHASE</name>
                    <description>chop == 0 ? ph1 : ph3</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CHOP_MPSC_D</name>
                    <description>chop == 0 ? ph3 : ph1</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CHOP_MPRX</name>
                    <description>chop == 0 ? ph1 : ph0</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH0</name>
                    <description>N/A</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH2</name>
                    <description>N/A</description>
                    <value>7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AYA_EN</name>
                <description>AMUXBUS A to CSD Bus A Switch. Controls the first part of AYA switch (AYA_EN&lt;0&gt; on the hardIP).

This register is wired to the hard IP directly (no MUX required in soft IP).</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN_ISOLATED</name>
                    <description>Opens first part of AYA switch.
Enables isolation on AYA if AYA_CTL is also OPEN.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>Closes first part of AYA switch and disables isolation.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AYB_CTL</name>
                <description>AMUXBUS A to CSD Bus B Switch. Controls second part of AYB switch (AYB_EN&lt;1&gt; on hardIP).
Alternative to using dsi_csh_tank in GPIO mode.</description>
                <bitRange>[14:12]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>Opens second part of AYB switch.
Enables isolation on AYB if AYB_EN is also OPEN_ISOLATED.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CHOP_TWO_PHASE</name>
                    <description>chop == 0 ? ph1 : ph0</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CHOP_FOUR_PHASE</name>
                    <description>chop == 0 ? ph3 : ph1</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CHOP_MPSC_D</name>
                    <description>chop == 0 ? ph1 : ph3</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CHOP_MPRX</name>
                    <description>chop == 0 ? ph0 : ph1</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH0</name>
                    <description>N/A</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH2</name>
                    <description>N/A</description>
                    <value>7</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AYB_EN</name>
                <description>AMUXBUS A to CSD Bus B Switch. Controls first part of AYB switch (AYB_EN&lt;0&gt; on the hardIP). 

This register is wired to the hard IP directly (no MUX required in soft IP).</description>
                <bitRange>[15:15]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN_ISOLATED</name>
                    <description>Opens first part of AYB switch.
Enables isolation on AYB if AYB_CTL is also OPEN.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>Closes first part of AYB switch and disables isolation.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BYB</name>
                <description>AMUXBUS B to CSD Bus B Switch.

This register is wired to the hard IP directly (no MUX required in soft IP).</description>
                <bitRange>[17:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN_ISOLATED</name>
                    <description>sel = 00</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>OPEN_NON_ISOLATED_CSDBUS</name>
                    <description>sel = 01</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>OPEN_NON_ISOLATED_AMUXBUS</name>
                    <description>sel = 10</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>sel = 11</description>
                    <value>3</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SOSH</name>
                <description>COAX Shield to Shield Buffer Output Switch</description>
                <bitRange>[19:18]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH1_OR_PH3</name>
                    <description>N/A</description>
                    <value>2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SHV</name>
                <description>COAX Shield to vdda_q Switch</description>
                <bitRange>[23:20]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH0</name>
                    <description>N/A</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH1</name>
                    <description>N/A</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH2</name>
                    <description>N/A</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH3</name>
                    <description>N/A</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH0X</name>
                    <description>N/A</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH1X</name>
                    <description>N/A</description>
                    <value>7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH0_OR_FS2PH0_AND_PH1_OR_PH3</name>
                    <description>ph0 || [Fs2_ph0 &amp;&amp; (ph1 || ph3)]</description>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH2_OR_FS2PH1_AND_PH1_OR_PH3</name>
                    <description>ph2 || [Fs2_ph1 &amp;&amp; (ph1 || ph3)]</description>
                    <value>9</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SHG</name>
                <description>COAX Shield to vssa_q Switch</description>
                <bitRange>[27:24]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH0</name>
                    <description>N/A</description>
                    <value>2</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH1</name>
                    <description>N/A</description>
                    <value>3</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH2</name>
                    <description>N/A</description>
                    <value>4</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH3</name>
                    <description>N/A</description>
                    <value>5</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH0X</name>
                    <description>N/A</description>
                    <value>6</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH1X</name>
                    <description>N/A</description>
                    <value>7</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH0_OR_FS2PH0_AND_PH1_OR_PH3</name>
                    <description>ph0 || [Fs2_ph0 &amp;&amp; (ph1 || ph3)]</description>
                    <value>8</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PH2_OR_FS2PH1_AND_PH1_OR_PH3</name>
                    <description>ph2 || [Fs2_ph1 &amp;&amp; (ph1 || ph3)]</description>
                    <value>9</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BGRF</name>
                <description>Bandgap Reference to Filter Switch</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>RMF</name>
                <description>Ratiometric Reference to Filter Switch</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MBF</name>
                <description>AMUXBUSB to Filter Switch</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>SW_SEL_COMP</name>
            <description>MSC Comparator Switch Control</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x80555555</resetMask>
            <fields>
              <field>
                <name>CPCS1</name>
                <description>Comparator Plus Terminal to CMOD1 Sense Switch</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CPCS3</name>
                <description>Comparator Plus Terminal to CMOD3 Sense Switch</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CPMA</name>
                <description>Comparator Plus Terminal to AMUXBUSA Switch</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CPCA</name>
                <description>Comparator Plus Terminal to CSD Bus A Switch</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CPCB</name>
                <description>Comparator Plus Terminal to CSD Bus B Switch</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CMCB</name>
                <description>Comparator Minus Terminal to CSD Bus B Switch</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CPF</name>
                <description>Comparator Plus Terminal to Reference Filter Switch</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CMCS2</name>
                <description>Comparator Minus Terminal to CMOD2 Sense Switch</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CMCS4</name>
                <description>Comparator Minus Terminal to CMOD4 Sense Switch</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CMV</name>
                <description>Comparator Minus Terminal to vdda_q Switch.

Firmware Rule: Do not program CMV and CMG such that they are closed simultaneously.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CMG</name>
                <description>Comparator Minus Terminal to vssa_q Switch.

Firmware Rule: Do not program CMV and CMG such that they are closed simultaneously.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CMF</name>
                <description>Comparator Minus Terminal to Reference Filter Switch</description>
                <bitRange>[22:22]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>HALF_WAVE_EN</name>
                <description>Enables halfwave mode in the comparator where reference is vdda_q.

Firmware Rule: When HALF_WAVE_EN = ENABLED, CHOP_POL must be programmed to 1 in the case where INIT_MODE = REFERENCE_VDDA.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLED</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ENABLED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>SW_SEL_SH</name>
            <description>Shielding Switch Control</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x7000000</resetValue>
            <resetMask>0x8F055555</resetMask>
            <fields>
              <field>
                <name>C1SHG</name>
                <description>cmod1_2_sh to vssa Switch</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>C1SH</name>
                <description>cmod1_2_sh to sh Switch (Drives cmod1_2_sh with shield signal)</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>C3SHG</name>
                <description>cmod3_4_sh to vssa Switch</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>C3SH</name>
                <description>cmod3_4_sh to sh Switch (Drives cmod3_4_sh with shield signal)</description>
                <bitRange>[6:6]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SOMB</name>
                <description>Shield OpAmp to AMUXBUSB Switch</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CBSO</name>
                <description>CSD Bus B to Shield OpAmp Switch</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SPCS1</name>
                <description>Shield Positive Terminal to CMOD1 Sense Switch</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>SPCS3</name>
                <description>Shield Positive Terminal to CMOD3 Sense Switch</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>FSP</name>
                <description>Reference Filter to Shield Positive Terminal Switch</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>CCSO</name>
                <description>CSD Bus C to Shield OpAmp Switch</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>OPEN</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CLOSED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BUF_SEL</name>
                <description>Selects value of compensation capacitance in shield buffer.</description>
                <bitRange>[27:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BUF_EN</name>
                <description>Enable the shield buffer.
'0': Off
'1': On</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLED</name>
                    <description>N/A</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ENABLED</name>
                    <description>N/A</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <dim>4096</dim>
          <dimIncrement>4</dimIncrement>
          <name>SENSOR_DATA[%s]</name>
          <description>Sensor Configuration Storage</description>
          <addressOffset>0x1000</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>DATA</name>
              <description>Local IP storage to support per-sensor configuration for AS-MS mode. Storage requirement in bytes is CONFIG_NR * (number of per sensor registers) * 4. The per sensor registers all have the prefix SNS_*.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM_CTL</name>
          <description>Trim Control</description>
          <addressOffset>0xFF00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>TRIM_IN</name>
              <description>Controls magnitude of comparator offset trim.</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIM_EN</name>
              <description>Enables comparator offset trim.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLED</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ENABLED</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>TRIM_POLARITY</name>
              <description>Controls polarity of comparator offset trim.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>LPCOMP</name>
      <description>Low Power Comparators</description>
      <baseAddress>0x402B0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>ID</name>
          <description>ID &amp; Revision</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x1E0E0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>ID</name>
              <description>the ID of LPCOMP peripheral is 0xE0E0</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>REVISION</name>
              <description>the version number is 0x0001</description>
              <bitRange>[31:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CONFIG</name>
          <description>LPCOMP Configuration Register</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x33FFFF</resetMask>
          <fields>
            <field>
              <name>MODE1</name>
              <description>Operating mode for the comparator</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SLOW</name>
                  <description>Slow operating mode (uses less power, &lt;50uA)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FAST</name>
                  <description>Fast operating mode (uses more power, &lt;400uA)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ULP</name>
                  <description>Ultra low power operting mode (uses ~2-4uA)</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HYST1</name>
              <description>Add 10mV hysteresis to the comparator
- 0: Enable Hysteresis
- 1: Disable Hysteresis</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FILTER1</name>
              <description>N/A</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INTTYPE1</name>
              <description>Sets which edge will trigger an IRQ</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>Disabled, no interrupts will be detected</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RISING</name>
                  <description>Rising edge</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FALLING</name>
                  <description>Falling edge</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BOTH</name>
                  <description>Both rising and falling edges</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OUT1</name>
              <description>Current output value of the comparator.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ENABLE1</name>
              <description>Enable comparator #1</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE2</name>
              <description>Operating mode for the comparator</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SLOW</name>
                  <description>Slow operating mode (uses less power, &lt;50uA)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FAST</name>
                  <description>Fast operating mode (uses more power, &lt;400uA)</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ULP</name>
                  <description>Ultra low power operting mode (uses ~2-4uA)</description>
                  <value>2</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>HYST2</name>
              <description>Add 10mV hysteresis to the comparator
- 0: Enable Hysteresis
- 1: Disable Hysteresis</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FILTER2</name>
              <description>N/A</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INTTYPE2</name>
              <description>Sets which edge will trigger an IRQ</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>Disabled, no interrupts will be detected</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RISING</name>
                  <description>Rising edge</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FALLING</name>
                  <description>Falling edge</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BOTH</name>
                  <description>Both rising and falling edges</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OUT2</name>
              <description>Current output value of the comparator.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>ENABLE2</name>
              <description>Enable comparator #2</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_BYPASS1</name>
              <description>Opamp1 bypass comparator output synchronization for DSI output: 0=synchronize (level or pulse), 1=bypass (output async)
Note that in DeepSleep mode this bit needs to be set to observe the DSI output on the dedicated pin.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_LEVEL1</name>
              <description>Opamp1 comparator DSI (trigger) out level : 0=pulse, 1=level</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_BYPASS2</name>
              <description>Opamp2 bypass comparator output synchronization for DSI output: 0=synchronize (level or pulse), 1=bypass (output async)
Note that in DeepSleep mode this bit needs to be set to observe the DSI output on the dedicated pin.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_LEVEL2</name>
              <description>Opamp2 comparator DSI (trigger) out level : 0=pulse, 1=level</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>LPCOMP Interrupt request register</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>COMP1</name>
              <description>Comparator 1 Interrupt: hardware sets this interrupt when comparator 0 triggers. Write with '1' to clear bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP2</name>
              <description>Comparator 2 Interrupt: hardware sets this interrupt when comparator 0 triggers. Write with '1' to clear bit.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>LPCOMP Interrupt set register</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>COMP1</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP2</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>LPCOMP Interrupt request mask</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>COMP1_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP2_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>LPCOMP Interrupt request masked</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>COMP1_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>COMP2_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM1</name>
          <description>LPCOMP Trim Register</description>
          <addressOffset>0xFF00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>COMP1_TRIMA</name>
              <description>Trim A for Comparator #1</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM2</name>
          <description>LPCOMP Trim Register</description>
          <addressOffset>0xFF04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>COMP1_TRIMB</name>
              <description>Trim B for Comparator #1</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM3</name>
          <description>LPCOMP Trim Register</description>
          <addressOffset>0xFF08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>COMP2_TRIMA</name>
              <description>Trim A for Comparator #2</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TRIM4</name>
          <description>LPCOMP Trim Register</description>
          <addressOffset>0xFF0C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1F</resetMask>
          <fields>
            <field>
              <name>COMP2_TRIMB</name>
              <description>Trim B for Comparator #2</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>LIN0</name>
      <description>LIN</description>
      <headerStructName>LIN</headerStructName>
      <baseAddress>0x402D0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>ERROR_CTL</name>
          <description>Error control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80EF001F</resetMask>
          <fields>
            <field>
              <name>CH_IDX</name>
              <description>Specifies the channel index of the channel to which HW  injected channel transmitter errors applies.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_SYNC_ERROR</name>
              <description>The synchronization field is changed from 0x55 to 0x00.

At the receiver, this should result in INTR.RX_HEADER_SYNC_ERROR activation.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_SYNC_STOP_ERROR</name>
              <description>The synchronization field STOP bits are inverted to '0'.

At the receiver, this should result in INTR.RX_HEADER_SYNC_ERROR or INTR.RX_HEADER_FRAME_ERROR activation.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PARITY_ERROR</name>
              <description>In LIN mode, the PID parity bit P[1] is inverted from !(ID[5] ^ ID[4] ^ ID[3] ^ ID[1]) to (ID[5] ^ ID[4] ^ ID[3] ^ ID[1]).

At the receiver, this should result in INTR.RX_HEADER_PARITY_ERROR activation.

In UART mode, a data field's parity bit is inverted.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PID_STOP_ERROR</name>
              <description>The PID field STOP bits are inverted to '0'.

At the receiver, this should result in INTR.RX_HEADER_FRAME_ERROR activation.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_DATA_STOP_ERROR</name>
              <description>The data field STOP bits are inverted to '0'.

At the receiver, this should result in INTR.RX_RESPONSE_FRAME_ERROR activation.

Note: Used in UART mode.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_CHECKSUM_ERROR</name>
              <description>The checksum field is inverted.

At the receiver, this should result in INTR.RX_RESPONSE_CHECKSUM_ERROR activation.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_CHECKSUM_STOP_ERROR</name>
              <description>The checksum field STOP bits are inverted to '0'.

At the receiver, this should result in INTR.RX_RESPONSE_FRAME_ERROR activation.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>Error injection enable:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TEST_CTL</name>
          <description>Test control</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8001001F</resetMask>
          <fields>
            <field>
              <name>CH_IDX</name>
              <description>Specifies the channel index of the channel to which test applies. The channel IO signals of channel indices CH_IDX and CH_NR-1 are connected as specified by MODE. CH_IDX should be in the range [0, CH_NR-2], as channel index CH_NR-1 is always involved in test and cannot be connected to itself. The test mode allows BOTH of the two connected channels to be tested.

Note: this testing functionality simplifies SW development, but may also be used in the field to verify correct channel functionality.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>Test mode:
'0': Partial disconnect from IOSS. This mode's isolation allows for device test without relying on an external LIN transceiver. The IOSS 'tx' IO cell can be used to observe messages outside of the device.
- tx_in[CH_IDX] = IOSS lin_tx_in[CH_IDX].
- tx_in[CH_NR-1] = IOSS lin_tx_in[CH_IDX].
- rx_in[CH_IDX] = IOSS lin_tx_in[CH_IDX].
- rx_in[CH_NR-1] = IOSS lin_tx_in[CH_IDX].
- lin_tx_out[CH_IDX] = tx_out[CH_IDX] &amp; tx_out[CH_NR-1].
- lin_tx_out[CH_NR-1] = tx_out[CH_IDX] &amp; tx_out[CH_NR-1].

'1': Full disconnect from IOSS (the IOSS/HSIOM should disconnect 'tx_out' from the 'tx' IO cell). This mode's isolation allows for device test without effecting an operational LIN cluster.
- tx_in[CH_IDX] = lin_tx_out[CH_IDX].
- tx_in[CH_NR-1] = lin_tx_out[CH_IDX].
- rx_in[CH_IDX] = lin_tx_out[CH_IDX].
- rx_in[CH_NR-1] = lin_tx_out[CH_IDX].
- lin_tx_out[CH_IDX] = tx_out[CH_IDX] &amp; tx_out[CH_NR-1].
- lin_tx_out[CH_NR-1] = tx_out[CH_IDX] &amp; tx_out[CH_NR-1].</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>Test enable:
'0': Disabled. Functional mode.
- tx_in[CH_IDX] = IOSS lin_tx_in[CH_IDX].
- tx_in[CH_NR-1] = IOSS lin_tx_in[CH_NR-1].
- rx_in[CH_IDX] = IOSS lin_rx_in[CH_IDX].
- rx_in[CH_NR-1] = IOSS lin_rx_in[CH_NR-1].
- lin_tx_out[CH_IDX] = tx_out[CH_IDX].
- lin_tx_out[CH_NR-1] = tx_out[CH_NR-1].
'1': Enabled. Test mode, specific test mode is specified by MODE.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>2</dim>
          <dimIncrement>256</dimIncrement>
          <name>CH[%s]</name>
          <description>LIN channel structure</description>
          <addressOffset>0x00008000</addressOffset>
          <register>
            <name>CTL0</name>
            <description>Control 0</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x400C0101</resetValue>
            <resetMask>0xF91F0313</resetMask>
            <fields>
              <field>
                <name>STOP_BITS</name>
                <description>STOP bit periods:
'0': 1/2 bit period.
'1': 1 bit period.
'2': 1 1/2 bit period.
'3': 2 bit periods.


In LIN mode, this field should be set to '1' (the default value) . 

In UART mode, this field can be programmed as desired.

Note: receiver STOP bit frame errors can only be detected if the number of STOP bit periods is 1 or more bit period.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>AUTO_EN</name>
                <description>LIN transceiver auto enable:
'0': Disabled.
'1': Enabled. The TX_RX_STATUS.EN_OUT field is controlled by HW.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BREAK_DELIMITER_LENGTH</name>
                <description>In LIN mode, this field specifies the break delimiter length:
(used in header transmission, not used in header reception).
'0': 1 bit period.
'1': 2 bit periods (default value).
'2': 3 bit periods.
'3': 4 bit periods.

In UART mode, this field specifies the data field size:
'0': 5 bit data field.
'1': 6 bit data field.
'2': 7 bit data field.
'3': 8 bit data field.
When the data field size is less than 8 bits, the most significant (unused) bits of the DATAx.DATAy[7:0] fields should be set to '0' for the transmitter.</description>
                <bitRange>[9:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BREAK_WAKEUP_LENGTH</name>
                <description>Break/wakeup length (minus 1) in bit periods:
'0': 1 bit period.
...
'10': 11 bit periods (break length for slave nodes)
...
'12': 13 bit periods (break length for master nodes)
...
'30': 31 bit periods.
'31': Illegal (should NOT be used!!!)

This field is used for transmission/reception of BOTH break and wakeup signals. Note that these functions are mutually exclusive:
- When CMD.TX_HEADER is '1', the field specifies the transmitted break field.
- When CMD.TX_WAKEUP is '1', the field specifies the transmitted wakeup field.
- When CMD.RX_HEADER is '1', the field specifies the to be received break field.
- Otherwise, the field specifies the to be received wakeup field.

Per the standard, the master wakeup duration is between 250 us and 5 ms. To support uncalibrated slaves, a slave has a detection threshold of 150 us (3 bit periods at 20 kbps). After transmission of a break or wakeup signal, the INTR.TX_BREAK_WAKEUP_DONE interrupt cause is activated. After reception of a wakeup signal, the INTR.RX_BREAK_WAKEUP_DONE interrupt cause is activated.

To specify longer wakeup signals in terms of absolute time (us/ms rather than bit periods), the associated PERI clock divider value can be (temporarily) increased to make the LIN bit period longer.

Note: entering bus sleep mode is achieved with the 'go-to-sleep' command.</description>
                <bitRange>[20:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>MODE</name>
                <description>Mode of operation:
'0': LIN mode.
'1': UART mode.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>LIN</name>
                    <description>LIN mode.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>UART</name>
                    <description>UART mode.</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>BIT_ERROR_IGNORE</name>
                <description>Specifies behavior on a detected bit error during header or response transmission:
'0': Message transfer is aborted.
'1': Message transfer is NOT aborted.

Note: this field does NOT effect the reporting of the bit error through INTR/STATUS.TX_HEADER/RESPONSE_BIT_ERROR; i.e. bit errors are always reported.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PARITY</name>
                <description>Parity mode:
'0': Even parity: even number of '1' bits (including parity).
'1': Odd parity.

Note: Used in UART mode only.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PARITY_EN</name>
                <description>Parity generation enable:
'0': Disabled. No parity bit is transferred.
'1': Enabled. The parity bit is transferred after the last (most significant) data field bit.

Note: Used in UART mode only.</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FILTER_EN</name>
                <description>RX filter (for 'lin_rx_in'):
'0': No filter.
'1': Median 3 (default value) operates on the last three 'lin_rx_in' values. The sequences '000', '001', '010' and '100' result in a filtered value '0'. The sequences '111', '110', '101' and '011' result in a filtered value '1'.</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED</name>
                <description>Channel enable:
'0': Disabled. If a channel is disabled, all non-retained MMIO registers (e.g. the TX_RX_STATUS, and INTR registers) have their fields reset to their default value.
'1': Enabled.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CTL1</name>
            <description>Control 1</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3000000</resetMask>
            <fields>
              <field>
                <name>DATA_NR</name>
                <description>Number of data fields (minus 1) in the response (not including the checksum):
'0': 1 data field.
'1': 2 data fields.
...
'7': 8 data fields.

Note: master and slave nodes need to agree upon the number of data fields before message transfer.
In RX_RESPONSE case, When PID (header) is received, firmware has the time of one response data byte, to modify CTL1.DATA_NR.</description>
                <bitRange>[2:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CHECKSUM_ENHANCED</name>
                <description>Checksum mode:
'0': Classic mode. PID field is NOT included in the checksum calculation.
'1': Enhanced mode. PID field is included in the checksum calculation. This mode requires special attention when the master node transmits the header and a (different) slave node transmits the response: the slave node will use the calculated partial checksum over the received PID field as a starting point for the calculation over the to be transmitted data fields.

Note: If the frame identifier ID[5:0] is 0x3c or 0x3d, the classic mode will ALWAYS be used for transmission and assumed for reception, independent of the CHECKSUM_ENHANCED value.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FRAME_TIMEOUT</name>
                <description>Specifies the maximum allowed length (timeout value) for a frame, frame header or frame response in bit periods. The LIN specification prescribes to set the maximum length to 1.4x the nominal length (Theader_max = 1.4 x Theader_nom and Tresponse_max = 1.4 x Tresponse_nom). The nominal header length Theader_nom is 34 bit periods and the nominal response length Tresponse_nom is 10 * (data_nr + 1) bit periods (data_nr is the number of data fields) 

Note: the LIN specification specifies the following: 'Tools and tests shall check the Tframe_max (= Theader_max + Tresponse_max). Nodes shall not check this time. The receiving node of the frame shall accept the frame up to the next frame slot (i.e. next break field), even if it is longer then Tframe_max).'</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FRAME_TIMEOUT_SEL</name>
                <description>Specifies the frame timeout mode:
'0': No timeout functionality (default value).
'1': Frame mode: detects timeout from the start of break field to checksum field STOP bits (inclusive). The minimum FRAME_TIMEOUT value is 34+20 bit periods (header and a response with 1 data field).
'2': Frame header mode: detects timeout from the start of break field to PID field STOP bits (inclusive). The minimum FRAME_TIMEOUT value is 34 bit periods (header).
'3': Frame response mode: detects timeout from the PID field STOP bits (exclusive) to checksum field STOP bits (the response space is included in the frame response). The minimum FRAME_TIMEOUT value is 20 bit periods (response with 1 data field).</description>
                <bitRange>[25:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>STATUS</name>
            <description>Status</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F03333F</resetMask>
            <fields>
              <field>
                <name>DATA_IDX</name>
                <description>Number of transferred data and checksum fields in the response (also acts as an index/address into response data field and checksum field registers (DATA0, DATA1, PID_CHECKSUM)) :
'0': No data fields transferred.
'1': Data field 1 transferred.
...
'7': Data fields 1, 2, 3, ... and 7 transferred.
'8':  Data fields 1, 2, 3, ... and 8 transferred.
'9': Data fields 1, 2, 3, ..., 8 and checksum field transferred.
'10'-'15': Unused.

Set to '0' on the start of a TX_HEADER or RX_HEADER command.</description>
                <bitRange>[3:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>HEADER_RESPONSE</name>
                <description>Frame header / response identifier (only valid when TX_BUSY or RX_BUSY is '1'):
'0': Frame header being transferred.
'1': Frame response being transferred.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_DATA0_FRAME_ERROR</name>
                <description>Frame response, first data field frame error. HW sets this field to '1'  when the received STOP bits of the first response data field have an unexpected value (only after a RX_HEADER command), and this data byte is 0x00. HW clears this field to '0' at the falling edge of SYNC start bit (after INTR.RX_HEADER_BREAK_WAKEUP_DONE). This field is used together with INTR.RX_RESPONSE_FRAME_ERROR to distinguish 'no response', 'error response' and 'correct response' scenarios.

Note: The ongoing message transfer is NOT aborted.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_BUSY</name>
                <description>Transmitter busy.
- Set to '1' on the start of the following commands: TX_HEADER, TX_RESPONSE, TX_WAKEUP.
- Set to '0' on successful completion of previous commands or when an error is detected. In the successful completion case, TX_BUSY is updated one cycle after TX_DONE.
   In 'TX_HEADER, RX_RESPONSE' case, set to '0' at the start bit falling edge in the first response data byte, after header transmission</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_BUSY</name>
                <description>Receiver busy.
- Set to '1' on the start of the following commands: RX_HEADER, RX_RESPONSE.
   in RX_HEADER case, set at Break filed rising edge.
   in RX_RESPONSE case, set at the start bit falling edge in the first response data byte.

- Set to '0' on successful completion of previous commands or when an error is detected. In the successful completion case, RX_BUSY is updated one cycle after RX_DONE.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_DONE</name>
                <description>Transmitter done:
- Set to '0' on the start of a new command.
- Set to '1' on successful completion of the following command sequences (if CTL.AUTO_EN is '1', this includes the 4-bit period external transceiver disable post-amble):
- TX_HEADER.
- TX_HEADER, TX_RESPONSE.
- RX_HEADER, TX_RESPONSE.
- TX_WAKEUP.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_DONE</name>
                <description>Receiver done:
- Set to '0' on the start of a new command.
- Set to '1' on successful completion of the following command sequences (if CTL.AUTO_EN is '1', this includes the 4-bit period external transceiver disable post-amble):
- RX_HEADER, RX_RESPONSE.
- TX_HEADER, RX_RESPONSE.</description>
                <bitRange>[13:13]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_HEADER_BIT_ERROR</name>
                <description>Copy of INTR.TX_HEADER_BIT_ERROR.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_RESPONSE_BIT_ERROR</name>
                <description>Copy of INTR.TX_RESPONSE_BIT_ERROR.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_HEADER_FRAME_ERROR</name>
                <description>Copy of INTR.RX_HEADER_FRAME_ERROR.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_HEADER_SYNC_ERROR</name>
                <description>Copy of INTR.RX_HEADER_SYNC_ERROR.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_HEADER_PARITY_ERROR</name>
                <description>Copy of INTR.RX_HEADER_PARITY_ERROR.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_RESPONSE_FRAME_ERROR</name>
                <description>Copy of INTR.RX_RESPONSE_FRAME_ERROR.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_RESPONSE_CHECKSUM_ERROR</name>
                <description>Copy of INTR.RX_RESPONSE_CHECKSUM_ERROR.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CMD</name>
            <description>Command</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x307</resetMask>
            <fields>
              <field>
                <name>TX_HEADER</name>
                <description>SW sets this field to '1' to transmit a header. HW sets this field to '0' on successful completion of ANY of the following legal command sequences (also set to '0' when an error is detected):
- TX_HEADER
- TX_HEADER, TX_RESPONSE.
- TX_HEADER, RX_RESPONSE.
- RX_HEADER, TX_RESPONSE.
- RX_HEADER, RX_RESPONSE.
- TX_WAKEUP.

The header is transmitted when the PID field STOP bits are transmitted (INTR.TX_HEADER_DONE).

HW sets this field to '1', when the 'tr_cmd_tx_header' input trigger is activated. This allows for time triggered LIN message transfer. HW driven time triggered transfer eliminates the jitter that is typically associated with SW driven transfer.

In UART mode, a single data field (DATA0.DATA1) is transmitted.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_RESPONSE</name>
                <description>SW sets this field to '1' to transmit a response. HW sets this field to '0' on successful completion of ANY of the legal command sequences (also set to '0' when an error is detected).

The response is transmitted when the checksum field STOP bits are transmitted (INTR.TX_RESPONSE_DONE).</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_WAKEUP</name>
                <description>SW sets this field to '1' to transmit a wakeup signal. HW sets this field to '0' on successful completion of ANY of the legal command sequences (also set to '0' when an error is detected).

The command generates CTL.BREAK_WAKEUP_LENGTH bit periods in the dominant state (low/'0') and transitions to the recessive state (high/'1') (INTR.TX_WAKEUP_DONE).</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER</name>
                <description>SW sets this field to '1' to receive a header. HW sets this field to '0' on successful completion of the ANY of the legal command sequences (NOT set to '0' when an error is detected in LIN mode).

The header is received when the PID field STOP bits are received (INTR.RX_HEADER_DONE).

Typically, a slave node SW sets both RX_HEADER and RX_RESPONSE to '1', anticipating a transfer of a response from the master node to this slave node. After receipt of the header PID field (INTR.RX_HEADER_PID_DONE is activated), the slave node may decide to set TX_RESPONSE to '1' (which has a higher priority than RX_RESPONSE) to transmit a response.

the Break detection is performed regardless of CMD.RX_HEADER.
INTR.RX_BREAK_WAKEUP_DONE will trigger at LIN_RX rising edge, when the low pulse meet CTL0.BREAK_WAKEUP_LENGTH. when Break is detected, HW check CMD.RX_HEADER before entering SYNC byte processing state. when RX_HEADER is cleared, SW has at least 11 bit times to set RX_HEADER again, before next Break is detected (RX_BREAK_WAKEUP_DONE). in this case, there is no gap, Break will never be missed.


In UART mode, a single data field in received (in DATA0.DATA1). HW set this field to '0' when the data field is received, or when an error is detected.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_RESPONSE</name>
                <description>SW sets this field to '1' to receive a response. HW sets this field to '0' on successful completion of ANY of the legal command sequences (NOT set to '0' when an error is detected).

The response is received when the checksum field STOP bits are received (INTR.RX_RESPONSE_DONE).</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TX_RX_STATUS</name>
            <description>TX/RX status</description>
            <addressOffset>0x60</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x5000000</resetValue>
            <resetMask>0x5000000</resetMask>
            <fields>
              <field>
                <name>SYNC_COUNTER</name>
                <description>Synchronization counter in LIN channel clock periods. After the receipt of a synchronization field, this fields reflects the duration of the synchronization field. Ideally, SYNC_COUNTER = 8*16 = 128 (the synchronization fields consists of eight bit period of 16 LIN channel clock periods each).
- If SYNC_COUNTER is less than 128, the LIN channel clock is too slow and the PERI/PCLK divider value should be decreased.
- If SYNC_COUNTER is greater than 128, the LIN channel clock is too fast and the PERI/PCLK divider value should be increased.

The biggest master-slave clock discrepancy occurs when the master is slow and the slave is fast or vice versa. At a 0.5 percent master inaccuracy and a 14 percent slave inaccuracy, this results in the extreme synchronization values of (.86 * 128) / 1.005 = 109.5 and (1.14 *128) / 0.995 = 146.6. We add a little margin for a valid range of [106, 152].

Note: Only slave nodes with imprecise clocks require clock resynchronization. Master and slave nodes with precise clocks do NOT require clock resynchronization.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_IN</name>
                <description>LIN transmitter input ('tx_in', 'lin_tx_in' in functional mode). TX_IN and RX_IN can be used to determine a wakeup source. Note that wakeup source detection relies on the external transceiver functionality.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_IN</name>
                <description>LIN receiver input ('rx_in', 'lin_rx_in' in functional mode).</description>
                <bitRange>[17:17]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_OUT</name>
                <description>LIN transmitter output ('tx_out', 'lin_tx_out').</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EN_OUT</name>
                <description>LIN transceiver enable ('en_out', 'lin_en_out'). This field controls the enable (or low active sleep enable) of the external transceiver:
'0': Disabled.
'1': Enabled.

If CTL.AUTO_EN is '0', SW controls this field to enable the external transceiver. If CTL.AUTO_EN is '1', HW controls this field to enable the external transceiver:
- Before a legal command sequence, HW sets this field to '1', if it is '0'. The start of the command sequence is effectively postponed by a 4-bit period preamble.
- After a legal command sequence, HW clears this field to '0'. The end of the command sequence is effectively postponed by a 4-bit period postamble.

Note: external transceivers require a 'power up' or 'power down' period of 1 or 2 bit periods, so a 4-bit period suffices for all known transceivers.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>PID_CHECKSUM</name>
            <description>PID and checksum</description>
            <addressOffset>0x80</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>PID</name>
                <description>Header protected identifier (PID). 
- Bits 5 down to 0: frame identifier ID[5:0].
Frame identifier 0x3c is for a 'master request' frame, 0x3d is for a 'slave response' frame, 0x3e and 0x3f are for future LIN enhancements. Frame identifier ID[5:4] is optionally used for length control; i.e. specifies the number of response data fields.
- Bits 1 down to 0: parity bits P[1] and P[0].
  - P[1] = ! (ID[5] ^ ID[4] ^ ID[3] ^ ID[1])
  - P[0] = (ID[4] ^ ID[2] ^ ID[1] ^ ID[0])

Transmission: To be transmitted PID field. SW needs to calculate the PID field parity bits P[1] and P[0].

Reception: Received PID field. Slave node SW uses the PID field to determine how to handle the response for a received frame header: TX_RESPONSE or  RX_RESPONSE.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CHECKSUM</name>
                <description>Checksum.

Transmission: HW calculated checksum (SW does not need to calculate the checksum) over the transmitted PID field (optional per CTL.CHECKSUM_ENHANCED) and data fields.

Reception: Received checksum. Note that in case of a RX_CHECKSUM_ERROR, SW can use the received PID field and the  received data fields to calculate the correct checksum value.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DATA0</name>
            <description>Response data 0</description>
            <addressOffset>0x84</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA1</name>
                <description>Data field 1. 

Transmission: To be transmitted data field. SW provides data field.

Reception: Received data field. SW uses the data field.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA2</name>
                <description>Data field 2.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA3</name>
                <description>Data field 3.</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA4</name>
                <description>Data field 4.</description>
                <bitRange>[31:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DATA1</name>
            <description>Response data 1</description>
            <addressOffset>0x88</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA5</name>
                <description>Data field 5.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA6</name>
                <description>Data field 6.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA7</name>
                <description>Data field 7.</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DATA8</name>
                <description>Data field 8.</description>
                <bitRange>[31:24]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Interrupt</description>
            <addressOffset>0xC0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F036F07</resetMask>
            <fields>
              <field>
                <name>TX_HEADER_DONE</name>
                <description>HW sets this field to '1', when a frame header (break field, synchronization field and PID field) is transmitted (the CMD.TX_HEADER is completed). Specifically:
- When followed by CMD.TX_RESPONSE or CMD.RX_RESPONSE, this field is set to '1' after completion of the frame header transfer.
- When not followed by a response command, this field is set to '1' after completion of the frame header transfer. If CTL.AUTO_EN is '1', this includes the 4-bit period external transceiver disable post-amble.

Note: used in UART mode.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_RESPONSE_DONE</name>
                <description>HW sets this field to '1', when a frame response (data fields and checksum field) is transmitted (the CMD.TX_RESPONSE is completed). If CTL.AUTO_EN is '1', this includes the 4-bit period external transceiver disable post-amble.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_WAKEUP_DONE</name>
                <description>HW sets this field to '1', when a wakeup signal is transmitted (per CTL.BREAK_WAKEUP_LENGTH). This cause is activated on a transition from dominant/'0' state to recessive/'1' state; i.e. at the end of the wakeup signal.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_DONE</name>
                <description>HW sets this field to '1', when a frame header (break field, synchronization field and PID field) is received (the CMD.RX_HEADER is completed). Specifically:
- When followed by CMD.TX_RESPONSE or CMD.RX_RESPONSE, this field is set to '1' after completion of the frame header transfer.
- When not followed by a response command, this field is set to '1' after completion of the frame header transfer. If CTL.AUTO_EN is '1', this includes the 4-bit period external transceiver disable post-amble.

Note: used in UART mode.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_RESPONSE_DONE</name>
                <description>HW sets this field to '1', when a frame response (data fields and checksum field) is received (the CMD.RX_RESPONSE is completed). If CTL.AUTO_EN is '1', this includes the 4-bit period external transceiver disable post-amble.

Note: activation implies that RX_RESPONSE_FRAME_ERROR and RX_RESPONSE_CHECKSUM_ERROR are not activated during response reception</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_BREAK_WAKEUP_DONE</name>
                <description>HW sets this field to '1', when a break or wakeup signal is received (per CTL.BREAK_WAKEUP_LENGTH). This cause is activated on a transition from dominant/'0' state to recessive/'1' state; i.e. at the end of the wakeup signal.

The break or wakeup detection is always enabled, regardless of CMD register setting.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_SYNC_DONE</name>
                <description>HW sets this field to '1', when a synchronization field is received (including trailing STOP bits).</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_NOISE_DETECT</name>
                <description>HW sets this field to '1', when isolated '0' or '1' 'in_rx_in' values are observed or when during sampling the last three 'lin_rx_in' values do NOT all have the same value. This mismatch is an indication of noise on the LIN line.

Note: The ongoing frame transfer is NOT aborted.

Note: Used in UART mode.</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TIMEOUT</name>
                <description>HW sets this field to '1', when a frame, frame header or frame response timeout is detected (per CTL.FRAME_TIMEOUT_SEL).

Note: The ongoing frame transfer is NOT aborted.</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_HEADER_BIT_ERROR</name>
                <description>HW sets this field to '1', when a transmitted 'lin_tx_out' value does NOT match a received 'lin_rx_in' value (during header transmission). This specific test allows for delay through the external transceiver. This mismatch is an indication of bus collisions on the LIN line.

The match is performed for the Wakeup, Break, SYNC and the PID fields (for the START bit, data Byte and STOP bit).

Note: When CTL.BIT_ERROR_IGNORE is '0', the ongoing message transfer is aborted (INTR.TX_HEADER_DONE is NOT activated) and the TX_HEADER, TX_RESPONSE and TX_WAKEUP commands are set to '0'. 

Note: Used in UART mode.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_RESPONSE_BIT_ERROR</name>
                <description>HW sets this field to '1', when a transmitted 'lin_tx_out' value does NOT match a received 'lin_rx_in' value (during response transmission).

The match is performed for the data fields and the checksum field (for the START bit, data Byte and STOP bit).

Note: When CTL.BIT_ERROR_IGNORE is '0', the ongoing message transfer is aborted (INTR.TX_RESPONSE_DONE is NOT activated) and the TX_HEADER, TX_RESPONSE and TX_WAKEUP commands are set to '0'.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_FRAME_ERROR</name>
                <description>HW sets this field to '1', when the received START or STOP bits have an unexpected value (during header reception).

Note: The ongoing message transfer is aborted (INTR.RX_HEADER_DONE is NOT activated) and the TX_HEADER, TX_RESPONSE and TX_WAKEUP commands are set to '0'. 

Note: Used in UART mode.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_SYNC_ERROR</name>
                <description>HW sets this field to '1', when the received synchronization field is not received within the synchronization counter range [106, 152] (see TX_RX_STATUS.SYNC_COUNTER). 

Note: The ongoing message transfer is aborted (INTR.RX_HEADER_SYNC_DONE is NOT activated) and the TX_HEADER, TX_RESPONSE and TX_WAKEUP commands are set to '0'.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_PARITY_ERROR</name>
                <description>HW sets this field to '1', when the received PID field has a parity error. 

Note: The ongoing message transfer is aborted (INTR.RX_PID_DONE is NOT activated) and the TX_HEADER, TX_RESPONSE and TX_WAKEUP commands are set to '0'. 

+G119 HW sets this field to '1', when the received data field has a parity error (when CTL0.PARITY_EN is '1').</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_RESPONSE_FRAME_ERROR</name>
                <description>HW sets this field to '1', when the received START or STOP bits have an unexpected value (during response reception). HW does NOT use this field for the STOP bits of the first data field after a RX_HEADER command, if the received data byte is 0x00. (STATUS.RX_DATA0_FRAME_ERROR is used instead).

Note: The ongoing message transfer is aborted (INTR.RX_RESPONSE_DONE is NOT activated) and the TX_HEADER, TX_RESPONSE and TX_WAKEUP commands are set to '0'.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_RESPONSE_CHECKSUM_ERROR</name>
                <description>HW sets this field to '1', when the calculated checksum over the received PID and data fields is not the same as the received checksum. 

Note: The ongoing message transfer is aborted (INTR.RX_RESPONSE_DONE is NOT activated) and the TX_HEADER, TX_RESPONSE and TX_WAKEUP commands are set to '0'.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt set</description>
            <addressOffset>0xC4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F036F07</resetMask>
            <fields>
              <field>
                <name>TX_HEADER_DONE</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_RESPONSE_DONE</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_WAKEUP_DONE</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_DONE</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_RESPONSE_DONE</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_BREAK_WAKEUP_DONE</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_SYNC_DONE</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_NOISE_DETECT</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TIMEOUT</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_HEADER_BIT_ERROR</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_RESPONSE_BIT_ERROR</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_FRAME_ERROR</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_SYNC_ERROR</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_PARITY_ERROR</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_RESPONSE_FRAME_ERROR</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_RESPONSE_CHECKSUM_ERROR</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt mask</description>
            <addressOffset>0xC8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F036F07</resetMask>
            <fields>
              <field>
                <name>TX_HEADER_DONE</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_RESPONSE_DONE</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_WAKEUP_DONE</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_DONE</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_RESPONSE_DONE</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_BREAK_WAKEUP_DONE</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_SYNC_DONE</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_NOISE_DETECT</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TIMEOUT</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[14:14]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_HEADER_BIT_ERROR</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_RESPONSE_BIT_ERROR</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_FRAME_ERROR</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_SYNC_ERROR</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_PARITY_ERROR</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_RESPONSE_FRAME_ERROR</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_RESPONSE_CHECKSUM_ERROR</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt masked</description>
            <addressOffset>0xCC</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F036F07</resetMask>
            <fields>
              <field>
                <name>TX_HEADER_DONE</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_RESPONSE_DONE</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_WAKEUP_DONE</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_HEADER_DONE</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_RESPONSE_DONE</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_BREAK_WAKEUP_DONE</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_HEADER_SYNC_DONE</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_NOISE_DETECT</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[13:13]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TIMEOUT</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[14:14]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_HEADER_BIT_ERROR</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_RESPONSE_BIT_ERROR</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_HEADER_FRAME_ERROR</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_HEADER_SYNC_ERROR</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_HEADER_PARITY_ERROR</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_RESPONSE_FRAME_ERROR</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_RESPONSE_CHECKSUM_ERROR</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>CXPI0</name>
      <description>CXPI</description>
      <headerStructName>CXPI</headerStructName>
      <baseAddress>0x402E0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>ERROR_CTL</name>
          <description>Error control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x821C001F</resetMask>
          <fields>
            <field>
              <name>CH_IDX</name>
              <description>Specifies the channel index of the channel to which HW  injected channel transmitter errors applies.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_CRC_ERROR</name>
              <description>The crc field is inverted.

At the receiver, this should result in INTR.RX_CRC_ERROR activation.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_PID_PARITY_ERROR</name>
              <description>In cxpi mode, the PID parity bit P[1] is inverted from !(ID[5] ^ ID[4] ^ ID[3] ^ ID[1]) to (ID[5] ^ ID[4] ^ ID[3] ^ ID[1]).

At the receiver, this should result in INTR.RX_HEADER_PARITY_ERROR activation.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_DATA_LENGTH_ERROR</name>
              <description>The transmitter continues to send logical '0' (during IFS) after CRC field is transmitted.

At the receiver, this should result in INTR.RX_DATA_LENGTH_ERROR activation.
At the transmitter, this should result in INTR.TX_DATA_LENGTH_ERROR activation.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TX_DATA_STOP_ERROR</name>
              <description>The data field STOP bits are inverted to '0'.

At the receiver, this should result in INTR.RX_FRAME_ERROR activation.
At the transmitter, this should result in INTR.TX_FRAME_ERROR activation.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>Error injection enable:
'0': Disabled.
'1': Enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>TEST_CTL</name>
          <description>Test control</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x8001001F</resetMask>
          <fields>
            <field>
              <name>CH_IDX</name>
              <description>Specifies the channel index of the channel to which test applies. The channel IO signals of channel indices CH_IDX and CH_NR-1 are connected as specified by MODE. CH_IDX should be in the range [0, CH_NR-2], as channel index CH_NR-1 is always involved in test and cannot be connected to itself. The test mode allows BOTH of the two connected channels to be tested.

Note: this testing functionality simplifies SW development, but may also be used in the field to verify correct channel functionality.</description>
              <bitRange>[4:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MODE</name>
              <description>Test mode:
'0': Partial disconnect from IOSS. This mode's isolation allows for device test without relying on an external cxpi transceiver. The IOSS 'tx' IO cell can be used to observe messages outside of the device.
- tx_in[CH_IDX] = IOSS cxpi_tx_in[CH_IDX].
- tx_in[CH_NR-1] = IOSS cxpi_tx_in[CH_IDX].
- rx_in[CH_IDX] = IOSS cxpi_tx_in[CH_IDX].
- rx_in[CH_NR-1] = IOSS cxpi_tx_in[CH_IDX].
- cxpi_tx_out[CH_IDX] = tx_out[CH_IDX] &amp; tx_out[CH_NR-1].
- cxpi_tx_out[CH_NR-1] = tx_out[CH_IDX] &amp; tx_out[CH_NR-1].

'1': Full disconnect from IOSS (the IOSS/HSIOM should disconnect 'tx_out' from the 'tx' IO cell). This mode's isolation allows for device test without effecting an operational cxpi cluster.
- tx_in[CH_IDX] = cxpi_tx_out[CH_IDX].
- tx_in[CH_NR-1] = cxpi_tx_out[CH_IDX].
- rx_in[CH_IDX] = cxpi_tx_out[CH_IDX].
- rx_in[CH_NR-1] = cxpi_tx_out[CH_IDX].
- cxpi_tx_out[CH_IDX] = tx_out[CH_IDX] &amp; tx_out[CH_NR-1].
- cxpi_tx_out[CH_NR-1] = tx_out[CH_IDX] &amp; tx_out[CH_NR-1].</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>PARTIAL_DISCONNECT</name>
                  <description>Partial disconnect</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FULL_DISCONNECT</name>
                  <description>Full disconnect</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>ENABLED</name>
              <description>Test enable:
'0': Disabled. Functional mode.
- tx_in[CH_IDX] = IOSS cxpi_tx_in[CH_IDX].
- tx_in[CH_NR-1] = IOSS cxpi_tx_in[CH_NR-1].
- rx_in[CH_IDX] = IOSS cxpi_rx_in[CH_IDX].
- rx_in[CH_NR-1] = IOSS cxpi_rx_in[CH_NR-1].
- cxpi_tx_out[CH_IDX] = tx_out[CH_IDX].
- cxpi_tx_out[CH_NR-1] = tx_out[CH_NR-1].
'1': Enabled. Test mode, specific test mode is specified by MODE.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>FUNCTIONAL_MODE</name>
                  <description>Functional mode</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>TEST_MODE</name>
                  <description>Test mode</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <cluster>
          <dim>2</dim>
          <dimIncrement>256</dimIncrement>
          <name>CH[%s]</name>
          <description>CXPI channel structure</description>
          <addressOffset>0x00008000</addressOffset>
          <register>
            <name>CTL0</name>
            <description>Control 0</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x10</resetValue>
            <resetMask>0xC9FF0391</resetMask>
            <fields>
              <field>
                <name>MODE</name>
                <description>Mode of operation:
'0': NRZ mode.
'1': PWM mode.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>NRZ</name>
                    <description>NRZ mode</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>PWM</name>
                    <description>PWM mode</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>AUTO_EN</name>
                <description>CXPI transceiver auto enable:
'0': Disabled.
'1': Enabled. The TX_RX_STATUS.EN_OUT field is controlled by HW.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RXPIDZERO_CHECK_EN</name>
                <description>Receive PID Zero Check Enable.
0 - No action if received PID[6:0] = 0 and PID[7]=1'b1.
1 - If received PID[6:0] = 0 and PID[7]=1'b1, HW (slave) does not clear CMD.RX_HEADER and will anticipate receiving header again (CMD.TX_HEADER=0). If CMD.TX_HEADER=1 in the same scenario, then HW (slave) clears CMD.RX_HEADER upon receiving the header follow by transmit PID. This mode is useful for case where polling method is used and CXPI controller is configured as slave. This would reduce dependency on SW to react to the header received within IBS=1.</description>
                <bitRange>[7:7]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FILTER_EN</name>
                <description>RX filter enable (for 'cxpi_rx_in')
'0': No filter
'1': Median 3 (default value) operates on the last three 'cxpi_rx_in' values. The sequences '000', '001', '010', and '100' result in a filtered value '0'. The sequences '111', '110', '101', and '011' result in a filtered value '1'.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>PRESAMPLE_EN</name>
                <description>Pre-sample enable for PWM mode.
'0': Disbaled.
'1': Enabled
When sampling counter's value is greater than CTL1.T_LOW1, pre-sample FF will be set to '1' as long as detecting any '1' on 'cxpi_rx_in' and be cleared to '0' after sampling moment. At the sampling moment, if pre-sample FF or 'cxpi_rx_in' is '1', sample value will be '1', otherwise '0'.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IFS</name>
                <description>Inter Frame Space in bit periods:
'0'' Invalid.
...
'10': 10 bit periods
...
'31': 31 bit periods
Values of &lt;10 are not allowed.
This field is used for transmission/reception for adding waiting inter frame space. 
Note that after a valid transaction (after CRC), HW waits for 10 bits as EOF. Hence, by setting CTL0.IFS=0xA means that HW will wait for 10bits before transmitting a new transaction (not including the EOF).
Note: 0 is not allowed when IFS_WAIT=1. SW needs to ensure it has program valid values before it can set IFS_WAIT=1.
If IFS_WAIT=1 after timeout occurs, the value of CTL0.IFS would need to consider the timeout count i.e. (IFS needed - CTL2.TIMEOUT_LENGTH-1) to get the total idle time. For example if TIMEOUT_LENGTH=9 and IFS needed is 20, then CTL0.IFS is set to 10.</description>
                <bitRange>[20:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IBS</name>
                <description>Inter Byte Space in bit periods:
'0' No offset.
'1' 1 IBS is inserted per every byte frame.
...
'9' 9 IBS are inserted per every byte frame.
Values &gt;9 are invalid per spec.
This field is used to control number of IBS after every byte frame when transmitting message frame. 
Note that this field is the minimum IBS inserted for every byte frame as the SW may require some time to prepare the response when it receives the PID. 
When receiving, this field is ignored with the exception of receiving header and transmitting response. For receiving header and transmitting response, SW can enable IBS insertion by setting TIMEOUT_SEL=1/2 prior to setting CMD.RX_HEADER=1 and CMD.RX_RESPONSE=1. If the received header corresponds to transmit response, SW clears CMD.RX_RESPONSE =0 and sets TX FIFO and CMD.TX_RESPONSE=1. HW waits for minimum IBS before transmit response (if timeout has not occurred yet). It is prohibit to program IBS&gt;TIMEOUT_LENGTH. 
This field should not be changed during inflight transaction including EOF.</description>
                <bitRange>[24:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BIT_ERROR_IGNORE</name>
                <description>Specifies behavior on a detected bit error during header or response transmission:
'0': Message transfer is aborted.
'1': Message transfer is NOT aborted.

Note: This field does NOT effect the reporting of the bit error through INTR/STATUS.TX_BIT_ERROR; i.e. bit errors are always reported.
Note: This field must not be set to '1' when it is NRZ mode. This is due to delay in transceiver will cause the transmitter behavior undefined when error occurs.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>ABORT_TX_MSG</name>
                    <description>Message transfer is aborted</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>CONT_TX_MSG</name>
                    <description>Message transfer is NOT aborted</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>MASTER</name>
                <description>CXPI master mode.
'0': Indicates CXPI as slave node.
'1': Indicates CXPI as master node.
This bit is only valid if ENABLED=1. SW needs to set only 1 node as master within the same CXPI cluster. SW needs to set this bit either at the same time as ENABLED or before ENABLED is set. If SW needs to change the controller to different mode, it needs to make sure that HW is quiescent before doing so.</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>SLAVE_MODE</name>
                    <description>Slave mode</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>MASTER_MODE</name>
                    <description>Master mode</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
              <field>
                <name>ENABLED</name>
                <description>Channel enable:
'0': Disabled. If a channel is disabled, CMD, STATUS, INTR MMIO registers will have their fields reset to their default value.
'1': Enabled.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>DISABLED</name>
                    <description>Disabled</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>ENABLED</name>
                    <description>Enabled</description>
                    <value>1</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>CTL1</name>
            <description>Control 1</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7FDFF1FF</resetMask>
            <fields>
              <field>
                <name>T_LOW1</name>
                <description>Low count for logic 1. This is valid only for PWM mode.
For master node, The count value here indicates the number of clocks per clk_cxpi_ch to drive a '0' at CXPI bus before releasing it to indicate a logical '1'. For slave node and pre-sample enabled, the count value indicates the number of clocks per clk_cxpi_ch to disable pre-sampling.
0: means 1 clock.
1: means 2 clocks
..
15: means 16 clocks.
..
399: means 400 clocks.
Any value above 399 is invalid.
Note that for NRZ mode, this field is ignored.
Note that it must be set less than CTL1.T_OFFSET for slave node if pre-sample mode enabled.
Note that it is also effective for pre-sample mode of master node.</description>
                <bitRange>[8:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>T_LOW0</name>
                <description>Low count for logic 0. This is valid only for PWM mode.
The count value here indicates the number of clocks per clk_cxpi_ch to drive a '0' at CXPI bus before releasing it to indicate a logical '0'.
0: means 1 clock.
1: means 2 clocks
..
15: means 16 clocks
..
399: means 400 clocks
Any value above 399 is invalid.
Note that for NRZ mode, this field is ignored.
Note that this field is used for TX.</description>
                <bitRange>[20:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>T_OFFSET</name>
                <description>The value of offset that is used for sampling the 'rx'. 
The value of this counter is used in HW as below.

   - 0 : means 1 clock after detecting falling edge of 'rx'
   - 1 : means 2 clocks after detecting falling edge of 'rx'
   ..
   - 7 : means 8 clocks after detecting falling edge of 'rx'
   ..
  - 15 : means 16 clocks after detecting falling edge of 'rx'
   ..
  - 399 : means 400 clocks after detecting falling edge of 'rx'
Any value above 399 is invalid.</description>
                <bitRange>[30:22]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CTL2</name>
            <description>Control 2</description>
            <addressOffset>0x8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFFCF3F03</resetMask>
            <fields>
              <field>
                <name>RETRY</name>
                <description>Number of retries after arbitration lost.
'0': No retries.
..
'3': 3 retries.
HW will immediately retry after arbitration lost i.e. after the message frame that won the arbitration is complete and fulfilled IFS. If SW wants to manage the retransmission then SW can program RETRY =0. In this case, HW will not retry after arbitration lost and will set TX_HEADER_ARB_LOST bit. SW needs to trigger HW to resend by programming the CMD fields again.</description>
                <bitRange>[1:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>T_WAKEUP_LENGTH</name>
                <description>Specifies the wake up pulse low period in Tbits that is transmitted during Standby mode.
'0': 1 bit period
'1': 2 bit period
..
'49': 50 bit period
Any value above 49 is invalid. 
This field is only valid if TX_WAKE_PULSE is set to 1.</description>
                <bitRange>[13:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TIMEOUT_LENGTH</name>
                <description>Timeout Length (in Tbits). Specifies the number of Tbits to exceed timeout between frame bytes within a message frame. CXPI spec states that the maximum allowed inter byte space (IBS) is 9Tbits.  
This field is valid only when TIMEOUT_SEL=1/2.
'0' - 1Tbit
'1' - 2Tbits
..
'9' - 10Tbits
Values &gt;9 is invalid per CXPI spec.
Note for NRZ mode, although there are propagation delay from transceiver to CXPI controller, the delay is cancelled out as the timeout is compared on the RX (for transmit case, HW waits for the feedback on RX).</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RXTX_DELAY</name>
                <description>Insert addtional delay from the falling edge of RX to the falling edge of TX for slave node transmitting '0'. This is valid only for PWM mode.
The count value here indicates the number of clocks per clk_cxpi_ch.
0: None 
1: means 1 clock.
2: means 2 clocks.
...
255: means 255 clocks.
Note it must be set less than CTL1.T_LOW0. 
Note make sure that the falling edge of tx_out is ahead of the rising edge of master node clock when CTL0.PRESAMPLE_EN=1.</description>
                <bitRange>[29:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TIMEOUT_SEL</name>
                <description>Timeout Select. 
'0' - Timeout check is disabled. HW clears timeout counter.
'1' - Timeout check is enabled and HW will refer to TIMEOUT_LENGTH as number of Tbits allowed between header and response.
'2' - Timeout check is enabled to check header-header, header-response, and header-header-response within a message frame to be space within TIMEOUT_LENGTH bit time.
'3' - invalid
For '1', HW will restart/start timeout counter after transmitting/receiving header. HW will hold the counter if timeout until the next header is transmitted or received. Timeout will cause HW to stop transmission of the current message frame together with interrupt to SW. For receive, HW abort reception of the frame if timeout occurs while waiting for receiving response and notify SW with interrupt.
For '2', HW will re-start/start timeout counter after receiving any frame bytes within a message frame. HW will hold the counter if timeout until the IFS. Timeout will cause HW to stop transmission of the current message frame and notify SW with interrupt. For receive, HW will abort reception of the message frame if timeout occurs while waiting for receiving response and notify SW with interrupt.
For all cases, HW stops counting when it is out of a message frame such as IFS or CXPI bus IDLE. If the timeout counter &gt; TIMEOUT_LENGTH, then it will set the INTR.TIMEOUT=1. 
Note that, TIMEOUT_SEL=1/2 also enables the count for IBS between receive header and transmit response on top of timeout check.</description>
                <bitRange>[31:30]</bitRange>
                <access>read-write</access>
                <enumeratedValues>
                  <enumeratedValue>
                    <name>TIMEOUT_DISABLED</name>
                    <description>Timeout check is disabled.</description>
                    <value>0</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TIMEOUT_CHECK_BTW_HDR_RSP</name>
                    <description>Timeout check is enabled and HW will refer to TIMEOUT_LENGHT as number of Tbits allowed between header and response.</description>
                    <value>1</value>
                  </enumeratedValue>
                  <enumeratedValue>
                    <name>TIMEOUT_CHECK_BTW_HDR_HDR_RSP</name>
                    <description>Timeout check is enabled to check header-header, header-response, and header-header-response within a message frame to be space within TIMEOUT_LENGTH bit time.</description>
                    <value>2</value>
                  </enumeratedValue>
                </enumeratedValues>
              </field>
            </fields>
          </register>
          <register>
            <name>STATUS</name>
            <description>Status</description>
            <addressOffset>0xC</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7FFC3313</resetMask>
            <fields>
              <field>
                <name>RETRIES_COUNT</name>
                <description>Retries count. 
The value reflects the number of retries that HW tries to transmit a header/response. 
HW will reset counter (either case below):
1. after successfully transmit the retry attempt 
2. SW clears the CMD.TX_HEADER='0' 
3. HW clearing CMD.TX_HEADER=0 due to errors (TX_BIT_ERROR, TX_HEADER_ARB_LOST, TX_OVERFLOW_ERROR, TX_UNDERFLOW_ERROR, TX_DATA_LENGTH_ERROR, and TX_FRAME_ERROR)</description>
                <bitRange>[1:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>HEADER_RESPONSE</name>
                <description>Frame header/response identifier (only valid when TX_BUSY or RX_BUSY is '1')
'0' - Frame header being transferred.
'1' - Frame response being transferred.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_BUSY</name>
                <description>Transmitter busy.
- Set to '1' on the start of the following commands: TX_HEADER, TX_RESPONSE.
- Set to '0' on successful completion of previous commands or when an error is detected.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_BUSY</name>
                <description>Receiver busy.
- Set to '1' on the start of the following commands: RX_HEADER, RX_RESPONSE.
- Set to '0' on successful completion of previous commands or when an error is detected.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_DONE</name>
                <description>Transmitter done:
- Set to '0' on the start of a new command.
- Set to '1' on successful completion of the following command sequences:
- TX_HEADER.
- TX_HEADER, TX_RESPONSE.
- RX_HEADER, TX_RESPONSE.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_DONE</name>
                <description>Receiver done:
- Set to '0' on the start of a new command.
- Set to '1' on successful completion of the following commmand sequences:
- RX_HEADER, RX_RESPONSE.
- TX_HEADER, RX_RESPONSE.</description>
                <bitRange>[13:13]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TIMEOUT</name>
                <description>Copy of INTR.TIMEOUT</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_HEADER_ARB_LOST</name>
                <description>Copy of INTR.TX_HEADER_ARB_LOST</description>
                <bitRange>[19:19]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_BIT_ERROR</name>
                <description>Copy of INTR.TX_BIT_ERROR.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_CRC_ERROR</name>
                <description>Copy of INTR.RX_CRC_ERROR.</description>
                <bitRange>[21:21]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_HEADER_PARITY_ERROR</name>
                <description>Copy of INTR.RX_HEADER_PARITY_ERROR.</description>
                <bitRange>[22:22]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_DATA_LENGTH_ERROR</name>
                <description>Copy of INTR.RX_DATA_LENGTH_ERROR.</description>
                <bitRange>[23:23]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_DATA_LENGTH_ERROR</name>
                <description>Copy of INTR.TX_DATA_LENGTH_ERROR.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_OVERFLOW_ERROR</name>
                <description>Copy of INTR.RX_OVERFLOW_ERROR.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_OVERFLOW_ERROR</name>
                <description>Copy of INTR.TX_OVERFLOW_ERROR.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_UNDERFLOW_ERROR</name>
                <description>Copy of INTR.RX_UNDERFLOW_ERROR.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_UNDERFLOW_ERROR</name>
                <description>Copy of INTR.TX_UNDERFLOW_ERROR.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_FRAME_ERROR</name>
                <description>Copy of INTR.RX_FRAME_ERROR.</description>
                <bitRange>[29:29]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_FRAME_ERROR</name>
                <description>Copy of INTR.TX_FRAME_ERROR.</description>
                <bitRange>[30:30]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CMD</name>
            <description>Command</description>
            <addressOffset>0x10</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x33F</resetMask>
            <fields>
              <field>
                <name>TX_HEADER</name>
                <description>SW sets this field to '1' to transmit a header. HW sets this field to '0' on successful completion of ANY of the following legal command sequences (also set to '0' when an error (such as bit error if bit_ignore=0, arbitration loss, tx data length error. For timeout please refer to SAS) is detected):
- TX_HEADER
- TX_HEADER, TX_RESPONSE.
- TX_HEADER, RX_RESPONSE.
The above is for transmission of PID without prior transmission of PTYPE.
The header is transmitted when the PID field STOP bits are transmitted (INTR.TX_HEADER_DONE).

HW sets this field to '1', when the 'tr_cmd_tx_header' input trigger is activated. This allows for time triggered CXPI message transfer. HW driven time triggered transfer eliminates the jitter that is typically associated with SW driven transfer.
SW clears this field to '0', when it wants to cancel a pending request. Note that if SW clears this field to '0' while HW is already in the middle of the request, then the cancel will be ignored. The cancel request can happen when HW is pending a retry when it is still servicing the current transaction. Or the cancel request can occur when HW is checking IFS/bus idle-ness.
Note that if PTYPE (TX_HEADER) is transmitted follow by receive response (RX_RESPONSE) or no response, HW clears TX_HEADER right after transmitting PTYPE.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_RESPONSE</name>
                <description>SW sets this field to '1' to transmit a response. HW sets this field to '0' on successful completion of ANY of the legal command sequences (also set to '0' when an error is detected).
- TX_HEADER, TX_RESPONSE.
- RX_HEADER, TX_RESPONSE.

SW can also clear this field to '0' if SW wants to cancel the TX_RESPONSE. 

The response is transmitted when the CRC are transmitted (INTR.TX_RESPONSE_DONE).</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SLEEP</name>
                <description>SW sets this field to '1' to direct HW to sleep mode. HW transits from Normal to Sleep upon SLEEP=1 and both TX and RX is idle. HW sets this field to '0' when it is in Sleep mode. 

Note that, SW needs to manage the entry to sleep mode by checking the conditions are met before initiating sleep mode e.g. all slave nodes supports sleep and on transmitting sleep frames to indicate sleep to all slave nodes.SW shall not program SLEEP=1 when HW is executing TX_WAKEUP_PULSE command. If SW programs SLEEP=1 during HW executing TX_WAKEUP_PULSE command, it will cause HW to abruptly stop transmitting wakeup pulse as below:
1. HW not clearing TX_WAKEUP_PULSE
2. HW not setting TX_WAKEUP_DONE 
3. HW outputting TX_OUT=0.</description>
                <bitRange>[2:2]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>WAKE_TO_STANDBY</name>
                <description>SW sets this field to '1' to direct HW to wake up from Sleep mode to Standby mode. SW clears this field to '0' from '1' when it wants to direct HW from Standby to Normal mode. HW clears this field to '0' when it is in Normal mode or back to Sleep mode from Standby mode. 

For the case of CXPI master mode, HW will move its power mode from Sleep-&gt;Standby when this field is set to '1'. When SW clears this field is from '1' to '0' in Standby mode, HW will move to Normal mode while HW starts transmitting clock. To transmit wake pulse, SW need to program TX_WAKE_PULSE accordingly in Standby mode before entering Normal.
For the case of CXPI slave mode and PWM mode, HW will move power mode from Sleep-&gt;Standby when this field is set to '1'. HW will wait for detection of clock before moving from Standby-&gt;Normal. SW clearing this field to '0' will have no effect.
For the case of CXPI slave mode and NRZ mode, HW will move power mode from Sleep-&gt;Standby when this field is set to '1'. HW needs to be directed by SW by clearing this field to '0' to move from Standby-&gt;Normal after SW has detected clock through another IP (e.g. MXTCPWM).</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_WAKE_PULSE</name>
                <description>SW sets this field to '1' to direct HW to send wake up pulse. HW will transmit wake up pulse in Standby state only. HW will ignore this field when it's not in Standby state. 
'1' - HW will drive CXPI bus to low for period dictated by T_WAKEUP_LENGTH.
'0:'- No wake up pulse 
HW clears this field to '0' after it transmit the pulse per T_WAKEUP_LENGTH.
For the case where more than 1 wake pulses are required, SW is expected to set this field to '1' again (after this field is cleared to '0') per the number of times the wake pulse is required.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>IFS_WAIT</name>
                <description>SW sets this field to '1' to wait for IFS. HW clears this field to '0' after it detects logical '1' based on IFS. 

HW will keep this field to '1' if it detects logical '0' before fulfilling the number of logical '1' required. 

The intention of this bit is to provide capability for SW to direct HW to check bus idle-ness before transmitting. Without setting this bit before directing HW to send header, HW will not check bus idle before transmitting. Besides that, this bit will also provide SW an option to configure HW to wait for IFS before sending again PTYPE or PID to fulfill IFS if there is no response from other nodes. 
Note: SW needs to configure valid IFS values before setting IFS_WAIT=1.</description>
                <bitRange>[5:5]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER</name>
                <description>SW sets this field to '1' to receive a header. HW sets this field to '0' on successful completion of the ANY of the legal command sequences.
(Not set to '0' when an error is detected).
-RX_HEADER
-RX_HEADER, TX_RESPONSE
-RX_HEADER, RX_RESPONSE
The above applies for cases of receiving PID without prior receiving PTYPE.
The header is received when the PID field STOP bits are received (INTR.RX_HEADER_PID_DONE and INTR.RX_HEADER_DONE). 

Typically, a slave node SW sets both RX_HEADER and RX_RESPONSE to '1', anticipating a transfer of a response from the master node to this slave node. After receipt of the header PID/PTYPE field (INTR.RX_HEADER_PID_DONE is activated), the slave node may decide to set TX_RESPONSE to '1' (which has lower priority than RX_RESPONSE hence RX_RESPONSE need to be clear to '0' by SW) to transmit a response.
Note that, for cases with RXPIDZERO_CHECK_EN=1 for slave in polling mode, RX_HEADER is cleared upon receiving PTYPE if the next course of action is to transmit PID. If the next course of action is to receive PID, then the RX_HEADER is cleared upon completion of response.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_RESPONSE</name>
                <description>SW sets this field to '1' to receive a response. HW sets this field to '0' on successful completion of ANY of the legal command sequences (NOT set to '0' when an error is detected).
-TX_HEADER, RX_RESPONSE
-RX_HEADER, RX_RESPONSE

SW can set this field to '1' to be conservative on receiving response i.e. IBS=0 whenever it is receiving PID. If the PID corresponds to transmit response, the SW can then clear this field to '0' and set TX_RESPONSE=1 to direct HW to send response. 

The response is received after CRC are received (INTR.RX_RESPONSE_DONE).</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TX_RX_STATUS</name>
            <description>TX/RX status</description>
            <addressOffset>0x40</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x5000000</resetValue>
            <resetMask>0x5000000</resetMask>
            <fields>
              <field>
                <name>TX_IN</name>
                <description>CXPI transmitter input ('tx_in', 'cxpi_tx_in' in functional mode). TX_IN and RX_IN can be used to determine a wakeup source. Note that wakeup source detection relies on the external transceiver functionality.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_IN</name>
                <description>CXPI receiver input ('rx_in', 'cxpi_rx_in' in functional mode).</description>
                <bitRange>[17:17]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_OUT</name>
                <description>CXPI transmitter output ('tx_out', 'cxpi_tx_out').</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>EN_OUT</name>
                <description>CXPI transceiver enable ('en_out', 'cxpi_en_out'). This field controls the enable (or low active sleep enable) of the external transceiver:
'0': Disabled.
'1': Enabled.

If CTL0.AUTO_EN is '0', SW controls this field to enable the external transceiver. If CTL0.AUTO_EN is '1', HW controls this field to enable the external transceiver:
- HW sets this field to '1' when it is out of Sleep state. If it moves to Sleep state, HW will clear this field to '0'.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TXPID_FI</name>
            <description>TXPID and Frame Information</description>
            <addressOffset>0x50</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>PID</name>
                <description>Header protected identifier (PID). 
- Bits 6 downto 0: frame identifier ID[6:0].
- Bits 7: is odd parity bit.
  - PID[7] = ! (ID[6] ^ ID[5] ^ ID[4] ^ ID[3] ^ ID[2] ^ ID[1] ^ ID[0])
Software does not need to program the parity bit i.e. bit[7]. HW will calculate the odd parity bit and ignore the bit[7] if SW occupies this bit. 

Transmission: To be transmitted PID field. HW will ignore bit[7] and compute the parity bit based on bits[6:0]

Note that, this field can be use by SW to send PType byte as the HW handles both PID and PType the same way. The frame type would occupy bit[6:0] and the odd parity will be calculated by the HW.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FI</name>
                <description>Frame Information.

This is the byte that will be transmitted as Frame Information. Per CXPI spec, 
FI[7:4] denotes the data length count (DLC).
FI[3:2] denotes Network Management. Bit[3] - wakeup.ind Bit[2] - sleep.ind
FI[1:0] denotes CT. Please program to 2'b11 if no support of counter.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>DLCEXT</name>
                <description>Data Length Count Extension. 

This field is intended for payload of more than 12B. This field is only valid if DLC=4'b1111 (FI[7:4]). 

The value specified in this field will be the new payload size. Valid values are 0-255.</description>
                <bitRange>[23:16]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RXPID_FI</name>
            <description>RXPID and Frame Information</description>
            <addressOffset>0x54</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>PID</name>
                <description>Header protected identifier (PID). 
- Bits 6 downto 0: frame identifier ID[6:0].
- Bits 7: is odd parity bit.
  - PID[7] = ! (ID[6] ^ ID[5] ^ ID[4] ^ ID[3] ^ ID[2] ^ ID[1] ^ ID[0])

Reception: Received PID field. SW uses the PID field to determine how to handle the response for a received frame header: TX_RESPONSE or  RX_RESPONSE.

Note that, this field can be use by SW to check PType byte as the HW handles both PID and PType the same way. The frame type would occupy bit[6:0] and bit[7] is the parity bit of the frame type. This parity bit is send by the transmitting node.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>FI</name>
                <description>Frame Information.

This is the byte that is received as Frame Information. Per CXPI spec, 
FI[7:4] denotes the data length count (DLC).
FI[3:2] denotes Network Management. Bit[3] - wakeup.ind Bit[2] - sleep.ind
FI[1:0] denotes CT.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>DLCEXT</name>
                <description>Data Length Count Extension. 

This field is intended for payload of more than 12B. This field is only valid if DLC=4'b1111 (FI[15:12]). 

The value specified in this field will be the new payload size. Valid values are 0-255.</description>
                <bitRange>[23:16]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>CRC</name>
            <description>CRC</description>
            <addressOffset>0x58</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>RXCRC1</name>
                <description>CRC first byte for both CRC8 and CRC16. This is valid for both Normal frame and Long frame. 
HW will load this field with first byte of CRC upon receiving it.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RXCRC2</name>
                <description>CRC second byte of CRC16. This is valid only for Long frames.
HW will load this field with second byte of CRC upon receiving it.</description>
                <bitRange>[15:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TXCRC1</name>
                <description>CRC first byte for both CRC8 and CRC16. This is valid for both Normal frame and Long frame. 
HW will load this field with first byte of CRC for transmit.</description>
                <bitRange>[23:16]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TXCRC2</name>
                <description>CRC second byte of CRC16. This is valid only for Long frames.
HW will load this field with second byte of CRC for transmit.</description>
                <bitRange>[31:24]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TX_FIFO_CTL</name>
            <description>TX FIFO control</description>
            <addressOffset>0x80</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3001F</resetMask>
            <fields>
              <field>
                <name>TRIGGER_LEVEL</name>
                <description>Trigger level. When the TX FIFO has less entries than the number of this field, a transmitter trigger event is generated:
-INTR.TX_FIFO_TRIGGER = (#FIFO entries &lt; TRIGGER_LEVEL)</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CLEAR</name>
                <description>This is a synchronous clear signal to the TX FIFO. When '1', the TX FIFO content are cleared. If a quick clear is required, the field should be set to '1' and followed by '0'. If a clear is required for an extended time, the field should be set to 1 during the complete time.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FREEZE</name>
                <description>Freeze functionality:
'0': HW uses TX FIFO data and pops the data from the TX FIFO for every HW read.
'1': HW read from TX FIFO does not pop the data from the TX FIFO.
Note: Freeze functionality is for debug purpose only.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TX_FIFO_STATUS</name>
            <description>TX FIFO status</description>
            <addressOffset>0x84</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F</resetMask>
            <fields>
              <field>
                <name>USED</name>
                <description>Number of used/occupied entries in the TX FIFO. The field value is in the range [0, 16]. When '0', the TX FIFO is empty. When '16', the TX FIFO is full.</description>
                <bitRange>[4:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>AVAIL</name>
                <description>TX FIFO Avail
0-No available slot in TX FIFO
1-1 available slot in TX FIFO.
2-2 available slot in TX FIFO.
..
16-16 available slot in TX FIFO.
Note that the Fifo Width is 1Byte and each slot in this context is 1 depth of the Fifo. The number of bytes are determine through the number of data bytes in a message frame. (TXPID_FI.FI/TXPID_FI.DLCEXT)</description>
                <bitRange>[20:16]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>TX_FIFO_WR</name>
            <description>TX FIFO write</description>
            <addressOffset>0x88</addressOffset>
            <size>32</size>
            <access>write-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xFF</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>Transmit Data field. 

Transmission: To be transmitted data field. SW provides data field. 

HW shadows over the write data to TX FIFO after SW performs a write to this field. 
HW shadows the whole 8 bits to the TX FIFO and relies on the TXPID_FI.FI/TXPID_FI.DCLEXT to determine the number of bytes.


SW needs to ensure that TX FIFO is not overwritten before the content is consumed by HW by checking TX_FIFO_STATUS.AVAIL. Otherwise, the previous content would be overwritten and resulting in TX FIFO's overflow error (INTR.TX_OVERFLOW_ERROR).</description>
                <bitRange>[7:0]</bitRange>
                <access>write-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RX_FIFO_CTL</name>
            <description>RX FIFO control</description>
            <addressOffset>0xA0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x3001F</resetMask>
            <fields>
              <field>
                <name>TRIGGER_LEVEL</name>
                <description>Trigger level. When RX FIFO has more entries than the number of this field, a receiver trigger event is generated.
- INTR_RX.FIFO_TRIGGER = (#FIFO entries &gt; TRIGGER_LEVEL)</description>
                <bitRange>[4:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>CLEAR</name>
                <description>When '1', the RX FIFO content are popped. If a quick clear is required, the field should be set to '1' and followed by '0'. If a clear is required for an extended time, the field should be set to 1 during the complete time.</description>
                <bitRange>[16:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>FREEZE</name>
                <description>Freeze functionality:
'0': HW writes to RX FIFO and push the data to RX FIFO.
'1': HW write to RX FIFO does not push the data to the RX FIFO.
Note: Freeze functionality is for debug purpose only.</description>
                <bitRange>[17:17]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RX_FIFO_STATUS</name>
            <description>RX FIFO status</description>
            <addressOffset>0xA4</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x1F</resetMask>
            <fields>
              <field>
                <name>USED</name>
                <description>Number of used/occupied entries in the RX FIFO. The field value is in the range [0, 16]. When '0', the RX FIFO is empty. When '16', the RX FIFO is full.</description>
                <bitRange>[4:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>AVAIL</name>
                <description>RX FIFO avail
0-No content in RX FIFO
1-1 available content in RX FIFO.
2-2 available content in RX FIFO.
..
16-16 available content in RX FIFO.
Note that the Fifo Width is 1Byte and each content in this context means 1 fifo slot. The number of bytes in each slot are determine through the number of data bytes in a message frame. (RXPID_FI.FI/RXPID_FI.DLCEXT)</description>
                <bitRange>[20:16]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RX_FIFO_RD</name>
            <description>RX FIFO read</description>
            <addressOffset>0xA8</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>Received Data field. Software uses this data field.

HW shadows the first content of the RX FIFO to this field. Software reading this field will remove the content from the RX FIFO and the next content of the RX FIFO will be shadowed over to this field. This field is 8bits and reflects the width of the RX FIFO. Software needs to rely on the RXPID_FI.FI/RXPID_FI.DLCEXT fields to determine number of bytes. Note that, during debug, a read from test controller would not remove/destory the content. 

Software needs to ensure it does not read from this field if there is no available content (from RX_FIFO_STATUS.USED). Otherwise, the content is undefined and it would result in RX FIFO underflow error. (INTR.RX_UNDERFLOW_ERROR).</description>
                <bitRange>[7:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>RX_FIFO_RD_SILENT</name>
            <description>RX FIFO silent read</description>
            <addressOffset>0xAC</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x0</resetMask>
            <fields>
              <field>
                <name>DATA</name>
                <description>Data read from the RX FIFO. Reading data from this field would not pop the data from RX FIFO. 

This register is for debug purpose.</description>
                <bitRange>[7:0]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR</name>
            <description>Interrupt</description>
            <addressOffset>0xC0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7FFC3F1B</resetMask>
            <fields>
              <field>
                <name>TX_HEADER_DONE</name>
                <description>HW sets this field to '1', when a frame header (PID field or PType field) is transmitted (the CMD.TX_HEADER is completed).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_RESPONSE_DONE</name>
                <description>HW sets this field to '1', when a frame response (frame information fields, data fields, and crc field) is transmitted (the CMD.TX_RESPONSE is completed).</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_WAKEUP_DONE</name>
                <description>HW sets this field to '1', when a wakeup signal is transmitted (per CTL2.T_WAKEUP_LENGTH). This interrupt cause is activated on a transition from dominant/'0' state to recessive/'1' state; i.e. at the end of the wakeup signal.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_FIFO_TRIGGER</name>
                <description>HW sets this field to '1', when TX trigger is generated (#used TX FIFO &lt; TRIGGER_LEVEL).</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_DONE</name>
                <description>HW sets this field to '1', when a frame header (PID field or PType field) is received (the CMD.RX_HEADER is completed). Specifically:
- When followed by CMD.TX_RESPONSE or CMD.RX_RESPONSE, this field is set to '1' after completion of the message frame transfer.
- When not followed by a response command, this field is set to '1' after completion of the header transfer if RXPIDZERO_CHECK_EN=1 and header received is PID. If RXPIDZERO_CHECK_EN=0 and response commands are not set, HW will set this field to '1' after receiving PID or PTYPE.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_RESPONSE_DONE</name>
                <description>HW sets this field to '1', when a frame response (frame information fields, data fields, and crc field) is received (the CMD.RX_RESPONSE is completed).</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_WAKEUP_DETECT</name>
                <description>HW sets this field to '1', when RX fall is detected in Sleep mode.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_FIFO_TRIGGER</name>
                <description>HW sets this field to '1', when RX trigger is generated (#used RX FIFO &gt; TRIGGER_LEVEL).</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_PID_DONE</name>
                <description>HW sets this field to '1', when RX header (PID/PTYPE field) is received.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TXRX_COMPLETE</name>
                <description>HW sets this field to '1', when message frame ends after EOF is completed and TX/RX_DATA_LENGTH_ERROR=0.</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TIMEOUT</name>
                <description>HW sets this field to '1', when the transmitted/received bytes space within a message frame is &gt; TIMEOUT_LENGTH.
SW needs to set TIMEOUT_SEL=0 before clearing TIMEOUT=0 to ensure HW does not immediately sets back the interrupt.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_HEADER_ARB_LOST</name>
                <description>HW sets this field to '1', when it detects arbitration lost after the number of retries has exceed the maximum allowed retries.

Note: The ongoing message transfer is aborted (INTR.TX_HEADER_DONE and INTR.TX_RESPONSE_DONE is NOT activated and the TX_HEADER and TX_RESPONSE command is cleared to 0).</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_BIT_ERROR</name>
                <description>HW sets this field to '1', when a transmitted 'cxpi_tx_out' value does NOT match a received 'cxpi_rx_in' value. 
The match is performed for the PID fields or PType (for the START bit and STOP bit only) and for the rest of the response i.e. frame information fields, data fields and the crc field (for the START bit, DATA bits, and STOP bits).

Note: When CTL0.BIT_ERROR_IGNORE is '0', the ongoing message transfer is aborted (INTR.TX_RESPONSE_DONE is NOT activated. INTR.TX_HEADER_DONE is NOT activated if bit error occurs during the transmission of header byte) and the TX_HEADER and TX_RESPONSE commands are set to '0'. When CTL0.BIT_ERROR_IGNORE is '1', the ongoing message transfer would be transferred.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_CRC_ERROR</name>
                <description>HW sets this field to '1', when received CRC is not matching with the compute CRC from header and response.

Note: The ongoing message transfer is aborted (INTR.RX_RESPONSE_DONE is NOT activated).</description>
                <bitRange>[21:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_PARITY_ERROR</name>
                <description>HW sets this field to '1', when the received PID field or PType field has a parity error. 

Note: The ongoing message transfer is aborted (INTR.RX_HEADER_PID_DONE is NOT activated).</description>
                <bitRange>[22:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_DATA_LENGTH_ERROR</name>
                <description>HW sets this field to '1, when the received message frame's data fields are more than the value specified in DLC (for normal frame) or DLCEXT (for long frame) i.e. after receiving CRC byte(s), HW is receiving logical '0' during EOF. For the case of receiving data length less than DLC/DLCEXT, HW will also set this field to '1'. This is the case where IBS&gt;9 before the number of data reaches data length, then HW will report as data length error. HW starts checking after frame information byte. 

Note: SW needs to handle the message transfer i.e. discard or flush out. HW will still set the RX_RESPONSE_DONE.</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_DATA_LENGTH_ERROR</name>
                <description>HW sets this field to '1, when the transmit message frame's data fields are more than the value specified in DLC (for normal frame) or DLCEXT (for long frame) i.e. after transmitting CRC(s) byte, HW is receiving logical '0' during EOF.  

Note: HW will still set TX_RESPONSE_DONE and the TX_HEADER and TX_RESPONSE commands are set to '0'.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_OVERFLOW_ERROR</name>
                <description>HW sets this field to '1', when the RX data is overwritten by HW before the SW reads from it. In CXPI spec, this error is denoted as overrun error.

Note: Upon this error, SW should discard the RX data in RX FIFO.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_OVERFLOW_ERROR</name>
                <description>HW sets this field to '1', when the TX data is overwritten by SW before the HW reads from it to transmit to CXPI bus.

Note: The ongoing message transfer will continue when this error happens however, data transferred at CXPI bus will be bogus and HW will invert the CRC to invalidate the message at the receiving node. TX_HEADER and TX_RESPONSE commands are set to '0'.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_UNDERFLOW_ERROR</name>
                <description>HW sets this field to '1', when RX FIFO is empty and SW reads from it. 

Note: Upon this error, SW should discard the RX data in RX FIFO.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_UNDERFLOW_ERROR</name>
                <description>HW sets this field to '1', when TX FIFO is empty and HW reads from it. 

Note: The ongoing message transfer will continue when this error happens however, data transferred at CXPI will be bogus and HW will invert the CRC to invalidate the message at the receiving node. TX_HEADER and TX_RESPONSE commands are set to '0'.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_FRAME_ERROR</name>
                <description>HW sets this field to '1', when the stop bit of a byte frame is incorrect.

Note: The ongoing message transfer is aborted (INTR.RX_RESPONSE_DONE is NOT activated and the INTR.RX_HEADER_DONE is NOT activated if the frame error occurs during header byte or if frame error occurs during response byte (if the HEADER and RESPONSE commands are set together)).</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_FRAME_ERROR</name>
                <description>HW sets this field to '1', when the stop bit of a byte frame is incorrect.
This error would be a subset of TX_BIT_ERROR and also subjected to BIT_ERROR_IGNORE field.

Note: The ongoing message transfer is aborted (RX_HEADER_DONE and INTR.TX_RESPONSE_DONE are NOT activated. INTR.TX_HEADER_DONE is NOT activated if frame error occurs during the transmission of header byte) and the TX_HEADER and TX_RESPONSE commands are set to '0'.
Note: When CTL0.BIT_ERROR_IGNORE is '0', the ongoing message transfer is aborted (INTR.TX_RESPONSE_DONE is NOT activated. INTR.TX_HEADER_DONE is NOT activated if frame error occurs during the transmission of header byte) and the TX_HEADER and TX_RESPONSE commands are set to '0'. When CTL0.BIT_ERROR_IGNORE is '1', the ongoing message transfer would be transferred.</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_SET</name>
            <description>Interrupt set</description>
            <addressOffset>0xC4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7FFC3F1B</resetMask>
            <fields>
              <field>
                <name>TX_HEADER_DONE</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_RESPONSE_DONE</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_WAKEUP_DONE</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_FIFO_TRIGGER</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_DONE</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_RESPONSE_DONE</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_WAKEUP_DETECT</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_FIFO_TRIGGER</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_PID_DONE</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TXRX_COMPLETE</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TIMEOUT</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_HEADER_ARB_LOST</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_BIT_ERROR</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_CRC_ERROR</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[21:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_PARITY_ERROR</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[22:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_DATA_LENGTH_ERROR</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_DATA_LENGTH_ERROR</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_OVERFLOW_ERROR</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_OVERFLOW_ERROR</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_UNDERFLOW_ERROR</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_UNDERFLOW_ERROR</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_FRAME_ERROR</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_FRAME_ERROR</name>
                <description>Write INTR_SET field with '1' to set corresponding INTR field (a write of '0' has no effect).</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASK</name>
            <description>Interrupt mask</description>
            <addressOffset>0xC8</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7FFC3F1B</resetMask>
            <fields>
              <field>
                <name>TX_HEADER_DONE</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_RESPONSE_DONE</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_WAKEUP_DONE</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_FIFO_TRIGGER</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_DONE</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_RESPONSE_DONE</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_WAKEUP_DETECT</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_FIFO_TRIGGER</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_PID_DONE</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TXRX_COMPLETE</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[13:13]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TIMEOUT</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_HEADER_ARB_LOST</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_BIT_ERROR</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_CRC_ERROR</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[21:21]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_HEADER_PARITY_ERROR</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[22:22]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_DATA_LENGTH_ERROR</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[23:23]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_DATA_LENGTH_ERROR</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_OVERFLOW_ERROR</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_OVERFLOW_ERROR</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_UNDERFLOW_ERROR</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_UNDERFLOW_ERROR</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>RX_FRAME_ERROR</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[29:29]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>TX_FRAME_ERROR</name>
                <description>Mask for corresponding field in INTR register.</description>
                <bitRange>[30:30]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>INTR_MASKED</name>
            <description>Interrupt masked</description>
            <addressOffset>0xCC</addressOffset>
            <size>32</size>
            <access>read-only</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x7FFC3F1B</resetMask>
            <fields>
              <field>
                <name>TX_HEADER_DONE</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[0:0]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_RESPONSE_DONE</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[1:1]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_WAKEUP_DONE</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[3:3]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_FIFO_TRIGGER</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[4:4]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_HEADER_DONE</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[8:8]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_RESPONSE_DONE</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[9:9]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_WAKEUP_DETECT</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[10:10]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_FIFO_TRIGGER</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[11:11]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_HEADER_PID_DONE</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[12:12]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TXRX_COMPLETE</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[13:13]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TIMEOUT</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[18:18]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_HEADER_ARB_LOST</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[19:19]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_BIT_ERROR</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[20:20]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_CRC_ERROR</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[21:21]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_HEADER_PARITY_ERROR</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[22:22]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_DATA_LENGTH_ERROR</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[23:23]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_DATA_LENGTH_ERROR</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[24:24]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_OVERFLOW_ERROR</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[25:25]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_OVERFLOW_ERROR</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[26:26]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_UNDERFLOW_ERROR</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[27:27]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_UNDERFLOW_ERROR</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[28:28]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>RX_FRAME_ERROR</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[29:29]</bitRange>
                <access>read-only</access>
              </field>
              <field>
                <name>TX_FRAME_ERROR</name>
                <description>Logical AND of corresponding INTR and INTR_MASK fields.</description>
                <bitRange>[30:30]</bitRange>
                <access>read-only</access>
              </field>
            </fields>
          </register>
        </cluster>
      </registers>
    </peripheral>
    <peripheral>
      <name>CTBM0</name>
      <description>Continuous Time Block Mini</description>
      <headerStructName>CTBM</headerStructName>
      <baseAddress>0x40300000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTB_CTRL</name>
          <description>global CTB and power control</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC0000000</resetMask>
          <fields>
            <field>
              <name>DEEPSLEEP_ON</name>
              <description>- 0: CTB IP disabled off during DeepSleep power mode
- 1: CTB IP remains enabled during DeepSleep power mode (if ENABLED=1)</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>- 0: CTB IP disabled (put analog in power down, open all switches)
- 1: CTB IP enabled</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OA_RES0_CTRL</name>
          <description>Opamp0 and resistor0 control</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xBF7</resetMask>
          <fields>
            <field>
              <name>OA0_PWR_MODE</name>
              <description>Opamp0 power level</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>OFF</name>
                  <description>Off</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>LOW</name>
                  <description>Low compensation setting (smallest cap, highest GBW). For gain=10: PM=60deg @ Cload=50pF for the output to pin driver and 10pF for the internal only driver</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MEDIUM</name>
                  <description>Medium compensation setting. For gain=4: PM=60deg @ Cload=50pF for the output to pin driver and 10pF for the internal only driver.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HIGH</name>
                  <description>Highest compensation (largest cap, lowest GBW). For gain=1: PM=60deg @ Cload=50pF for the output to pin driver and 10pF for the internal only driver</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OA0_DRIVE_STR_SEL</name>
              <description>Opamp0 output strenght select 0=1x, 1=10x</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0_COMP_EN</name>
              <description>Opamp0 comparator enable</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0_HYST_EN</name>
              <description>Opamp0 hysteresis enable (10mV)</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0_BYPASS_DSI_SYNC</name>
              <description>Opamp0 bypass comparator output synchronization for DSI (trigger) output: 0=synchronize (level or pulse), 1=bypass (output async)</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0_DSI_LEVEL</name>
              <description>Opamp0 comparator DSI (trigger) out level : 
0=pulse, each time an edge is detected (see OA0_COMPINT) a pulse is sent out on DSI
1=level,  DSI output is a synchronized version of the comparator output</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0_COMPINT</name>
              <description>Opamp0 comparator edge detect for interrupt and pulse mode of DSI (trigger)</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>Disabled, no interrupts will be detected</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RISING</name>
                  <description>Rising edge</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FALLING</name>
                  <description>Falling edge</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BOTH</name>
                  <description>Both rising and falling edges</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OA0_PUMP_EN</name>
              <description>Opamp0 pump enable</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OA_RES1_CTRL</name>
          <description>Opamp1 and resistor1 control</description>
          <addressOffset>0x8</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xBF7</resetMask>
          <fields>
            <field>
              <name>OA1_PWR_MODE</name>
              <description>Opamp1 power level: see description of OA0_PWR_MODE</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1_DRIVE_STR_SEL</name>
              <description>Opamp1 output strenght select 0=1x, 1=10x</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1_COMP_EN</name>
              <description>Opamp1 comparator enable</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1_HYST_EN</name>
              <description>Opamp1 hysteresis enable (10mV)</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1_BYPASS_DSI_SYNC</name>
              <description>Opamp1 bypass comparator output synchronization for DSI output: 0=synchronize, 1=bypass</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1_DSI_LEVEL</name>
              <description>Opamp1 comparator DSI (trigger) out level : 
0=pulse, each time an edge is detected (see OA1_COMPINT) a pulse is sent out on DSI
1=level,  DSI output is a synchronized version of the comparator output</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1_COMPINT</name>
              <description>Opamp1 comparator edge detect for interrupt and pulse mode of DSI (trigger)</description>
              <bitRange>[9:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>DISABLE</name>
                  <description>Disabled, no interrupts will be detected</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RISING</name>
                  <description>Rising edge</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>FALLING</name>
                  <description>Falling edge</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>BOTH</name>
                  <description>Both rising and falling edges</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>OA1_PUMP_EN</name>
              <description>Opamp1 pump enable</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>COMP_STAT</name>
          <description>Comparator status</description>
          <addressOffset>0xC</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x10001</resetMask>
          <fields>
            <field>
              <name>OA0_COMP</name>
              <description>Opamp0 current comparator status</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OA1_COMP</name>
              <description>Opamp1 current comparator status</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>Interrupt request register</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>COMP0</name>
              <description>Comparator 0 Interrupt: hardware sets this interrupt when comparator 0 triggers. Write with '1' to clear bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP1</name>
              <description>Comparator 1 Interrupt: hardware sets this interrupt when comparator 1 triggers. Write with '1' to clear bit.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>Interrupt request set register</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>COMP0_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP1_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>Interrupt request mask</description>
          <addressOffset>0x28</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>COMP0_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>COMP1_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>Interrupt request masked</description>
          <addressOffset>0x2C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>COMP0_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>COMP1_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DFT_CTRL</name>
          <description>Was 'Analog DfT controls', now used as Risk Mitigation bits (RMP)</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000007</resetMask>
          <fields>
            <field>
              <name>DFT_MODE</name>
              <description>this bit is combined with bit 31, to form RMP[3:0], it must always be written with '3' for correct operation.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_EN</name>
              <description>this bit is combined with the 3 bits 2:0, to form RMP[3:0]</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OA0_SW</name>
          <description>Opamp0 switch control</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x24410D</resetMask>
          <fields>
            <field>
              <name>OA0P_A00</name>
              <description>Opamp0 positive terminal amuxbusa</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0P_A20</name>
              <description>Opamp0 positive terminal P0</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0P_A30</name>
              <description>Opamp0 positive terminal ctbbus0</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0M_A11</name>
              <description>Opamp0 negative terminal P1</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0M_A81</name>
              <description>Opamp0 negative terminal Opamp0 output</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0O_D51</name>
              <description>Opamp0 output sarbus0 (ctbbus2 in CTB)</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0O_D81</name>
              <description>Opamp0 output switch to short 1x with 10x drive</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OA0_SW_CLEAR</name>
          <description>Opamp0 switch control clear</description>
          <addressOffset>0x84</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x24410D</resetMask>
          <fields>
            <field>
              <name>OA0P_A00</name>
              <description>see corresponding bit in OA0_SW</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0P_A20</name>
              <description>see corresponding bit in OA0_SW</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0P_A30</name>
              <description>see corresponding bit in OA0_SW</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0M_A11</name>
              <description>see corresponding bit in OA0_SW</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0M_A81</name>
              <description>see corresponding bit in OA0_SW</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0O_D51</name>
              <description>see corresponding bit in OA0_SW</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA0O_D81</name>
              <description>see corresponding bit in OA0_SW</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OA1_SW</name>
          <description>Opamp1 switch control</description>
          <addressOffset>0x88</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x2C4113</resetMask>
          <fields>
            <field>
              <name>OA1P_A03</name>
              <description>Opamp1 positive terminal amuxbusb</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1P_A13</name>
              <description>Opamp1 positive terminal P5</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1P_A43</name>
              <description>Opamp1 positive terminal ctbbus1</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1M_A22</name>
              <description>Opamp1 negative terminal P4</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1M_A82</name>
              <description>Opamp1 negative terminal Opamp1 output</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1O_D52</name>
              <description>Opamp1 output sarbus0 (ctbbus2 in CTB)</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1O_D62</name>
              <description>Opamp1 output sarbus1 (ctbbus3 in CTB)</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1O_D82</name>
              <description>Opamp1 output switch to short 1x with 10x drive</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OA1_SW_CLEAR</name>
          <description>Opamp1 switch control clear</description>
          <addressOffset>0x8C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x2C4113</resetMask>
          <fields>
            <field>
              <name>OA1P_A03</name>
              <description>see corresponding bit in OA1_SW</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1P_A13</name>
              <description>see corresponding bit in OA1_SW</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1P_A43</name>
              <description>see corresponding bit in OA1_SW</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1M_A22</name>
              <description>see corresponding bit in OA1_SW</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1M_A82</name>
              <description>see corresponding bit in OA1_SW</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1O_D52</name>
              <description>see corresponding bit in OA1_SW</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1O_D62</name>
              <description>see corresponding bit in OA1_SW</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OA1O_D82</name>
              <description>see corresponding bit in OA1_SW</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CTB_SW_HW_CTRL</name>
          <description>CTB bus switch control</description>
          <addressOffset>0xC0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC</resetMask>
          <fields>
            <field>
              <name>P2_HW_CTRL</name>
              <description>for P22, D51 (dsi_out[2])</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>P3_HW_CTRL</name>
              <description>for P33, D52, D62 (dsi_out[3])</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CTB_SW_STATUS</name>
          <description>CTB bus switch control status</description>
          <addressOffset>0xC4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x70000000</resetMask>
          <fields>
            <field>
              <name>OA0O_D51_STAT</name>
              <description>see OA0O_D51 bit in OA0_SW</description>
              <bitRange>[28:28]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OA1O_D52_STAT</name>
              <description>see OA1O_D52 bit in OA1_SW</description>
              <bitRange>[29:29]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OA1O_D62_STAT</name>
              <description>see OA1O_D62 bit in OA1_SW</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OA0_OFFSET_TRIM</name>
          <description>Opamp0 trim control</description>
          <addressOffset>0xFF00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>OA0_OFFSET_TRIM</name>
              <description>Opamp0 offset trim</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OA0_SLOPE_OFFSET_TRIM</name>
          <description>Opamp0 trim control</description>
          <addressOffset>0xFF04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>OA0_SLOPE_OFFSET_TRIM</name>
              <description>Opamp0 slope offset drift trim</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OA0_COMP_TRIM</name>
          <description>Opamp0 trim control</description>
          <addressOffset>0xFF08</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>OA0_COMP_TRIM</name>
              <description>Opamp 0 Compensation Capacitor Trim</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OA1_OFFSET_TRIM</name>
          <description>Opamp1 trim control</description>
          <addressOffset>0xFF0C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>OA1_OFFSET_TRIM</name>
              <description>Opamp1 offset trim</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OA1_SLOPE_OFFSET_TRIM</name>
          <description>Opamp1 trim control</description>
          <addressOffset>0xFF10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>OA1_SLOPE_OFFSET_TRIM</name>
              <description>Opamp1 slope offset drift trim</description>
              <bitRange>[5:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>OA1_COMP_TRIM</name>
          <description>Opamp1 trim control</description>
          <addressOffset>0xFF14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>OA1_COMP_TRIM</name>
              <description>Opamp 1 Compensation Capacitor Trim</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>SAR0</name>
      <description>SAR ADC with Sequencer</description>
      <headerStructName>SAR</headerStructName>
      <baseAddress>0x403A0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>CTRL</name>
          <description>Analog control register.</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFB3FEEF0</resetMask>
          <fields>
            <field>
              <name>VREF_SEL</name>
              <description>SARADC internal VREF selection.</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>RSVD_VREF_0</name>
                  <description>N/A</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD_VREF_1</name>
                  <description>N/A</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>RSVD_VREF_2</name>
                  <description>N/A</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VREF_ADFT</name>
                  <description>Test mode only</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VBGR</name>
                  <description>1.2V from SRSS BandGap (VREF buffer on)</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VREF_EXT</name>
                  <description>External precision Vref direct from a pin (low impedance path).</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VDDA_DIV_2</name>
                  <description>Vdda/2  (VREF buffer on)</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VDDA</name>
                  <description>Vdda.</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>VREF_BYP_CAP_EN</name>
              <description>VREF bypass cap enable for when VREF buffer is on</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NEG_SEL</name>
              <description>SARADC internal NEG selection for Single ended conversion</description>
              <bitRange>[11:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>VSSA_KELVIN</name>
                  <description>NEG input of SARADC is connected to 'vssa_kelvin', gives more precision around zero. Note this opens both SARADC internal switches, therefore use this value to insert a break-before-make cycle on those switches when SWITCH_DISABLE is high.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ART_VSSA</name>
                  <description>NEG input of SARADC is connected to VSSA in AROUTE close to the SARADC</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>P1</name>
                  <description>NEG input of SARADC is connected to P1 pin of SARMUX</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>P3</name>
                  <description>NEG input of SARADC is connected to P3 pin of SARMUX</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>P5</name>
                  <description>NEG input of SARADC is connected to P5 pin of SARMUX</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>P7</name>
                  <description>NEG input of SARADC is connected to P7 pin of SARMUX</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ACORE</name>
                  <description>NEG input of SARADC is connected to an ACORE in AROUTE</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>VREF</name>
                  <description>NEG input of SARADC is shorted with VREF input of SARADC.</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SAR_HW_CTRL_NEGVREF</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for VREF to NEG switch.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PWR_CTRL_VREF</name>
              <description>VREF buffer low power mode.</description>
              <bitRange>[15:14]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NORMAL_PWR</name>
                  <description>normal power (default), bypass cap, max clk_sar is 18MHz.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALF_PWR</name>
                  <description>deprecated</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>THIRD_PWR</name>
                  <description>Invalid for PSoC4A, otherwise 2X power, no bypass cap, max clk_sar is 1.8MHz</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>QUARTER_PWR</name>
                  <description>deprecated</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>SPARE</name>
              <description>Spare controls, not yet designated, for late changes done with an ECO</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>BOOSTPUMP_EN</name>
              <description>SARADC internal pump: 0=disabled: pump output is VDDA, 1=enabled: pump output is boosted.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>REFBUF_EN</name>
              <description>1 - Enable the SARREFBUF. This bit needs to be set when SAR is enabled and needs reference buffer.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ICONT_LV</name>
              <description>SARADC low power mode.</description>
              <bitRange>[25:24]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>NORMAL_PWR</name>
                  <description>normal power (default), max clk_sar is 18MHz.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>HALF_PWR</name>
                  <description>1/2 power mode, max clk_sar is 9MHz.</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>MORE_PWR</name>
                  <description>1.333 power mode, max clk_sar is 18MHz.</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>QUARTER_PWR</name>
                  <description>1/4 power mode, max clk_sar is 4.5MHz.</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DEEPSLEEP_ON</name>
              <description>- 0: SARMUX IP disabled off during DeepSleep power mode
- 1: SARMUX IP remains enabled during DeepSleep power mode (if ENABLED=1)</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_CTRL_28</name>
              <description>N/A</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RSVD_CTRL_29</name>
              <description>N/A</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SWITCH_DISABLE</name>
              <description>Disable SAR sequencer from enabling routing switches (note DSI and firmware can always close switches independent of this control)
- 0: Normal mode, SAR sequencer changes switches according to pin address in channel configurations
- 1: Switches disabled, SAR sequencer does not enable any switches, it is the responsibility of the firmware or UDBs (through DSI) to set the switches to route the signal to be converted through the SARMUX</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>- 0: SAR IP disabled (put analog in power down and stop clocks), also can clear FW_TRIGGER and INJ_START_EN (if not tailgaiting) on write.
- 1: SAR IP enabled.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SAMPLE_CTRL</name>
          <description>Sample control register.</description>
          <addressOffset>0x4</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x80008</resetValue>
          <resetMask>0x800F01FF</resetMask>
          <fields>
            <field>
              <name>SUB_RESOLUTION</name>
              <description>Conversion resolution for channels that have sub-resolution enabled (RESOLUTION=1) (otherwise resolution is 12-bit).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>8B</name>
                  <description>8-bit.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>10B</name>
                  <description>10-bit.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>LEFT_ALIGN</name>
              <description>Left align data in data[15:0], default data is right aligned in data[11:0], with sign extension to 16 bits if the channel is differential.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SINGLE_ENDED_SIGNED</name>
              <description>Output data from a single ended conversion as a signed value 

If AVG_MODE = 1 (Interleaved averaging), then SINGLE_ENDED_SIGNED must be configured identically to DIFFERENTIAL_SIGNED.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>UNSIGNED</name>
                  <description>Default: result data is unsigned (zero extended if needed)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SIGNED</name>
                  <description>result data is signed (sign extended if needed)</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIFFERENTIAL_SIGNED</name>
              <description>Output data from a differential conversion as a signed value when DIFFERENTIAL_EN or NEG_ADDR_EN is set to 1

If AVG_MODE = 1 (Interleaved averaging), then DIFFERENTIAL_SIGNED must be configured identically to SINGLE_ENDED_SIGNED.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>UNSIGNED</name>
                  <description>result data is unsigned (zero extended if needed)</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SIGNED</name>
                  <description>Default: result data is signed (sign extended if needed)</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AVG_CNT</name>
              <description>Averaging Count for channels that have averaging enabled (AVG_EN). A channel will be sampled (1&lt;&lt;(AVG_CNT+1)) = [2..256] times.
- In ACCUNDUMP mode  (1st order accumulate and dump filter) a channel will be sampled back to back, the average result is calculated and stored and then the next enabled channel is sampled. If shifting is not enabled (AVG_SHIFT=0) then the result is forced to shift right so that is fits in 16 bits, so right shift is done by max(0,AVG_CNT-3).
- In INTERLEAVED mode one sample is taken per triggered scan, only in the scan where the final averaging count is reached a valid average is calculated and stored in the RESULT register (by definition the same scan for all the channels that have averaging enabled). In all other scans the RESULT register for averaged channels will have an invalid result and the intermediate accumulated value is stored in the 16-bit WORK register. In this mode make sure that the averaging count is low enough to ensure that the intermediate value does not exceed 16-bits otherwise the MSBs will be lost. So for a 12-bit resolution the averaging count should be set to 16 or less (AVG_CNT=&lt;3).</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AVG_SHIFT</name>
              <description>Averaging shifting: after averaging the result is shifted right to fit in the sample resolution. For averaging the sample resolution is the highest resolution allowed by wounding.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>AVG_MODE</name>
              <description>Averaging mode,  in DSI mode this bit is ignored and only AccuNDump mode is available.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>ACCUNDUMP</name>
                  <description>Accumulate and Dump (1st order accumulate and dump filter): a channel will be sampled back to back and averaged</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INTERLEAVED</name>
                  <description>Interleaved: On each scan (trigger) one sample is taken per channel and averaged over several scans. 
NOTE: If all channels in a scan are configured for interleaved averaging, then EOS is only asserted after the last scan of the average count.  In addition, a new trigger which would cause a collision, will be ignored, except for the last scan of the average count. If the collision is detected in the the last scan, the trigger will be pended and will be executed after the last scan is completed.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>CONTINUOUS</name>
              <description>- 0: Wait for next FW_TRIGGER (one shot) or hardware (DSI) trigger (e.g. from TPWM for periodic triggering) before scanning enabled channels.
- 1: Continuously scan enabled channels, ignore triggers.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_TRIGGER_EN</name>
              <description>- 0: firmware trigger only: disable hardware (DSI) trigger.
- 1: enable hardware (DSI) trigger (e.g. from TCPWM, GPIO or UDB).</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_TRIGGER_LEVEL</name>
              <description>- 0: DSI trigger signal is a pulse input, a positive edge detected on the DSI trigger signal triggers a new scan.
- 1: DSI trigger signal is a level input, as long as the DSI trigger signal remains high the SAR will do continuous scans.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_SYNC_TRIGGER</name>
              <description>- 0: bypass clock domain synchronisation of the DSI trigger signal.
- 1: synchronize the DSI trigger signal to the SAR clock domain, if needed an edge detect is done in the peripheral clock domain.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EOS_DSI_OUT_EN</name>
              <description>Enable to output EOS_INTR to DSI. When enabled each time EOS_INTR is set by the hardware also a pulse is send on the dsi_eos signal.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SAMPLE_TIME01</name>
          <description>Sample time specification ST0 and ST1</description>
          <addressOffset>0x10</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40004</resetValue>
          <resetMask>0x3FF03FF</resetMask>
          <fields>
            <field>
              <name>SAMPLE_TIME0</name>
              <description>Sample time0 (aperture) in ADC clock cycles. Note that actual sample time is half a clock less than specified here. The minimum sample time is 194ns, which is 3.5 cycles (4 in this field) with an 18MHz clock. Minimum legal value in this register is 2.</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_TIME1</name>
              <description>Sample time1</description>
              <bitRange>[25:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SAMPLE_TIME23</name>
          <description>Sample time specification ST2 and ST3</description>
          <addressOffset>0x14</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x40004</resetValue>
          <resetMask>0x3FF03FF</resetMask>
          <fields>
            <field>
              <name>SAMPLE_TIME2</name>
              <description>Sample time2</description>
              <bitRange>[9:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_TIME3</name>
              <description>Sample time3</description>
              <bitRange>[25:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RANGE_THRES</name>
          <description>Global range detect threshold register.</description>
          <addressOffset>0x18</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RANGE_LOW</name>
              <description>Low threshold for range detect.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RANGE_HIGH</name>
              <description>High threshold for range detect.</description>
              <bitRange>[31:16]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RANGE_COND</name>
          <description>Global range detect mode register.</description>
          <addressOffset>0x1C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC0000000</resetMask>
          <fields>
            <field>
              <name>RANGE_COND</name>
              <description>Range condition select.</description>
              <bitRange>[31:30]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>BELOW</name>
                  <description>result &lt; RANGE_LOW</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>INSIDE</name>
                  <description>RANGE_LOW &lt;= result &lt; RANGE_HIGH</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>ABOVE</name>
                  <description>RANGE_HIGH &lt;= result</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>OUTSIDE</name>
                  <description>result &lt; RANGE_LOW || RANGE_HIGH &lt;= result</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
        <register>
          <name>CHAN_EN</name>
          <description>Enable bits for the channels</description>
          <addressOffset>0x20</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CHAN_EN</name>
              <description>Channel enable. 
- 0: the corresponding channel is disabled.
- 1: the corresponding channel is enabled, it will be included in the next scan.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>START_CTRL</name>
          <description>Start control register (firmware trigger).</description>
          <addressOffset>0x24</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>FW_TRIGGER</name>
              <description>When firmware writes a 1 here it will trigger the next scan of enabled channels, hardware clears this bit when the scan started with this trigger is completed. If scanning continuously the trigger is ignored and hardware clears this bit after the next scan is done. This bit is also cleared when the SAR is disabled.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DFT_CTRL</name>
          <description>DFT control register.</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x2</resetValue>
          <resetMask>0xFF7F0003</resetMask>
          <fields>
            <field>
              <name>DLY_INC</name>
              <description>DFT control: Control for delay circuits on sampling phase, =1 doubes the non-overlap delay</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>HIZ</name>
              <description>DFT control for getting higher input impedance, must be 1 (0 is deprecated)</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_INC</name>
              <description>DFT control for preamp inputs</description>
              <bitRange>[19:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DFT_OUTC</name>
              <description>DFT control for preamp outputs</description>
              <bitRange>[22:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SEL_CSEL_DFT</name>
              <description>Usage 1: DFT bits for DAC array
Usage 2: For [0]=1 (when dcen=0): Delay timing for latch enable increased by 20 percent
[1]=1: comparator preamp power level increased by 25 percent</description>
              <bitRange>[27:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>EN_CSEL_DFT</name>
              <description>Mux select signal for DAC control</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DCEN</name>
              <description>Delay Control Enable for latch.
- 0: doubles the latch enable time.
- 1: normal latch enable time.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADFT_OVERRIDE_EXPMUX</name>
              <description>During deepsleep/ hibernate mode keep EXPMUX active, i.e. do not open all switches (disconnect), to be used for ADFT.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ADFT_OVERRIDE</name>
              <description>During deepsleep/ hibernate mode keep SARMUX active, i.e. do not open all switches (disconnect), to be used for ADFT</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>32</dim>
          <dimIncrement>4</dimIncrement>
          <name>CHAN_CONFIG[%s]</name>
          <description>Channel configuration register.</description>
          <addressOffset>0x80</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xBD773777</resetMask>
          <fields>
            <field>
              <name>POS_PIN_ADDR</name>
              <description>Address of the pin to be sampled by this channel (connected to Vplus)</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>POS_PORT_ADDR</name>
              <description>Address of the port that contains the pin to be sampled by this channel (connected to Vplus)</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SARMUX</name>
                  <description>SARMUX PORT pins.
Select POS_PIN_ADDR 0-7 for GPIO 0-7
See DIFF_EN bit description for legacy differential mode</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB0</name>
                  <description>CTB0
Selet:
POS_PIN_ADDR 2 for OA0 output (single ended)...</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB1</name>
                  <description>CTB1 (see CTB0)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB2</name>
                  <description>CTB2 (see CTB0)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB3</name>
                  <description>CTB3 (see CTB0)</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXPMUX</name>
                  <description>GPIO Expansion Mux (if present)
See DIFF_EN bit description for legacy differential mode</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIAGMUX</name>
                  <description>Diagnostic inputs</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SARMUX_VIRT</name>
                  <description>SARMUX virtual port (VPORT0)
Select POS_PIN_ADDR 0 for Temp Sensor
Select POS_PIN_ADDR 2 for AMUXBUSA (single ended, test only)...</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>DIFFERENTIAL_EN</name>
              <description>Legacy differential mode, usage is described by port below:
SARMUX: Legacy mode, use applications should use NEG_PORT/PIN_ADDR 
CTB0-3: Special purpose, see CTB0 description
EXPMUX: Legacy mode, use applications should use NEG_PORT/PIN_ADDR
DIAGMUX: Not applicable
SARMUX_VIRT: Special purpose, see SARMUX_VIRT description

LEGACY MODE DESCRIPTION:
Differential enable for the selected port pin for this channel.  If differential is enabled then POS_PIN_ADDR[0] is ignored and considered to be 0, i.e. POS_PIN_ADDR points to the even pin of a pin pair. For differential the even pin of the pair is connected to Vplus and the odd pin of the pair is connected to Vminus. POS_PORT_ADDR is used to identify the port that contains the pins.
- 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.
- 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (POS_PIN_ADDR[0] is ignored).

NOTE: Set to 0 if using the NEG_PIN_ADDR and NEG_PORT_ADDR to select the negative source.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RESOLUTION</name>
              <description>Resolution for this channel.  When AVG_EN is set this bit is ignored and always a 12-bit resolution (or highest resolution allowed by wounding) is used for this channel.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>MAXRES</name>
                  <description>The maximum resolution is used for this channel (maximum resolution depends on wounding).</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SUBRES</name>
                  <description>The resolution specified by SUB_RESOLUTION in the SAR_SAMPLE_CTRL register is used for this channel.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>AVG_EN</name>
              <description>Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>SAMPLE_TIME_SEL</name>
              <description>Sample time select: select which of the 4 global sample times to use for this channel</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NEG_PIN_ADDR</name>
              <description>Address of the neg pin to be sampled by this channel.</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>NEG_PORT_ADDR</name>
              <description>Address of the neg port that contains the pin to be sampled by this channel.</description>
              <bitRange>[22:20]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SARMUX</name>
                  <description>SARMUX pins.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXPMUX</name>
                  <description>GPIO Expansion Mux (if present)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIAGMUX</name>
                  <description>Diagnostic  inputs</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SARMUX_VIRT</name>
                  <description>SARMUX virtual port (VPORT0)</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>NEG_ADDR_EN</name>
              <description>1 - The NEG_PIN_ADDR and NEG_PORT_ADDR determines what drives the Vminus pin. This is a variation of differential mode with no even-odd pair limitation                                                                                                                                0 -  The NEG_SEL determines what drives the Vminus pin.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DIAG_VPLUS_SOURCE</name>
              <description>Enable for 10uA current source on vplus signal, active during sampling of this channel</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DIAG_VPLUS_SINK</name>
              <description>Enable for 10uA current sink on vplus signal, active during sampling of this channel</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DIAG_VMINUS_SOURCE</name>
              <description>Enable for 10uA current source on vminus signal, active during sampling of this channel</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DIAG_VMINUS_SINK</name>
              <description>Enable for 10uA current sink on vminus signal, active during sampling of this channel</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_OUT_EN</name>
              <description>DSI data output enable for this channel.
- 0: the conversion result for this channel is only stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set.
- 1: the conversion result for this channel is stored in the channel data register and the corresponding CHAN_DATA_VALID bit is set. The same data (same formating), together with the channel number, is sent out on the DSI communication channel for processing in UDBs.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>32</dim>
          <dimIncrement>4</dimIncrement>
          <name>CHAN_WORK[%s]</name>
          <description>Channel working data register</description>
          <addressOffset>0x100</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000000</resetMask>
          <fields>
            <field>
              <name>WORK</name>
              <description>SAR conversion working data of the channel. The data is written here right after sampling this channel.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_WORK_UPDATED_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_WORK_UPDATED register</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <dim>32</dim>
          <dimIncrement>4</dimIncrement>
          <name>CHAN_RESULT[%s]</name>
          <description>Channel result data register</description>
          <addressOffset>0x180</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xE0000000</resetMask>
          <fields>
            <field>
              <name>RESULT</name>
              <description>SAR conversion result of the channel. The data is copied here from the WORK field after all enabled channels in this scan have been sampled.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SATURATE_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_SATURATE_INTR register</description>
              <bitRange>[29:29]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RANGE_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_RANGE_INTR register</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CHAN_RESULT_UPDATED_MIR</name>
              <description>mirror bit of corresponding bit in SAR_CHAN_RESULT_UPDATED register</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CHAN_WORK_UPDATED</name>
          <description>Channel working data register 'updated' bits</description>
          <addressOffset>0x200</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CHAN_WORK_UPDATED</name>
              <description>If set the corresponding WORK register was updated, i.e. was already sampled during the current scan and, in case of Interleaved averaging, reached the averaging count. If this bit is low then either the channel is not enabled or the averaging count is not yet reached for Interleaved averaging.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>CHAN_RESULT_UPDATED</name>
          <description>Channel result data register 'updated' bits</description>
          <addressOffset>0x204</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>CHAN_RESULT_UPDATED</name>
              <description>If set the corresponding RESULT register was updated, i.e. was sampled during the previous scan and, in case of Interleaved averaging, reached the averaging count. If this bit is low then either the channel is not enabled or the averaging count is not yet reached for Interleaved averaging.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR</name>
          <description>Interrupt request register.</description>
          <addressOffset>0x210</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>EOS_INTR</name>
              <description>End Of Scan Interrupt: hardware sets this interrupt after completing a scan of all the enabled channels. Write with '1' to clear bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW_INTR</name>
              <description>Overflow Interrupt: hardware sets this interrupt when it sets a new EOS_INTR while that bit was not yet cleared by the firmware. Write with '1' to clear bit.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FW_COLLISION_INTR</name>
              <description>Firmware Collision Interrupt: hardware sets this interrupt when FW_TRIGGER is asserted while the SAR is BUSY. Raising this interrupt is delayed to when the scan caused by the FW_TRIGGER has been completed, i.e. not when the preceeding scan with which this trigger collided is completed. When this interrupt is set it implies that the channels were sampled later than was intended (jitter). Write with '1' to clear bit.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_COLLISION_INTR</name>
              <description>DSI Collision Interrupt: hardware sets this interrupt when the DSI trigger signal is asserted while the SAR is BUSY. Raising this interrupt is delayed to when the scan caused by the DSI trigger has been completed, i.e. not when the preceeding scan with which this trigger collided is completed. When this interrupt is set it implies that the channels were sampled later than was intended (jitter). Write with '1' to clear bit.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_EOC_INTR</name>
              <description>Injection End of Conversion Interrupt: hardware sets this interrupt after completing the conversion for the injection channel (irrespective of if tailgating was used). Write with '1' to clear bit.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_SATURATE_INTR</name>
              <description>Injection Saturation Interrupt: hardware sets this interrupt if an injection conversion result (before averaging) is either 0x000 or 0xFFF (for 12-bit resolution), this is an indication that the ADC likely saturated. Write with '1' to clear bit.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_RANGE_INTR</name>
              <description>Injection Range detect Interrupt: hardware sets this interrupt if the injection conversion result (after averaging) met the condition specified by the SAR_RANGE registers. Write with '1' to clear bit.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_COLLISION_INTR</name>
              <description>Injection Collision Interrupt: hardware sets this interrupt when the injection trigger signal is asserted (INJ_START_EN==1 &amp;&amp; INJ_TAILGATING==0) while the SAR is BUSY. Raising this interrupt is delayed to when the sampling of the injection channel has been completed, i.e. not when the preceeding scan with which this trigger collided is completed. When this interrupt is set it implies that the injection channel was sampled later than was intended. Write with '1' to clear bit.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_SET</name>
          <description>Interrupt set request register</description>
          <addressOffset>0x214</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>EOS_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FW_COLLISION_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_COLLISION_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_EOC_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_SATURATE_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_RANGE_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_COLLISION_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASK</name>
          <description>Interrupt mask register.</description>
          <addressOffset>0x218</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>EOS_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>OVERFLOW_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>FW_COLLISION_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSI_COLLISION_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_EOC_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_SATURATE_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_RANGE_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_COLLISION_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_MASKED</name>
          <description>Interrupt masked request register</description>
          <addressOffset>0x21C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF</resetMask>
          <fields>
            <field>
              <name>EOS_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERFLOW_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FW_COLLISION_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DSI_COLLISION_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_EOC_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_SATURATE_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_RANGE_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_COLLISION_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SATURATE_INTR</name>
          <description>Saturate interrupt request register.</description>
          <addressOffset>0x220</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SATURATE_INTR</name>
              <description>Saturate Interrupt: hardware sets this interrupt for each channel if a conversion result (before averaging) of that channel is either 0x000 or 0xFFF (for 12-bit resolution), this is an indication that the ADC likely saturated. Write with '1' to clear bit.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SATURATE_INTR_SET</name>
          <description>Saturate interrupt set request register</description>
          <addressOffset>0x224</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SATURATE_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SATURATE_INTR_MASK</name>
          <description>Saturate interrupt mask register.</description>
          <addressOffset>0x228</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SATURATE_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>SATURATE_INTR_MASKED</name>
          <description>Saturate interrupt masked request register</description>
          <addressOffset>0x22C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>SATURATE_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RANGE_INTR</name>
          <description>Range detect interrupt request register.</description>
          <addressOffset>0x230</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RANGE_INTR</name>
              <description>Range detect Interrupt: hardware sets this interrupt for each channel if the conversion result (after averaging) of that channel met the condition specified by the SAR_RANGE registers. Write with '1' to clear bit.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RANGE_INTR_SET</name>
          <description>Range detect interrupt set request register</description>
          <addressOffset>0x234</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RANGE_SET</name>
              <description>Write with '1' to set corresponding bit in interrupt request register.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RANGE_INTR_MASK</name>
          <description>Range detect interrupt mask register.</description>
          <addressOffset>0x238</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RANGE_MASK</name>
              <description>Mask bit for corresponding bit in interrupt request register.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>RANGE_INTR_MASKED</name>
          <description>Range interrupt masked request register</description>
          <addressOffset>0x23C</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>RANGE_MASKED</name>
              <description>Logical and of corresponding request and mask bits.</description>
              <bitRange>[31:0]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INTR_CAUSE</name>
          <description>Interrupt cause register</description>
          <addressOffset>0x240</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC00000FF</resetMask>
          <fields>
            <field>
              <name>EOS_MASKED_MIR</name>
              <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>OVERFLOW_MASKED_MIR</name>
              <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>FW_COLLISION_MASKED_MIR</name>
              <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>DSI_COLLISION_MASKED_MIR</name>
              <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_EOC_MASKED_MIR</name>
              <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_SATURATE_MASKED_MIR</name>
              <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_RANGE_MASKED_MIR</name>
              <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_COLLISION_MASKED_MIR</name>
              <description>Mirror copy of corresponding bit in SAR_INTR_MASKED</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SATURATE_MASKED_RED</name>
              <description>Reduction OR of all SAR_SATURATION_INTR_MASKED bits</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>RANGE_MASKED_RED</name>
              <description>Reduction OR of all SAR_RANGE_INTR_MASKED bits</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INJ_CHAN_CONFIG</name>
          <description>Injection channel configuration register.</description>
          <addressOffset>0x280</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFD773777</resetMask>
          <fields>
            <field>
              <name>INJ_PIN_ADDR</name>
              <description>Address of the pin to be sampled by this injection channel. If differential is enabled then INJ_PIN_ADDR[0] is ignored and considered to be 0, i.e. INJ_PIN_ADDR points to the even pin of a pin pair.</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_PORT_ADDR</name>
              <description>Address of the port that contains the pin to be sampled by this channel (connected to Vplus)</description>
              <bitRange>[6:4]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SARMUX</name>
                  <description>SARMUX PORT pins.
Select POS_PIN_ADDR 0-7 for GPIO 0-7
See DIFF_EN bit description for legacy differential mode</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB0</name>
                  <description>CTB0
Selet:
POS_PIN_ADDR 2 for OA0 output (single ended)...</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB1</name>
                  <description>CTB1 (see CTB0)</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB2</name>
                  <description>CTB2 (see CTB0)</description>
                  <value>3</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>CTB3</name>
                  <description>CTB3 (see CTB0)</description>
                  <value>4</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXPMUX</name>
                  <description>GPIO Expansion Mux (if present)
See DIFF_EN bit description for legacy differential mode</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIAGMUX</name>
                  <description>Diagnostic inputs</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SARMUX_VIRT</name>
                  <description>SARMUX virtual port (VPORT0)
Select POS_PIN_ADDR 0 for Temp Sensor
Select POS_PIN_ADDR 2 for AMUXBUSA (single ended, test only)...</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INJ_DIFFERENTIAL_EN</name>
              <description>Legacy differential mode, usage is described by port below:
SARMUX: Legacy mode, use applications should use NEG_PORT/PIN_ADDR 
CTB0-3: Special purpose, see CTB0 description
EXPMUX: Legacy mode, use applications should use NEG_PORT/PIN_ADDR
DIAGMUX: Not applicable
SARMUX_VIRT: Special purpose, see SARMUX_VIRT description

LEGACY MODE DESCRIPTION:
Differential enable for the selected port pin for this channel.  If differential is enabled then POS_PIN_ADDR[0] is ignored and considered to be 0, i.e. POS_PIN_ADDR points to the even pin of a pin pair. For differential the even pin of the pair is connected to Vplus and the odd pin of the pair is connected to Vminus. POS_PORT_ADDR is used to identify the port that contains the pins.
- 0: The voltage on the addressed pin is measured (Single-ended) and the resulting value is stored in the corresponding data register.
- 1: The differential voltage on the addressed pin pair is measured and the resulting value is stored in the corresponding data register. (POS_PIN_ADDR[0] is ignored).

NOTE: Set to 0 if using the NEG_PIN_ADDR and NEG_PORT_ADDR to select the negative source.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_RESOLUTION</name>
              <description>Resolution for this channel.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>12B</name>
                  <description>12-bit resolution is used for this channel.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SUBRES</name>
                  <description>The resolution specified by SUB_RESOLUTION in the SAR_SAMPLE_CTRL register is used for this channel.</description>
                  <value>1</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INJ_AVG_EN</name>
              <description>Averaging enable for this channel. If set the AVG_CNT and AVG_SHIFT settings are used for sampling the addressed pin(s)</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_SAMPLE_TIME_SEL</name>
              <description>Injection sample time select: select which of the 4 global sample times to use for this channel</description>
              <bitRange>[13:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_NEG_PIN_ADDR</name>
              <description>Address of the neg pin to be sampled by the injection channel.</description>
              <bitRange>[18:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_NEG_PORT_ADDR</name>
              <description>Address of the neg port that contains the pin to be sampled by the injection channel.</description>
              <bitRange>[22:20]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>SARMUX</name>
                  <description>SARMUX pins.</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>EXPMUX</name>
                  <description>GPIO Expansion Mux (if present)</description>
                  <value>5</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>DIAGMUX</name>
                  <description>Diagnostic  inputs</description>
                  <value>6</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>SARMUX_VIRT</name>
                  <description>SARMUX virtual port (VPORT0)</description>
                  <value>7</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
            <field>
              <name>INJ_NEG_ADDR_EN</name>
              <description>1 - The NEG_PIN_ADDR and NEG_PORT_ADDR determines what drives the Vminus pin. This is a variation of differential mode with no even-odd pair limitation                                                                                                                                0 -  The NEG_SEL determines what drives the Vminus pin.

DIFFERENTIAL_EN must be set to 0 for this feature to work correctly.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_DIAG_VPLUS_SOURCE</name>
              <description>Enable for 10uA current source on vplus signal, active during sampling of this channel</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_DIAG_VPLUS_SINK</name>
              <description>Enable for 10uA current sink on vplus signal, active during sampling of this channel</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_DIAG_VMINUS_SOURCE</name>
              <description>Enable for 10uA current source on vminus signal, active during sampling of this channel</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_DIAG_VMINUS_SINK</name>
              <description>Enable for 10uA current sink on vminus signal, active during sampling of this channel</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_TAILGATING</name>
              <description>Injection channel tailgating.
- 0: no tailgating for this channel, SAR is immediately triggered when the INJ_START_EN bit is set if the SAR is not busy. If the SAR is busy, the INJ
     channel addressed pin is sampled at the end of the current scan.
- 1: injection channel tailgating. The addressed pin is sampled after the next trigger and after all enabled channels have been scanned.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>INJ_START_EN</name>
              <description>Set by firmware to enable the injection channel. If INJ_TAILGATING is not set this bit also functions as trigger for this channel. Cleared by hardware after this channel has been sampled (i.e. this channel is always one shot even if CONTINUOUS is set). Also cleared if the SAR is disabled.

NOTE: If the intent is to trigger an injection channel with no tailgaiting (immediately if not busy), just prior to a firmware trigger, the following sequence must be followed to ensure that the injection channel starts first:
- Trigger injection channel (set this bit to 1)
- Poll for busy (wait for STATUS.SAR_BUSY == 1)
- Trigger the scan (START_CTRL.FW_TRIGGER set to 1)</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>INJ_RESULT</name>
          <description>Injection channel result register</description>
          <addressOffset>0x290</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF0000000</resetMask>
          <fields>
            <field>
              <name>INJ_RESULT</name>
              <description>SAR conversion result of the channel.</description>
              <bitRange>[15:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_COLLISION_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_INTR register</description>
              <bitRange>[28:28]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_SATURATE_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_INTR register</description>
              <bitRange>[29:29]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_RANGE_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_INTR register</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INJ_EOC_INTR_MIR</name>
              <description>mirror bit of corresponding bit in SAR_INTR register</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>STATUS</name>
          <description>Current status of internal SAR registers (mostly for debug)</description>
          <addressOffset>0x2A0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xC000003F</resetMask>
          <fields>
            <field>
              <name>CUR_CHAN</name>
              <description>current channel being sampled (channel 16 indicates the injection channel), only valid if BUSY.</description>
              <bitRange>[5:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>SW_VREF_NEG</name>
              <description>the current switch status, including DSI and sequencer controls, of the switch in the SARADC that shorts NEG with VREF input (see NEG_SEL).</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>BUSY</name>
              <description>If high then the SAR is busy with a conversion. This bit is always high when CONTINUOUS is set. Firmware should wait for this bit to be low before putting the SAR in power down.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>AVG_STAT</name>
          <description>Current averaging status (for debug)</description>
          <addressOffset>0x2A4</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF8FFFFF</resetMask>
          <fields>
            <field>
              <name>CUR_AVG_ACCU</name>
              <description>the current value of the averaging accumulator</description>
              <bitRange>[19:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>INTRLV_BUSY</name>
              <description>If high then the SAR is in the middle of Interleaved averaging spanning several scans. While this bit is high the Firmware should not make any changes to the configuration registers otherwise some results may be incorrect. Note that the CUR_AVG_CNT status register below gives an indication how many more scans need to be done to complete the Interleaved averaging.
This bit can be cleared by changing the averaging mode to ACCUNDUMP or by disabling the SAR.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CUR_AVG_CNT</name>
              <description>the current value of the averaging counter. Note that the value shown is updated after the sampling time and therefore runs ahead of the accumulator update.</description>
              <bitRange>[31:24]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MUX_SWITCH0</name>
          <description>SARMUX Firmware switch controls</description>
          <addressOffset>0x300</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>MUX_FW_P0_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P0 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P1_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P1 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P2_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P2 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P3_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P3 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P4_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P4 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P5_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P5 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P6_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P6 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P7_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P7 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P0_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P0 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P1_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P1 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P2_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P2 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P3_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P3 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P4_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P4 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P5_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P5 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P6_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P6 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P7_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P7 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_VSSA_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between vssa_kelvin and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_TEMP_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between temperature sensor and vplus signal, also powers on the temperature sensor. Write with '1' to set bit.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSA_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between amuxbusa and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSB_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between amuxbusb and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSA_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between amuxbusa and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSB_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between amuxbusb and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS0_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between sarbus0 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS1_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between sarbus1 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS0_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between sarbus0 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS1_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between sarbus1 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P4_COREIO0</name>
              <description>Firmware control: 0=open, 1=close switch between P4 and coreio0 signal. Write with '1' to set bit.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P5_COREIO1</name>
              <description>Firmware control: 0=open, 1=close switch between P5 and coreio1 signal. Write with '1' to set bit.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P6_COREIO2</name>
              <description>Firmware control: 0=open, 1=close switch between P6 and coreio2 signal. Write with '1' to set bit.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P7_COREIO3</name>
              <description>Firmware control: 0=open, 1=close switch between P7 and coreio3 signal. Write with '1' to set bit.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MUX_SWITCH_CLEAR0</name>
          <description>SARMUX Firmware switch control clear</description>
          <addressOffset>0x304</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FFFFFFF</resetMask>
          <fields>
            <field>
              <name>MUX_FW_P0_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P1_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P2_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P3_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P4_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P5_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P6_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P7_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P0_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P1_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P2_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P3_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P4_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P5_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P6_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P7_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_VSSA_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_TEMP_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSA_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSB_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSA_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSB_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS0_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS1_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS0_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS1_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P4_COREIO0</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P5_COREIO1</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P6_COREIO2</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P7_COREIO3</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH0</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MUX_SWITCH1</name>
          <description>SARMUX Firmware switch controls</description>
          <addressOffset>0x308</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>MUX_FW_P4_DFT_INP</name>
              <description>Firmware control: 0=open, 1=close switch between P4 pin and dft_inp signal. Write with '1' to set bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P5_DFT_INM</name>
              <description>Firmware control: 0=open, 1=close switch between P5 pin and dft_inm signal. Write with '1' to set bit.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_ADFT0_SARBUS0</name>
              <description>Firmware control: 0=open, 1=close switch between adft0 signal and sarbus0 signal. Write with '1' to set bit.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_ADFT1_SARBUS1</name>
              <description>Firmware control: 0=open, 1=close switch between adft1 signal and sarbus1 signal. Write with '1' to set bit.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MUX_SWITCH_CLEAR1</name>
          <description>SARMUX Firmware switch control clear</description>
          <addressOffset>0x30C</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>MUX_FW_P4_DFT_INP</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH1</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_P5_DFT_INM</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH1</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_ADFT0_SARBUS0</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH1</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_ADFT1_SARBUS1</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH1</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MUX_SWITCH2</name>
          <description>EXPMUX and DIAGMUX Firmware switch controls</description>
          <addressOffset>0x310</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MUX_FW_EXP_P0_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P0 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_EXP_P1_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P1 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_EXP_P2_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P2 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_EXP_P3_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P3 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_EXP_P4_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P4 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_EXP_P5_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P5 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_EXP_P6_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P6 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_EXP_P7_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P7 and vplus signal. Write with '1' to set bit.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_EXP_P0_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P0 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_EXP_P1_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P1 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_EXP_P2_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P2 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_EXP_P3_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P3 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_EXP_P4_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P4 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_EXP_P5_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P5 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_EXP_P6_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P6 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_EXP_P7_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between pin P7 and vminus signal. Write with '1' to set bit.</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_VD0_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between internal Vdiag.0 and vplus signal . Write with '1' to set bit.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_VD1_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between internal Vdiag.1 and vplus signal . Write with '1' to set bit.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_VD2_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between internal Vdiag.2 and vplus signal . Write with '1' to set bit.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_VD3_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between internal Vdiag.3 and vplus signal . Write with '1' to set bit.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_VD4_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between internal Vdiag.4 and vplus signal . Write with '1' to set bit.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_VD5_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between internal Vdiag.5 and vplus signal . Write with '1' to set bit.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_VD6_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between internal Vdiag.6 and vplus signal . Write with '1' to set bit.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_VD7_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between internal Vdiag.7 and vplus signal . Write with '1' to set bit.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_VG0_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between internal Vgnd.0 and vplus signal . Write with '1' to set bit.</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_VG1_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between internal Vgnd.1 and vplus signal . Write with '1' to set bit.</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_VG2_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between internal Vgnd.2 and vplus signal . Write with '1' to set bit.</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_VG3_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between internal Vgnd.3 and vplus signal . Write with '1' to set bit.</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_CSRC_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between 10uA current source and the vplus signal  Write with '1' to set bit.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_CSINK_VPLUS</name>
              <description>Firmware control: 0=open, 1=close switch between 10uA current sink and the vplus signal  Write with '1' to set bit.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_CSRC_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between 10uA current source and the vplus signal  Write with '1' to set bit.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_CSINK_VMINUS</name>
              <description>Firmware control: 0=open, 1=close switch between 10uA current sink and the vminus signal  Write with '1' to set bit.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MUX_SWITCH_CLEAR2</name>
          <description>EXPMUX and DIAGMUX Firmware switch control clear</description>
          <addressOffset>0x314</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MUX_FW_EXP_P0_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH2</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_EXP_P1_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH2</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_EXP_P2_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH2</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_EXP_P3_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH2</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_EXP_P4_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH2</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_EXP_P5_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH2</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_EXP_P6_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH2</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_EXP_P7_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH2</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_EXP_P0_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH2</description>
              <bitRange>[8:8]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_EXP_P1_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH2</description>
              <bitRange>[9:9]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_EXP_P2_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH2</description>
              <bitRange>[10:10]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_EXP_P3_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH2</description>
              <bitRange>[11:11]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_EXP_P4_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH2</description>
              <bitRange>[12:12]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_EXP_P5_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH2</description>
              <bitRange>[13:13]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_EXP_P6_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH2</description>
              <bitRange>[14:14]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_EXP_P7_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH2</description>
              <bitRange>[15:15]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_VD0_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH2</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_VD1_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH2</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_VD2_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH2</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_VD3_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH2</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_VD4_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH2</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_VD5_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH2</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_VD6_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH2</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_VD7_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH2</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_VG0_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH2</description>
              <bitRange>[24:24]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_VG1_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH2</description>
              <bitRange>[25:25]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_VG2_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH2</description>
              <bitRange>[26:26]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_VG3_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH2</description>
              <bitRange>[27:27]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_CSRC_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH2</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_CSINK_VPLUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH2</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_CSRC_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH2</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_CSINK_VMINUS</name>
              <description>Write '1' to clear corresponding bit in MUX_SWITCH2</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MUX_SWITCH_HW_CTRL</name>
          <description>SARMUX switch hardware control</description>
          <addressOffset>0x340</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xCF00FF</resetMask>
          <fields>
            <field>
              <name>MUX_HW_CTRL_P0</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for pin P0 switches.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_P1</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for pin P1 switches.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_P2</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for pin P2 switches.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_P3</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for pin P3 switches.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_P4</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for pin P4 switches.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_P5</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for pin P5 switches.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_P6</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for pin P6 switches.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_P7</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for pin P7 switches.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_VSSA</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for vssa switch.</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_TEMP</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for temp switch.</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_AMUXBUSA</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for amuxbusa switches.</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_AMUXBUSB</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for amuxbusb switches.</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_SARBUS0</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for sarbus0 switches.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_SARBUS1</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for sarbus1 switches.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MUX_SWITCH_HW_CTRL2</name>
          <description>EXPMUX and DIAGMUX switch hardware control</description>
          <addressOffset>0x344</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF0FF00FF</resetMask>
          <fields>
            <field>
              <name>MUX_HW_CTRL_EXP_P0</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for pin P0 switches.</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_EXP_P1</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for pin P1 switches.</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_EXP_P2</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for pin P2 switches.</description>
              <bitRange>[2:2]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_EXP_P3</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for pin P3 switches.</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_EXP_P4</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for pin P4 switches.</description>
              <bitRange>[4:4]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_EXP_P5</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for pin P5 switches.</description>
              <bitRange>[5:5]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_EXP_P6</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for pin P6 switches.</description>
              <bitRange>[6:6]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_HW_CTRL_EXP_P7</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for pin P7 switches.</description>
              <bitRange>[7:7]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_VD0_VG0</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for Vdiag.0 and Vgnd.0 switches</description>
              <bitRange>[16:16]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_VD1_VG1</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for Vdiag.1 and Vgnd.1 switches</description>
              <bitRange>[17:17]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_VD2_VG2</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for Vdiag.2 and Vgnd.2 switches</description>
              <bitRange>[18:18]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_VD3_VG3</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for Vdiag.3 and Vgnd.3 switches</description>
              <bitRange>[19:19]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_VD4</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for Vdiag.4 switch.</description>
              <bitRange>[20:20]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_VD5</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for Vdiag.5 switch.</description>
              <bitRange>[21:21]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_VD6</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for Vdiag.6 switch.</description>
              <bitRange>[22:22]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_VD7</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for Vdiag.7 switch.</description>
              <bitRange>[23:23]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_CSRC_VPLUS</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting to close switch between 10uA current source and the vplus signal.</description>
              <bitRange>[28:28]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_CSINK_VPLUS</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for close switch between 10uA current sink and the vplus signal.</description>
              <bitRange>[29:29]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_CSRC_VMINUS</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting for close switch between 10uA current source and the vminus signal.</description>
              <bitRange>[30:30]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>MUX_FW_CSINK_VMINUS</name>
              <description>Hardware control: 0=only firmware control, 1=hardware control masked by firmware setting to close switch between 10uA current sink and the vminus signal.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MUX_SWITCH_STATUS</name>
          <description>SARMUX switch status</description>
          <addressOffset>0x350</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3FFFFFF</resetMask>
          <fields>
            <field>
              <name>MUX_FW_P0_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P1_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P2_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P3_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P4_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P5_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P6_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P7_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P0_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P1_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P2_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P3_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P4_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P5_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P6_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_P7_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_VSSA_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_TEMP_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSA_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[18:18]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSB_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[19:19]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSA_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[20:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_AMUXBUSB_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[21:21]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS0_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[22:22]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS1_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[23:23]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS0_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_SARBUS1_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH0</description>
              <bitRange>[25:25]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>MUX_SWITCH_STATUS2</name>
          <description>EXPMUX and DIAGMUX switch status</description>
          <addressOffset>0x354</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFFFFFFFF</resetMask>
          <fields>
            <field>
              <name>MUX_FW_EXP_P0_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH2</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_EXP_P1_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH2</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_EXP_P2_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH2</description>
              <bitRange>[2:2]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_EXP_P3_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH2</description>
              <bitRange>[3:3]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_EXP_P4_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH2</description>
              <bitRange>[4:4]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_EXP_P5_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH2</description>
              <bitRange>[5:5]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_EXP_P6_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH2</description>
              <bitRange>[6:6]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_EXP_P7_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH2</description>
              <bitRange>[7:7]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_EXP_P0_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH2</description>
              <bitRange>[8:8]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_EXP_P1_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH2</description>
              <bitRange>[9:9]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_EXP_P2_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH2</description>
              <bitRange>[10:10]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_EXP_P3_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH2</description>
              <bitRange>[11:11]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_EXP_P4_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH2</description>
              <bitRange>[12:12]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_EXP_P5_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH2</description>
              <bitRange>[13:13]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_EXP_P6_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH2</description>
              <bitRange>[14:14]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_EXP_P7_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH2</description>
              <bitRange>[15:15]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_VD0_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH2</description>
              <bitRange>[16:16]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_VD1_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH2</description>
              <bitRange>[17:17]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_VD2_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH2</description>
              <bitRange>[18:18]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_VD3_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH2</description>
              <bitRange>[19:19]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_VD4_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH2</description>
              <bitRange>[20:20]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_VD5_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH2</description>
              <bitRange>[21:21]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_VD6_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH2</description>
              <bitRange>[22:22]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_VD7_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH2</description>
              <bitRange>[23:23]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_VG0_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH2</description>
              <bitRange>[24:24]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_VG1_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH2</description>
              <bitRange>[25:25]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_VG2_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH2</description>
              <bitRange>[26:26]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_VG3_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH2</description>
              <bitRange>[27:27]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_CSRC_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH2</description>
              <bitRange>[28:28]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_CSINK_VPLUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH2</description>
              <bitRange>[29:29]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_CSRC_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH2</description>
              <bitRange>[30:30]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>MUX_FW_CSINK_VMINUS</name>
              <description>switch status of corresponding bit in MUX_SWITCH2</description>
              <bitRange>[31:31]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PUMP_CTRL</name>
          <description>Switch pump control</description>
          <addressOffset>0x380</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x80000001</resetMask>
          <fields>
            <field>
              <name>CLOCK_SEL</name>
              <description>Clock select: 0=external clock, 1=internal clock (deprecated).</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>ENABLED</name>
              <description>0=disabled: pump output is VDDA_PUMP, 1=enabled: pump output is boosted.</description>
              <bitRange>[31:31]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>ANA_TRIM</name>
          <description>Analog trim register.</description>
          <addressOffset>0xFF00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xF</resetMask>
          <fields>
            <field>
              <name>CAP_TRIM</name>
              <description>Attenuation cap trimming</description>
              <bitRange>[2:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>TRIMUNIT</name>
              <description>Attenuation cap trimming</description>
              <bitRange>[3:3]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>WOUNDING</name>
          <description>SAR wounding register</description>
          <addressOffset>0xFF04</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>WOUND_RESOLUTION</name>
              <description>Maximum SAR resolution allowed</description>
              <bitRange>[1:0]</bitRange>
              <access>read-write</access>
              <enumeratedValues>
                <enumeratedValue>
                  <name>12BIT</name>
                  <description>unwounded: up to full 12-bit SAR resolution allowed</description>
                  <value>0</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>10BIT</name>
                  <description>wounded: max resolution upto 10-bit SAR resolution allowed</description>
                  <value>1</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>8BIT</name>
                  <description>wounded: only 8-bit SAR resolution allowed</description>
                  <value>2</value>
                </enumeratedValue>
                <enumeratedValue>
                  <name>8BIT_TOO</name>
                  <description>wounded: only 8-bit SAR resolution allowed</description>
                  <value>3</value>
                </enumeratedValue>
              </enumeratedValues>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
    <peripheral>
      <name>PASS0</name>
      <description>PASS top-level MMIO (DSABv2, INTR)</description>
      <headerStructName>PASS</headerStructName>
      <baseAddress>0x403F0000</baseAddress>
      <addressBlock>
        <offset>0</offset>
        <size>65536</size>
        <usage>registers</usage>
      </addressBlock>
      <registers>
        <register>
          <name>INTR_CAUSE</name>
          <description>Interrupt cause register</description>
          <addressOffset>0x0</addressOffset>
          <size>32</size>
          <access>read-only</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3</resetMask>
          <fields>
            <field>
              <name>CTB0_INT</name>
              <description>CTB0 interrupt pending</description>
              <bitRange>[0:0]</bitRange>
              <access>read-only</access>
            </field>
            <field>
              <name>CTB1_INT</name>
              <description>CTB1 interrupt pending</description>
              <bitRange>[1:1]</bitRange>
              <access>read-only</access>
            </field>
          </fields>
        </register>
        <register>
          <name>DFT_CTRL</name>
          <description>DFT control register</description>
          <addressOffset>0x30</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x1</resetMask>
          <fields>
            <field>
              <name>DSAB_ADFT_RES_EN</name>
              <description>Close the switch to connect the DSAB ADFT resistor to the AMUXBUS</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <register>
          <name>PASS_CTRL</name>
          <description>PASS Control</description>
          <addressOffset>0x108</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0xFF03</resetMask>
          <fields>
            <field>
              <name>PMPCLK_BYP</name>
              <description>- 0: Pump clk is clk_hf/2
 - 1: Pump clk is selected from PMPCLK_SRC</description>
              <bitRange>[0:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>PMPCLK_SRC</name>
              <description>- 0: Pump clk is clk_hf
 - 1: Pump clk is direct from SRSS</description>
              <bitRange>[1:1]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>RMB_BITS</name>
              <description>Risk mitigation bits</description>
              <bitRange>[15:8]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
        <cluster>
          <name>DSAB</name>
          <description>DSAB configuration</description>
          <addressOffset>0x00000E00</addressOffset>
          <register>
            <name>DSAB_CTRL</name>
            <description>global DSAB control</description>
            <addressOffset>0x0</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0x910F0F3F</resetMask>
            <fields>
              <field>
                <name>CURRENT_SEL</name>
                <description>DSAB DAC control field

Nominal DSAB Output Current = CURRENT_SEL * 0.075 uA

In products with SRSS-LITE, this setting impacts the CTB(m) offset. A value of 0x20 is used during factory trim and is required to maintain low offsets across temperature variation. If a different setting is used then a periodic re-trim of CTB(m) offset should be performed.</description>
                <bitRange>[5:0]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>SEL_OUT</name>
                <description>N/A</description>
                <bitRange>[11:8]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>REF_SWAP_EN</name>
                <description>This field (along with SEL_OUT and ENABLED) provides bitwise selection of the current sources that drive the DSAB ZTC and PTAT outputs.

See SEL_OUT field for truth tables.</description>
                <bitRange>[19:16]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>BYPASS_MODE_EN</name>
                <description>0 - DSAB PTAT generator is powered from DSAB regulator: VDDA must be at least 2.4V
1 - DSAB PTAT generator is pwoered directly from VDDA: VDDA cannot exceed 4.0V</description>
                <bitRange>[24:24]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>STARTUP_RM</name>
                <description>Risk mitigation control                                                                                         
1 - Force start the startup circuit</description>
                <bitRange>[28:28]</bitRange>
                <access>read-write</access>
              </field>
              <field>
                <name>ENABLED</name>
                <description>This field (along with SEL_OUT and REF_SWAP_EN) provides bitwise selection of the current sources that drive the DSAB ZTC and PTAT outputs.
See SEL_OUT field for truth tables.
In SRSSLT devices, in active mode, this bit is overridden to '1', that is - it is always enabled in active mode.</description>
                <bitRange>[31:31]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
          <register>
            <name>DSAB_DFT</name>
            <description>DFT bits</description>
            <addressOffset>0x4</addressOffset>
            <size>32</size>
            <access>read-write</access>
            <resetValue>0x0</resetValue>
            <resetMask>0xF</resetMask>
            <fields>
              <field>
                <name>EN_DFT</name>
                <description>- 0: DSAB DFT disabled
- 1: DSAB DFT enabled (connect output to amuxbus)

0001 - PTAT&lt;0&gt;
0010 - PTAT&lt;1&gt;
0011 - PTAT&lt;1:0&gt;
0100 - PTAT&lt;2&gt;
0111 - PTAT&lt;2:0&gt;
1000 - PTAT&lt;3&gt;
1111 - PTAT&lt;3:0&gt; 
1001 - DSAB Reg Out</description>
                <bitRange>[3:0]</bitRange>
                <access>read-write</access>
              </field>
            </fields>
          </register>
        </cluster>
        <register>
          <name>DSAB_TRIM</name>
          <description>DSAB Trim bits</description>
          <addressOffset>0xFF00</addressOffset>
          <size>32</size>
          <access>read-write</access>
          <resetValue>0x0</resetValue>
          <resetMask>0x3F</resetMask>
          <fields>
            <field>
              <name>IBIAS_TRIM</name>
              <description>1111=lowest, 0000=highest</description>
              <bitRange>[3:0]</bitRange>
              <access>read-write</access>
            </field>
            <field>
              <name>DSAB_RMB_BITS</name>
              <description>Risk mitigation bits</description>
              <bitRange>[5:4]</bitRange>
              <access>read-write</access>
            </field>
          </fields>
        </register>
      </registers>
    </peripheral>
  </peripherals>
</device>